{"0":{
  "id": "RUSTSEC-2021-0121",
  "modified": "2021-10-18T16:22:07Z",
  "published": "2021-10-08T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Non-aligned u32 read in Chacha20 encryption and decryption",
  "details": "The implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to `std::slice::from_raw_parts_mut`, which breaks the contract and introduces undefined behavior.\n\nThis affects Chacha20 encryption and decryption in crypto2.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "crypto2",
        "purl": "pkg:cargo/crypto2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "crypto2::streamcipher::Chacha20::decrypt_slice",
            "crypto2::streamcipher::Chacha20::encrypt_slice",
            "crypto2::streamcipher::xor_si512_inplace"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/crypto2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0121.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/shadowsocks/crypto2/issues/27"
    }
  ]
},"1":{
  "id": "RUSTSEC-2021-0064",
  "modified": "2021-05-06T23:45:32Z",
  "published": "2021-05-06T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`cpuid-bool` has been renamed to `cpufeatures`",
  "details": "Please use the `cpufeatures`` crate going forward:\n\n<https://github.com/RustCrypto/utils/tree/master/cpufeatures>\n\nThere will be no further releases of `cpuid-bool`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cpuid-bool",
        "purl": "pkg:cargo/cpuid-bool"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cpuid-bool"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0064.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/utils/pull/381"
    }
  ]
},"2":{
  "id": "RUSTSEC-2018-0019",
  "modified": "2021-08-22T01:18:11Z",
  "published": "2018-06-08T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Multiple memory safety issues",
  "details": "Affected versions contain multiple memory safety issues, such as:\n\n - Unsoundly coercing immutable references to mutable references\n - Unsoundly extending lifetimes of strings\n - Adding the `Send` marker trait to objects that cannot be safely sent between threads\n\nThis may result in a variety of memory corruption scenarios, most likely use-after-free.\n \nA significant refactoring effort has been conducted to resolve these issues.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "actix-web",
        "purl": "pkg:cargo/actix-web"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.15"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/actix-web"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0019.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/actix/actix-web/issues/289"
    }
  ]
},"3":{
  "id": "RUSTSEC-2020-0078",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-07T12:00:00Z",
  "aliases": [
    "CVE-2020-35919"
  ],
  "related": [],
  "summary": "`net2` invalidly assumes the memory layout of std::net::SocketAddr",
  "details": "The [`net2`](https://crates.io/crates/net2) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "net2",
        "purl": "pkg:cargo/net2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.36"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/net2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0078.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/deprecrated/net2-rs/issues/105"
    }
  ]
},"4":{
  "id": "RUSTSEC-2019-0005",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-06-15T12:00:00Z",
  "aliases": [
    "CVE-2019-15546"
  ],
  "related": [],
  "summary": "Format string vulnerabilities in `pancurses`",
  "details": "`pancurses::mvprintw` and `pancurses::printw` passes a pointer from a rust `&str` to C,\nallowing hostile input to execute a format string attack, which trivially allows writing\narbitrary data to stack memory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "pancurses",
        "purl": "pkg:cargo/pancurses"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "pancurses::mvprintw",
            "pancurses::printw"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/pancurses"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0005.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/106"
    }
  ]
},"5":{
  "id": "RUSTSEC-2020-0097",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36205"
  ],
  "related": [],
  "summary": "Soundness issue with base::Error",
  "details": "`base::Error` type contains public field named `ptr`.\nWith this definition, it is possible to create a `base::Error` with an invalid pointer and trigger memory safety errors\nsuch as use-after-free or double-free with safe Rust.\n\nThe users of `xcb` crate are advised not to manipulate the field.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "xcb",
        "purl": "pkg:cargo/xcb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/xcb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0097.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rtbo/rust-xcb/issues/93"
    }
  ]
},"6":{
  "id": "RUSTSEC-2021-0033",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-22T12:00:00Z",
  "aliases": [
    "CVE-2021-28034",
    "CVE-2021-28035"
  ],
  "related": [],
  "summary": "push_cloned can drop uninitialized memory or double free on panic",
  "details": "Affected versions of `stack_dst` used a `push_inner` function that increased\nthe internal length of the array and then called `val.clone()`.\n\nIf the `val.clone()` call panics, the stack could drop an already dropped\nelement or drop uninitialized memory.\n\nThis issue was fixed in `2a4d538` by increasing the length of the array after\nelements are cloned.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stack_dst",
        "purl": "pkg:cargo/stack_dst"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "stack_dst::StackA::push_cloned"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stack_dst"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0033.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/thepowersgang/stack_dst-rs/issues/5"
    }
  ]
},"7":{
  "id": "RUSTSEC-2019-0013",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-08-27T12:00:00Z",
  "aliases": [
    "CVE-2019-16137"
  ],
  "related": [],
  "summary": "Wrong memory orderings in RwLock potentially violates mutual exclusion",
  "details": "Wrong memory orderings inside the RwLock implementation allow for two writers to acquire the lock at the same time. The drop implementation used Ordering::Relaxed, which allows the compiler or CPU to reorder a mutable access on the locked data after the lock has been yielded.\n\nOnly users of the RwLock implementation are affected. Users of Once (including users of lazy_static with the `spin_no_std` feature enabled) are NOT affected.\n\nOn strongly ordered CPU architectures like x86, the only real way that this would lead to a memory corruption is if the compiler reorders an access after the lock is yielded, which is possible but in practice unlikely. It is a more serious issue on weakly ordered architectures such as ARM which, except in the presence of certain instructions, allow the hardware to decide which accesses are seen at what times. Therefore on an ARM system it is likely that using the wrong memory ordering would result in a memory corruption, even if the compiler itself doesn't reorder the memory accesses in a buggy way.\n\nThe flaw was corrected by https://github.com/mvdnes/spin-rs/pull/66.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "spin",
        "purl": "pkg:cargo/spin"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "spin::RwLock::new"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/spin"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0013.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/mvdnes/spin-rs/issues/65"
    }
  ]
},"8":{
  "id": "RUSTSEC-2020-0081",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [
    "CVE-2020-35922"
  ],
  "related": [],
  "summary": "`mio` invalidly assumes the memory layout of std::net::SocketAddr",
  "details": "The [`mio`](https://crates.io/crates/mio) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "mio",
        "purl": "pkg:cargo/mio"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.7.0","<": "0.7.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/mio"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0081.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tokio-rs/mio/issues/1386"
    }
  ]
},"9":{
  "id": "RUSTSEC-2016-0001",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2016-11-05T12:00:00Z",
  "aliases": [
    "CVE-2016-10931"
  ],
  "related": [],
  "summary": "SSL/TLS MitM vulnerability due to insecure defaults",
  "details": "All versions of rust-openssl prior to 0.9.0 contained numerous insecure defaults\nincluding off-by-default certificate verification and no API to perform hostname\nverification.\n\nUnless configured correctly by a developer, these defaults could allow an attacker\nto perform man-in-the-middle attacks.\n\nThe problem was addressed in newer versions by enabling certificate verification\nby default and exposing APIs to perform hostname verification. Use the\n`SslConnector` and `SslAcceptor` types to take advantage of these new features\n(as opposed to the lower-level `SslContext` type).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl",
        "purl": "pkg:cargo/openssl"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2016-0001.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/sfackler/rust-openssl/releases/tag/v0.9.0"
    }
  ]
},"10":{
  "id": "RUSTSEC-2021-0025",
  "modified": "2021-02-15T16:43:30Z",
  "published": "2021-02-15T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `qjsonrpc`",
  "details": "This crate has been renamed from `jsonrpc-quic` to `qjsonrpc`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_api>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "jsonrpc-quic",
        "purl": "pkg:cargo/jsonrpc-quic"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/jsonrpc-quic"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0025.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_api/pull/623"
    }
  ]
},"11":{
  "id": "RUSTSEC-2020-0039",
  "modified": "2021-01-04T17:02:59Z",
  "published": "2020-09-03T12:00:00Z",
  "aliases": [
    "CVE-2020-35892",
    "CVE-2020-35893"
  ],
  "related": [],
  "summary": "`index()` allows out-of-bound read and `remove()` has off-by-one error",
  "details": "`Slab::index()` does not perform the boundary checking, which leads to out-of-bound read access. `Slab::remove()` copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "simple-slab",
        "purl": "pkg:cargo/simple-slab"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/simple-slab"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0039.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/nathansizemore/simple-slab/issues/2"
    }
  ]
},"12":{
  "id": "RUSTSEC-2021-0072",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-07-07T12:00:00Z",
  "aliases": [
    "CVE-2021-38191"
  ],
  "related": [],
  "summary": "Task dropped in wrong thread when aborting `LocalSet` task",
  "details": "When aborting a task with `JoinHandle::abort`, the future is dropped in the\nthread calling abort if the task is not currently being executed. This is\nincorrect for tasks spawned on a `LocalSet`.\n\nThis can easily result in race conditions as many projects use `Rc` or `RefCell`\nin their Tokio tasks for better performance.\n\nSee [tokio#3929][issue] for more details.\n\n[issue]: https://github.com/tokio-rs/tokio/issues/3929",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tokio",
        "purl": "pkg:cargo/tokio"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "tokio::task::JoinHandle::abort"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.0","<": "1.5.1"
            },
            {
              ">=": "1.6.0","<": "1.6.3"
            },
            {
              ">=": "1.7.0","<": "1.7.2"
            },
            {
              ">=": "1.8.0","<": "1.8.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tokio"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0072.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tokio-rs/tokio/issues/3929"
    }
  ]
},"13":{
  "id": "RUSTSEC-2020-0107",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36215"
  ],
  "related": [],
  "summary": "hashconsing's HConsed lacks Send/Sync bound for its Send/Sync trait.",
  "details": "Affected versions of `hashconsing` implements `Send`/`Sync` for its `HConsed` type without restricting it to `Send`able types and `Sync`able types.\n\nThis allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hashconsing",
        "purl": "pkg:cargo/hashconsing"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.1.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hashconsing"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0107.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/AdrienChampion/hashconsing/issues/1"
    }
  ]
},"14":{
  "id": "RUSTSEC-2020-0042",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-24T12:00:00Z",
  "aliases": [
    "CVE-2020-35895"
  ],
  "related": [],
  "summary": "Missing check in ArrayVec leads to out-of-bounds write.",
  "details": "ArrayVec::insert allows insertion of an element into the array object into the\nspecified index. Due to a missing check on the upperbound of this index, it is\npossible to write out of bounds.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stack",
        "purl": "pkg:cargo/stack"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stack"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0042.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/arcnmx/stack-rs/issues/4"
    }
  ]
},"15":{
  "id": "RUSTSEC-2021-0009",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-10T12:00:00Z",
  "aliases": [
    "CVE-2021-25906"
  ],
  "related": [],
  "summary": "panic safety issue in `impl TransformContent<S, D> for [S; (2|3|4)]`",
  "details": "Affected versions of this crate did not guard against double drop while temporarily duplicating objects' ownership using `ptr::read()`. Upon panic in a user-provided function `conversion`, objects that are copied by `ptr::read()` are dropped twice, leading to memory corruption.\n\nThe flaw was corrected in v0.9.2 by using `ManuallyDrop<T>` to enclose objects that are to be temporarily duplicated.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "basic_dsp_matrix",
        "purl": "pkg:cargo/basic_dsp_matrix"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/basic_dsp_matrix"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0009.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/liebharc/basic_dsp/issues/47"
    }
  ]
},"16":{
  "id": "RUSTSEC-2020-0150",
  "modified": "2022-02-21T21:23:42Z",
  "published": "2020-12-17T12:00:00Z",
  "aliases": [
    "CVE-2020-36470"
  ],
  "related": [],
  "summary": "RingBuffer can create multiple mutable references and cause data races",
  "details": "The `RingBuffer` type retrieves mutable references from the `DataProvider` in a\nnon-atomic manner, potentially allowing the creation of multiple mutable\nreferences. `RingBuffer` also implements the `Send` and `Sync` traits for all\ntypes `T`.\n\nThis allows undefined behavior from the aliased mutable references as well\nas data races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "disrustor",
        "purl": "pkg:cargo/disrustor"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/disrustor"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0150.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/sklose/disrustor/issues/1"
    }
  ]
},"17":{
  "id": "RUSTSEC-2020-0015",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-04-25T12:00:00Z",
  "aliases": [
    "CVE-2020-1967"
  ],
  "related": [],
  "summary": "Crash causing Denial of Service attack",
  "details": "Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 \nhandshake may crash due to a NULL pointer dereference as a result of incorrect handling of the \n\"signature_algorithms_cert\" TLS extension. The crash occurs if an invalid or unrecognised signature \nalgorithm is received from the peer. This could be exploited by a malicious peer in a Denial of \nService attack.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "111.6.0","<": "111.9.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0015.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20200421.txt"
    }
  ]
},"18":{
  "id": "RUSTSEC-2020-0146",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-04-09T12:00:00Z",
  "aliases": [
    "CVE-2020-36465"
  ],
  "related": [],
  "summary": "arr! macro erases lifetimes",
  "details": "Affected versions of this crate allowed unsoundly extending\nlifetimes using `arr!` macro. This may result in a variety of\nmemory corruption scenarios, most likely use-after-free.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "generic-array",
        "purl": "pkg:cargo/generic-array"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.8.0","<": "0.8.4"
            },
            {
              ">=": "0.9.0","<": "0.9.1"
            },
            {
              ">=": "0.10.0","<": "0.10.1"
            },
            {
              ">=": "0.11.0","<": "0.11.2"
            },
            {
              ">=": "0.12.0","<": "0.12.4"
            },
            {
              ">=": "0.13.0","<": "0.13.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/generic-array"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0146.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/fizyk20/generic-array/issues/98"
    }
  ]
},"19":{
  "id": "RUSTSEC-2020-0003",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2020-01-20T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "rust_sodium is unmaintained; switch to a modern alternative",
  "details": "The `rust_sodium` crate is no longer maintained by its current owner, who\nadvise in the repository readme that they are looking for\nsomeone else to take ownership of it.\n\nWe recommend you switch to an alternative crate such as:\n- [`sodiumoxide`](https://crates.io/crates/sodiumoxide)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rust_sodium",
        "purl": "pkg:cargo/rust_sodium"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.10.3-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rust_sodium"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0003.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/rust_sodium/pull/117"
    }
  ]
},"20":{
  "id": "RUSTSEC-2021-0048",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-19T12:00:00Z",
  "aliases": [
    "CVE-2021-29939"
  ],
  "related": [],
  "summary": "StackVec::extend can write out of bounds when size_hint is incorrect",
  "details": "`StackVec::extend` used the lower and upper bounds from an Iterator's\n`size_hint` to determine how many items to push into the stack based vector.\n\nIf the `size_hint` implementation returned a lower bound that was larger than\nthe upper bound, `StackVec` would write out of bounds and overwrite memory\non the stack. As mentioned by the [size_hint](https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods)\ndocumentation, `size_hint` is mainly for optimization and incorrect\nimplementations should not lead to memory safety issues.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stackvector",
        "purl": "pkg:cargo/stackvector"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.9"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stackvector"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0048.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Alexhuszagh/rust-stackvector/issues/2"
    }
  ]
},"21":{
  "id": "RUSTSEC-2020-0111",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36217"
  ],
  "related": [],
  "summary": "may_queue's Queue lacks Send/Sync bound for its Send/Sync trait.",
  "details": "Affected versions of `may_queue` implements `Send`/`Sync` for its `Queue` type without restricting it to `Send`able types and `Sync`able types.\n\nThis allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "may_queue",
        "purl": "pkg:cargo/may_queue"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/may_queue"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0111.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Xudong-Huang/may/issues/88"
    }
  ]
},"22":{
  "id": "RUSTSEC-2019-0029",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-10-22T12:00:00Z",
  "aliases": [
    "CVE-2019-25005"
  ],
  "related": [],
  "summary": "ChaCha20 counter overflow can expose repetitions in the keystream",
  "details": "The ChaCha20 stream cipher can produce a maximum of 2^32 blocks (~256GB)\nbefore the 32-bit counter overflows. Releases of the `chacha20` crate prior\nto v0.2.3 allow generating keystreams larger than this, including seeking\npast the limit. When this occurs, the keystream is duplicated, with failure\nmodes similar to nonce reuse (i.e. exposure of the XOR of two plaintexts).\n\nThe v0.2.3 release now panics in this event, rather than exposing the\nduplicated keystream. Note this is a \"hot fix\" solution to the problem\nand future releases will pursue returning an error in this case.\n\nUsers of the `chacha20poly1305` crate are unaffected by this as this crate\nproperly asserts the length of the plaintext is less than the maximum allowed\n(`P_MAX` as described in RFC 8439 Section 2.8).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "chacha20",
        "purl": "pkg:cargo/chacha20"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/chacha20"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0029.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/stream-ciphers/pull/64"
    }
  ]
},"23":{
  "id": "RUSTSEC-2020-0054",
  "modified": "2021-06-29T22:08:30Z",
  "published": "2020-10-16T12:00:00Z",
  "withdrawn": "2021-04-19T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "directories is unmaintained, use directories-next instead",
  "details": "The `directories` crate is not maintained any more;\nuse [`directories-next`](https://crates.io/crates/directories-next) instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "directories",
        "purl": "pkg:cargo/directories"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/directories"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0054.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/dirs-dev/directories-rs"
    }
  ]
},"24":{
  "id": "RUSTSEC-2021-0087",
  "modified": "2021-08-22T01:27:48Z",
  "published": "2021-01-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "columnar: `Read` on uninitialized buffer may cause UB (ColumnarReadExt::read_typed_vec())",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (`ColumnarReadExt::read_typed_vec()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "columnar",
        "purl": "pkg:cargo/columnar"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/columnar"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0087.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/frankmcsherry/columnar/issues/6"
    }
  ]
},"25":{
  "id": "RUSTSEC-2018-0015",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2018-11-19T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "term is looking for a new maintainer",
  "details": "The author of the `term` crate does not have time to maintain it and is looking\nfor a new maintainer.\n\nSome maintained alternatives you can potentially switch to instead, depending\non your needs:\n\n- [`crossterm`](https://github.com/crossterm-rs/crossterm)\n- [`termcolor`](https://crates.io/crates/termcolor)\n- [`yansi`](https://crates.io/crates/yansi)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "term",
        "purl": "pkg:cargo/term"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.2-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/term"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0015.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Stebalien/term/issues/93"
    }
  ]
},"26":{
  "id": "RUSTSEC-2021-0068",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-05-19T12:00:00Z",
  "aliases": [
    "CVE-2021-38188"
  ],
  "related": [],
  "summary": "Soundness issue in `iced-x86` versions <= 1.10.3",
  "details": "Versions of iced-x86 <= 1.10.3 invoke undefined behavior which may cause soundness\nissues in crates using the `iced_x86::Decoder` struct. The `Decoder::new()` function\nmade a call to `slice.get_unchecked(slice.length())` to get the end position of \nthe input buffer. The flaw was fixed with safe logic that does not invoke undefined\nbehavior.\n\nMore details can be found at <https://github.com/icedland/iced/issues/168>.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "iced-x86",
        "purl": "pkg:cargo/iced-x86"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "iced_x86::Decoder::new"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.10.4-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/iced-x86"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0068.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/icedland/iced/issues/168"
    }
  ]
},"27":{
  "id": "RUSTSEC-2020-0023",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-02-11T12:00:00Z",
  "aliases": [
    "CVE-2020-35879"
  ],
  "related": [],
  "summary": "Lifetime boundary for `raw_slice` and `raw_slice_mut` are incorrect",
  "details": "The affected version of `rulinalg` has incorrect lifetime boundary definitions\nfor `RowMut::raw_slice` and `RowMut::raw_slice_mut`. They do not conform with\nRust's borrowing rule and allows the user to create multiple mutable references\nto the same location. This may result in unexpected calculation result and data\nrace if both references are used at the same time.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rulinalg",
        "purl": "pkg:cargo/rulinalg"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rulinalg::matrix::RowMut::raw_slice",
            "rulinalg::matrix::RowMut::raw_slice_mut"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rulinalg"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0023.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/AtheMathmo/rulinalg/issues/201"
    }
  ]
},"28":{
  "id": "RUSTSEC-2017-0007",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2017-04-17T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "lz4-compress is unmaintained",
  "details": "[According to the developers](https://gitlab.redox-os.org/redox-os/tfs/issues/89) this crate is no longer maintained.\n\nThe suggested alternative is [`lz4-compression`](https://crates.io/crates/lz4-compression), a maintained fork of `lz4-compress`.\n\nSee also [lz-fear](https://crates.io/crates/lz-fear) which is compatible with the reference LZ4 implementation in C, but not with lz4-compress.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lz4-compress",
        "purl": "pkg:cargo/lz4-compress"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lz4-compress"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0007.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.redox-os.org/redox-os/tfs/issues/89"
    }
  ]
},"29":{
  "id": "RUSTSEC-2019-0009",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-06-06T12:00:00Z",
  "aliases": [
    "CVE-2019-15551"
  ],
  "related": [],
  "summary": "Double-free and use-after-free in SmallVec::grow()",
  "details": "Attempting to call `grow` on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents.\n\nAn attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.\n\nCredits to @ehuss for discovering, reporting and fixing the bug.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "smallvec",
        "purl": "pkg:cargo/smallvec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "smallvec::SmallVec::grow"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.5","<": "0.6.10"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/smallvec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0009.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/servo/rust-smallvec/issues/148"
    }
  ]
},"30":{
  "id": "RUSTSEC-2020-0074",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-28T12:00:00Z",
  "aliases": [
    "CVE-2020-35917"
  ],
  "related": [],
  "summary": "Reference counting error in `From<Py<T>>`",
  "details": "A bug in `From<Py<T>>` would lead to an extra reference count decrement, often\nleading to use-after-free issues.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "pyo3",
        "purl": "pkg:cargo/pyo3"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.12.0","<": "0.12.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/pyo3"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0074.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/PyO3/pyo3/pull/1297"
    }
  ]
},"31":{
  "id": "RUSTSEC-2020-0131",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-14T12:00:00Z",
  "aliases": [
    "CVE-2020-36451"
  ],
  "related": [],
  "summary": "Send/Sync bound needed on T  for Send/Sync impl of RcuCell<T>",
  "details": "Affected versions of this crate unconditionally implement Send/Sync for `RcuCell<T>`.\nThis allows users to send `T: !Send` to other threads (while `T` enclosed within `RcuCell<T>`), and allows users to concurrently access `T: !Sync` by using the APIs of `RcuCell<T>` that provide access to `&T`.\n\nThis can result in memory corruption caused by data races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rcu_cell",
        "purl": "pkg:cargo/rcu_cell"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rcu_cell"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0131.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Xudong-Huang/rcu_cell/issues/3"
    }
  ]
},"32":{
  "id": "RUSTSEC-2021-0029",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-17T12:00:00Z",
  "aliases": [
    "CVE-2021-28030"
  ],
  "related": [],
  "summary": "Tape::take_bytes exposes uninitialized memory to a user-provided Read",
  "details": "Affected versions of this crate passed an unininitialized buffer to a\nuser-provided `Read` instance in `Tape::take_bytes`.\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\nThe flaw was corrected in commit `1f2dc7f37dd` by removing the unsafe block\nand zero-initializing the buffer.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "truetype",
        "purl": "pkg:cargo/truetype"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.30.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/truetype"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0029.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bodoni/truetype/issues/11"
    }
  ]
},"33":{
  "id": "RUSTSEC-2020-0062",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-24T12:00:00Z",
  "aliases": [
    "CVE-2020-35908"
  ],
  "related": [],
  "summary": "Improper `Sync` implementation on `FuturesUnordered` in futures-utils can cause data corruption",
  "details": "Affected versions of the crate had an unsound `Sync` implementation on the `FuturesUnordered` structure, which used a `Cell` for\ninterior mutability without any code to handle synchronized access to the underlying task list's length and head safely.\n\nThis could of lead to data corruption since two threads modifying the list at once could see incorrect values due to the lack\nof access synchronization.\n\nThe issue was fixed by adding access synchronization code around insertion of tasks into the list.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "futures-util",
        "purl": "pkg:cargo/futures-util"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "futures_util::stream::FuturesUnordered"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.0","<": "0.3.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/futures-util"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0062.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-lang/futures-rs/issues/2050"
    }
  ]
},"34":{
  "id": "RUSTSEC-2020-0127",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-18T12:00:00Z",
  "aliases": [
    "CVE-2020-36447"
  ],
  "related": [],
  "summary": "SyncRef's clone() and debug() allow data races",
  "details": "Affected versions of this crate unconditionally implement `Sync` for `SyncRef<T>`.\nThis definition allows data races if `&T` is accessible through `&SyncRef`.\n\n`SyncRef<T>` derives `Clone` and `Debug`, and the default implementations of those traits access `&T` by invoking `T::clone()` & `T::fmt()`. It is possible to create data races & undefined behavior by concurrently invoking `SyncRef<T>::clone()` or `SyncRef<T>::fmt()` from multiple threads with `T: !Sync`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "v9",
        "purl": "pkg:cargo/v9"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/v9"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0127.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/purpleposeidon/v9/issues/1"
    }
  ]
},"35":{
  "id": "RUSTSEC-2021-0091",
  "modified": "2021-08-22T01:39:27Z",
  "published": "2021-01-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Reading on uninitialized buffer may cause UB ( `gfx_auxil::read_spirv()` )",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "gfx-auxil",
        "purl": "pkg:cargo/gfx-auxil"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/gfx-auxil"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0091.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gfx-rs/gfx/issues/3567"
    }
  ]
},"36":{
  "id": "RUSTSEC-2018-0003",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-07-19T12:00:00Z",
  "aliases": [
    "CVE-2018-20991"
  ],
  "related": [],
  "summary": "Possible double free during unwinding in SmallVec::insert_many",
  "details": "If an iterator passed to `SmallVec::insert_many` panicked in `Iterator::next`,\ndestructors were run during unwinding while the vector was in an inconsistent\nstate, possibly causing a double free (a destructor running on two copies of\nthe same value).\n\nThis is fixed in smallvec 0.6.3 by ensuring that the vector's length is not\nupdated to include moved items until they have been removed from their\noriginal positions.  Items may now be leaked if `Iterator::next` panics, but\nthey will not be dropped more than once.\n\nThank you to @Vurich for reporting this bug.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "smallvec",
        "purl": "pkg:cargo/smallvec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.2","<": "0.3.4"
            },
            {
              ">=": "0.4.0-0","<": "0.4.5"
            },
            {
              ">=": "0.5.0-0","<": "0.5.1"
            },
            {
              ">=": "0.6.0-0","<": "0.6.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/smallvec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0003.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/servo/rust-smallvec/issues/96"
    }
  ]
},"37":{
  "id": "RUSTSEC-2020-0035",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-08-25T12:00:00Z",
  "aliases": [
    "CVE-2020-36433"
  ],
  "related": [],
  "summary": "Chunk API does not respect align requirement",
  "details": "Chunk API does not respect the align requirement of types. Unaligned reference can be created with the API, which is an undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "chunky",
        "purl": "pkg:cargo/chunky"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/chunky"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0035.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/aeplay/chunky/issues/2"
    }
  ]
},"38":{
  "id": "RUSTSEC-2021-0005",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-10T12:00:00Z",
  "aliases": [
    "CVE-2021-25902"
  ],
  "related": [],
  "summary": "Double drop upon panic in 'fn map_array()'",
  "details": "Affected versions of this crate did not guard against panic within the user-provided function `f` (2nd parameter of `fn map_array`), and thus panic within `f` \ncauses double drop of a single object.\n\nThe flaw was corrected in the 0.4.0 release by wrapping the object vulnerable\nto a double drop within `ManuallyDrop<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "glsl-layout",
        "purl": "pkg:cargo/glsl-layout"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/glsl-layout"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0005.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rustgd/glsl-layout/pull/10"
    }
  ]
},"39":{
  "id": "RUSTSEC-2019-0033",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-11-16T12:00:00Z",
  "aliases": [
    "CVE-2020-25574",
    "CVE-2019-25008"
  ],
  "related": [],
  "summary": "Integer Overflow in HeaderMap::reserve() can cause Denial of Service",
  "details": "`HeaderMap::reserve()` used `usize::next_power_of_two()` to calculate the increased capacity.\nHowever, `next_power_of_two()` silently overflows to 0 if given a sufficiently large number\nin release mode.\n\nIf the map was not empty when the overflow happens,\nthe library will invoke `self.grow(0)` and start infinite probing.\nThis allows an attacker who controls the argument to `reserve()`\nto cause a potential denial of service (DoS).\n\nThe flaw was corrected in 0.1.20 release of `http` crate.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "http",
        "purl": "pkg:cargo/http"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "http::header::HeaderMap::reserve"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.20"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/http"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0033.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/hyperium/http/issues/352"
    }
  ]
},"40":{
  "id": "RUSTSEC-2021-0052",
  "modified": "2021-04-13T21:10:09Z",
  "published": "2021-02-26T12:00:00Z",
  "aliases": [
    "CVE-2021-30455",
    "CVE-2021-30456",
    "CVE-2021-30457"
  ],
  "related": [],
  "summary": "Multiple functions can cause double-frees",
  "details": "The following functions in the crate are affected:\n\n## `IdMap::clone_from`\n\nThe `clone_from` implementation for `IdMap` drops the values present in the\nmap and then begins cloning values from the other map. If a `.clone()` call\npancics, then the afformentioned dropped elements can be freed again.\n\n## `get_or_insert`\n\n`get_or_insert` reserves space for a value, before calling the user provided\ninsertion function `f`. If the function `f` panics then uninitialized or\npreviously freed memory can be dropped.\n\n## `remove_set`\n\nWhen removing a set of elements, `ptr::drop_in_place` is called on each of the\nelement to be removed. If the `Drop` impl of one of these elements panics then\nthe previously dropped elements can be dropped again.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "id-map",
        "purl": "pkg:cargo/id-map"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/id-map"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0052.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/andrewhickman/id-map/issues/3"
    }
  ]
},"41":{
  "id": "RUSTSEC-2022-0007",
  "modified": "2022-01-24T17:41:17Z",
  "published": "2022-01-24T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "A malicious coder can get unsound access to TCell or TLCell memory",
  "details": "This is impossible to do by accident, but by carefully constructing\nmarker types to be covariant, a malicious coder can cheat the\nsingleton check in `TCellOwner` and `TLCellOwner`, giving unsound\naccess to cell memory.  This could take the form of getting two\nmutable references to the same memory, or a mutable reference and an\nimmutable reference.\n\nThe fix is for the crate to internally force the marker type to be\ninvariant.  This blocks the conversion between covariant types which\nRust normally allows.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "qcell",
        "purl": "pkg:cargo/qcell"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/qcell"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0007.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/uazu/qcell/issues/20"
    }
  ]
},"42":{
  "id": "RUSTSEC-2021-0117",
  "modified": "2021-12-22T21:15:54Z",
  "published": "2021-09-14T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`DecimalArray` does not perform bound checks on accessing values and offsets",
  "details": "`DecimalArray` performs insufficient bounds checks,\nwhich allows out-of-bounds reads in safe code\nif the lenght of the backing buffer is not a multiple of 16.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arrow",
        "purl": "pkg:cargo/arrow"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "6.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arrow"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0117.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/apache/arrow-rs/issues/775"
    }
  ]
},"43":{
  "id": "RUSTSEC-2020-0019",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-19T12:00:00Z",
  "aliases": [
    "CVE-2020-35875"
  ],
  "related": [],
  "summary": "tokio-rustls reads may cause excessive memory usage",
  "details": "`tokio-rustls` does not call `process_new_packets` immediately after `read`,\nso the expected termination condition `wants_read` always returns true.\nAs long as new incoming data arrives faster than it is processed\nand the reader does not return pending, data will be buffered.\n\nThis may cause DoS.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tokio-rustls",
        "purl": "pkg:cargo/tokio-rustls"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.12.0","<": "0.12.3"
            },
            {
              ">=": "0.13.0","<": "0.13.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tokio-rustls"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0019.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/tokio-rs/tls/pull/14"
    }
  ]
},"44":{
  "id": "RUSTSEC-2022-0011",
  "modified": "2022-03-01T16:17:42Z",
  "published": "2022-02-28T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Miscomputation when performing AES encryption in rust-crypto",
  "details": "The following Rust program demonstrates some strangeness in AES encryption - if you have an immutable key slice and then operate on that slice, you get different encryption output than if you operate on a copy of that key.\n\nFor these functions, we expect that extending a 16 byte key to a 32 byte key by repeating it gives the same encrypted data, because the underlying rust-crypto functions repeat key data up to the necessary key size for the cipher.\n\n```rust\nuse crypto::{\n    aes, blockmodes, buffer,\n    buffer::{BufferResult, ReadBuffer, WriteBuffer},\n    symmetriccipher,\n};\n\nfn encrypt(\n    key: &[u8],\n    iv: &[u8],\n    data: &str,\n) -> Result<String, symmetriccipher::SymmetricCipherError> {\n    let mut encryptor =\n        aes::cbc_encryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);\n\n    let mut encrypted_data = Vec::<u8>::new();\n    let mut read_buffer = buffer::RefReadBuffer::new(data.as_bytes());\n    let mut buffer = [0; 4096];\n    let mut write_buffer = buffer::RefWriteBuffer::new(&mut buffer);\n\n    loop {\n        let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true)?;\n\n        encrypted_data.extend(\n            write_buffer\n                .take_read_buffer()\n                .take_remaining()\n                .iter()\n                .copied(),\n        );\n\n        match result {\n            BufferResult::BufferUnderflow => break,\n            BufferResult::BufferOverflow => {}\n        }\n    }\n\n    Ok(hex::encode(encrypted_data))\n}\n\nfn working() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // The copy here makes the code work.\n    let key_copy = key;\n    let key2: Vec<u8> = key_copy.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&key), hex::encode(&key2));\n\n    let x1 = encrypt(&key, &iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&key2, &iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn broken() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // This operation shouldn't affect the contents of key at all.\n    let key2: Vec<u8> = key.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&key), hex::encode(&key2));\n\n    let x1 = encrypt(&key, &iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&key2, &iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn main() {\n    working();\n    broken();\n}\n```\n\nThe output from this program:\n\n```shell\n     Running `target/host/debug/rust-crypto-test`\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 90462bbe32965c8e7ea0addbbed4cddb\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 26e847e5e7df1947bf82a650548a7d5b\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `\"26e847e5e7df1947bf82a650548a7d5b\"`,\n right: `\"90462bbe32965c8e7ea0addbbed4cddb\"`', src/main.rs:83:5\n```\n\nNotably, the X1 key in the `broken()` test changes every time after rerunning the program.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rust-crypto",
        "purl": "pkg:cargo/rust-crypto"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rust-crypto"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0011.html"
    }
  ]
},"45":{
  "id": "RUSTSEC-2021-0044",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-09T12:00:00Z",
  "aliases": [
    "CVE-2021-29935"
  ],
  "related": [],
  "summary": "Use after free possible in `uri::Formatter` on panic",
  "details": "Affected versions of this crate transmuted a `&str` to a `&'static str` before\npushing it into a `StackVec`, this value was then popped later in the same\nfunction.\n\nThis was assumed to be safe because the reference would be valid while the\nmethod's stack was active. In between the push and the pop, however, a function\n`f` was called that could invoke a user provided function.\n\nIf the user provided panicked, then the assumption used by the function was no\nlonger true and the transmute to `&'static` would create an illegal static\nreference to the string. This could result in a freed string being used during\n(such as in a `Drop` implementation) or after (e.g through `catch_unwind`) the\npanic unwinding.\n\nThis flaw was corrected in commit [e325e2f](https://github.com/SergioBenitez/Rocket/commit/e325e2fce4d9f9f392761e9fb58b418a48cef8bb)\nby using a guard object to ensure that the `&'static str` was dropped inside\nthe function.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rocket",
        "purl": "pkg:cargo/rocket"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.7"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rocket"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0044.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/SergioBenitez/Rocket/issues/1534"
    }
  ]
},"46":{
  "id": "RUSTSEC-2021-0101",
  "modified": "2021-09-10T15:58:27Z",
  "published": "2021-05-27T12:00:00Z",
  "aliases": [
    "CVE-2021-31155",
    "GHSA-vc5p-j8vw-mc6x"
  ],
  "related": [],
  "summary": "Permissions bypass in pleaser",
  "details": "Failure to normalize the umask in pleaser before 0.4 allows a local attacker to gain full root privileges if they are allowed to execute at least one command.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "pleaser",
        "purl": "pkg:cargo/pleaser"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "privilege-escalation"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/pleaser"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0101.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31155"
    }
  ]
},"47":{
  "id": "RUSTSEC-2021-0013",
  "modified": "2021-08-22T01:18:11Z",
  "published": "2021-01-20T12:00:00Z",
  "aliases": [
    "CVE-2021-26306",
    "CVE-2021-26307"
  ],
  "related": [],
  "summary": "Soundness issues in `raw-cpuid`",
  "details": "## Undefined behavior in `as_string()` methods\n\n`VendorInfo::as_string()`, `SoCVendorBrand::as_string()`,\nand `ExtendedFunctionInfo::processor_brand_string()` construct byte slices\nusing `std::slice::from_raw_parts()`, with data coming from\n`#[repr(Rust)]` structs. This is always undefined behavior.\n\nSee https://github.com/gz/rust-cpuid/issues/40.\n\nThis flaw has been fixed in v9.0.0, by making the relevant structs\n`#[repr(C)]`.\n\n## `native_cpuid::cpuid_count()` is unsound\n\n`native_cpuid::cpuid_count()` exposes the unsafe `__cpuid_count()` intrinsic\nfrom `core::arch::x86` or `core::arch::x86_64` as a safe function, and uses\nit internally, without checking the\n[safety requirement](https://doc.rust-lang.org/core/arch/index.html#overview):\n\n> The CPU the program is currently running on supports the function being\n> called.\n\nCPUID is available in most, but not all, x86/x86_64 environments. The crate\ncompiles only on these architectures, so others are unaffected.\n\nThis issue is mitigated by the fact that affected programs are expected\nto crash deterministically every time.\n\nSee https://github.com/gz/rust-cpuid/issues/41.\n\nThe flaw has been fixed in v9.0.0, by intentionally breaking compilation\nwhen targeting SGX or 32-bit x86 without SSE. This covers all affected CPUs.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "raw-cpuid",
        "purl": "pkg:cargo/raw-cpuid"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [
            "x86",
            "x86_64"
          ],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "9.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/raw-cpuid"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0013.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustSec/advisory-db/pull/614"
    }
  ]
},"48":{
  "id": "RUSTSEC-2020-0058",
  "modified": "2020-10-25T19:14:03Z",
  "published": "2020-10-15T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `cipher`",
  "details": "This crate has been renamed from `stream-cipher` to `cipher`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/traits/tree/master/cipher>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stream-cipher",
        "purl": "pkg:cargo/stream-cipher"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stream-cipher"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0058.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/traits/pull/337"
    }
  ]
},"49":{
  "id": "RUSTSEC-2019-0025",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-10-03T12:00:00Z",
  "aliases": [
    "CVE-2019-25001"
  ],
  "related": [],
  "summary": "Flaw in CBOR deserializer allows stack overflow",
  "details": "Affected versions of this crate did not properly check if semantic tags were nested excessively during deserialization.\n\nThis allows an attacker to craft small (< 1 kB) CBOR documents that cause a stack overflow.\n \nThe flaw was corrected by limiting the allowed number of nested tags.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "serde_cbor",
        "purl": "pkg:cargo/serde_cbor"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.10.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/serde_cbor"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0025.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/pyfisch/cbor/releases/tag/v0.10.2"
    }
  ]
},"50":{
  "id": "RUSTSEC-2020-0059",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-10-22T12:00:00Z",
  "aliases": [
    "CVE-2020-35905"
  ],
  "related": [],
  "summary": "MutexGuard::map can cause a data race in safe code",
  "details": "Affected versions of the crate had a Send/Sync implementation for MappedMutexGuard that only considered variance on T, while MappedMutexGuard dereferenced to U.\n\nThis could of led to data races in safe Rust code when a closure used in MutexGuard::map() returns U that is unrelated to T.\n\nThe issue was fixed by fixing `Send` and `Sync` implementations, and by adding a `PhantomData<&'a mut U>` marker to the `MappedMutexGuard` type to tell the compiler that the guard is over\nU too.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "futures-util",
        "purl": "pkg:cargo/futures-util"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "futures_util::lock::MutexGuard::map"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.2","<": "0.3.7"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/futures-util"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0059.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-lang/futures-rs/issues/2239"
    }
  ]
},"51":{
  "id": "RUSTSEC-2019-0024",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2019-10-08T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Test advisory with associated example crate",
  "details": "This is a test advisory useful for verifying RustSec tooling and vulnerability\ndetection pipelines are working correctly. Aside from the fact that it is filed\nagainst an example crate, it is otherwise considered by the Advisory Database\nitself to be a normal security advisory.\n\nIt's filed against `rustsec-example-crate`, an otherwise completely empty crate\nwith no functionality or code, which has two releases:\n\n- [v0.0.1] - *vulnerable* according to this advisory\n- [v1.0.0] - *patched* by this advisory\n\n(Technically there is a third release, v0.0.0, which is yanked, but otherwise\nidentical to the v0.0.1 release)\n\n[v0.0.1]: https://crates.io/crates/rustsec-example-crate/0.0.1\n[v1.0.0]: https://crates.io/crates/rustsec-example-crate/1.0.0",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rustsec-example-crate",
        "purl": "pkg:cargo/rustsec-example-crate"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rustsec-example-crate"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0024.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/158"
    }
  ]
},"52":{
  "id": "RUSTSEC-2021-0012",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-02T12:00:00Z",
  "aliases": [
    "CVE-2021-26305"
  ],
  "related": [],
  "summary": "Reading uninitialized memory can cause UB (`Deserializer::read_vec`)",
  "details": "`Deserializer::read_vec()` created an uninitialized buffer and passes it to a user-provided `Read` implementation (`Deserializer.reader.read_exact()`).\n\nPassing an uninitialized buffer to an arbitrary `Read` implementation is currently defined as undefined behavior in Rust. Official documentation for the `Read` trait explains the following: \"It is your responsibility to make sure that buf is initialized before calling read. Calling read with an uninitialized buf (of the kind one obtains via MaybeUninit<T>) is not safe, and can lead to undefined behavior.\"\n\nThe flaw was corrected in commit ce310f7 by zero-initializing the newly allocated buffer before handing it to `Deserializer.reader.read_exact()`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cdr",
        "purl": "pkg:cargo/cdr"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cdr"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0012.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/hrektts/cdr-rs/issues/10"
    }
  ]
},"53":{
  "id": "RUSTSEC-2021-0045",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-11T12:00:00Z",
  "aliases": [
    "CVE-2021-29936"
  ],
  "related": [],
  "summary": "FromIterator implementation for Vector/Matrix can drop uninitialized memory",
  "details": "The `FromIterator<T>` methods for `Vector` and `Matrix` rely on the type\nparameter `N` to allocate space in the iterable.\n\nIf the passed in `N` type parameter is larger than the number of items returned\nby the iterator, it can lead to uninitialized memory being left in the\n`Vector` or `Matrix` type which gets dropped.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "adtensor",
        "purl": "pkg:cargo/adtensor"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/adtensor"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0045.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/charles-r-earp/adtensor/issues/4"
    }
  ]
},"54":{
  "id": "RUSTSEC-2022-0010",
  "modified": "2022-02-18T22:15:59Z",
  "published": "2022-02-17T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "enum_map macro can cause UB when `Enum` trait is incorrectly implemented",
  "details": "Affected versions of this crate did not properly check the length of an enum when using `enum_map!` macro, trusting user-provided length.\n\nWhen the `LENGTH` in the `Enum` trait does not match the array length in the `EnumArray` trait, this can result in the initialization of the enum map with uninitialized types, which in turn can allow an attacker to execute arbitrary code.\n\nThis problem can only occur with a manual implementation of the Enum trait, it will never occur for enums that use `#[derive(Enum)]`.\n\nExample code that triggers this vulnerability looks like this:\n\n```rust\nenum E {\n    A,\n    B,\n    C,\n}\n\nimpl Enum for E {\n    const LENGTH: usize = 2;\n\n    fn from_usize(value: usize) -> E {\n        match value {\n            0 => E::A,\n            1 => E::B,\n            2 => E::C,\n            _ => unimplemented!(),\n        }\n    }\n\n    fn into_usize(self) -> usize {\n        self as usize\n    }\n}\n\nimpl<V> EnumArray<V> for E {\n    type Array = [V; 3];\n}\n\nlet _map: EnumMap<E, String> = enum_map! { _ => \"Hello, world!\".into() };\n```\n\nThe flaw was corrected in commit [b824e23](https://gitlab.com/KonradBorowski/enum-map/-/commit/b824e232f2fb47837740070096ac253df8e80dfc) by putting `LENGTH` property on sealed trait for macro to read.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "enum-map",
        "purl": "pkg:cargo/enum-map"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "2.0.0-2","<": "2.0.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/enum-map"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0010.html"
    },
    {
      "type": "WEB",
      "url": "https://gitlab.com/KonradBorowski/enum-map/-/blob/master/CHANGELOG.md#version-202"
    }
  ]
},"55":{
  "id": "RUSTSEC-2021-0100",
  "modified": "2021-09-09T16:22:48Z",
  "published": "2021-09-08T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Miscomputed results when using AVX2 backend",
  "details": "The v0.9.7 release of the `sha2` crate introduced a new AVX2-accelerated\nbackend which was automatically enabled for all x86/x86_64 CPUs where AVX2\nsupport was autodetected at runtime.\n\nThis backend was buggy and would miscompute results for long messages\n(i.e. messages spanning multiple SHA blocks).\n\nThe crate has since been yanked, but any users who upgraded to v0.9.7 should\nimmediately upgrade to v0.9.8 and recompute any hashes which were previously\ncomputed by v0.9.7.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "sha2",
        "purl": "pkg:cargo/sha2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.9.7","<": "0.9.8"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/sha2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0100.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/hashes/pull/314"
    }
  ]
},"56":{
  "id": "RUSTSEC-2020-0018",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2020-05-26T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `block-cipher`",
  "details": "This crate has been renamed from `block-cipher-trait` to `block-cipher`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/traits/tree/master/block-cipher>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "block-cipher-trait",
        "purl": "pkg:cargo/block-cipher-trait"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/block-cipher-trait"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0018.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/traits/pull/139"
    }
  ]
},"57":{
  "id": "RUSTSEC-2022-0006",
  "modified": "2022-01-24T14:39:43Z",
  "published": "2022-01-23T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Data race in `Iter` and `IterMut`",
  "details": "In the affected version of this crate, `{Iter, IterMut}::next` used a weaker memory ordering when loading values than what was required, exposing a potential data race\nwhen iterating over a `ThreadLocal`'s values.\n\nCrates using `Iter::next`, or `IterMut::next` are affected by this issue.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "thread_local",
        "purl": "pkg:cargo/thread_local"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.1.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/thread_local"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0006.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Amanieu/thread_local-rs/issues/33"
    }
  ]
},"58":{
  "id": "RUSTSEC-2021-0053",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-03-07T12:00:00Z",
  "aliases": [
    "CVE-2021-31996"
  ],
  "related": [],
  "summary": "'merge_sort::merge()' crashes with double-free for `T: Drop`",
  "details": "In the affected versions of this crate, `merge_sort::merge()` wildly duplicates and drops ownership of `T` without guarding against double-free. Due to such implementation,\nsimply invoking `merge_sort::merge()` on `Vec<T: Drop>` can cause **double free** bugs.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "algorithmica",
        "purl": "pkg:cargo/algorithmica"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/algorithmica"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0053.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/AbrarNitk/algorithmica/issues/1"
    }
  ]
},"59":{
  "id": "RUSTSEC-2021-0116",
  "modified": "2021-12-22T21:15:54Z",
  "published": "2021-09-14T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`BinaryArray` does not perform bound checks on reading values and offsets",
  "details": "`BinaryArray` performs insufficient validation on creation, which allows out-of-bounds reads in safe code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arrow",
        "purl": "pkg:cargo/arrow"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "6.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arrow"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0116.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/apache/arrow-rs/issues/772"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/apache/arrow-rs/issues/773"
    }
  ]
},"60":{
  "id": "RUSTSEC-2019-0032",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2019-11-21T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crust repo has been archived; use libp2p instead",
  "details": "** The `crust` crate repo was archived with no warning or explanation.**\n\nGiven that it was archived with no warning or successor, there's not an\nofficial replacement but [`rust-libp2p`](https://github.com/libp2p/rust-libp2p)\nlooks like it's got a similar feature set and is actively maintained.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "crust",
        "purl": "pkg:cargo/crust"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.32.2-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/crust"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0032.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/crust"
    }
  ]
},"61":{
  "id": "RUSTSEC-2021-0004",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-17T12:00:00Z",
  "aliases": [
    "CVE-2021-25901"
  ],
  "related": [],
  "summary": "Missing Send bound for Lazy",
  "details": "All current versions of this crate allow causing data races in safe code.\n\nThe flaw will be fixed in the next release.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lazy-init",
        "purl": "pkg:cargo/lazy-init"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.1-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lazy-init"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0004.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/khuey/lazy-init/issues/9"
    }
  ]
},"62":{
  "id": "RUSTSEC-2020-0034",
  "modified": "2021-01-31T04:02:50Z",
  "published": "2020-08-25T12:00:00Z",
  "aliases": [
    "CVE-2020-35886",
    "CVE-2020-35887",
    "CVE-2020-35888"
  ],
  "related": [],
  "summary": "Multiple security issues including data race, buffer overflow, and uninitialized memory drop",
  "details": "`arr` crate contains multiple security issues. Specifically,\n\n1. It incorrectly implements Sync/Send bounds, which allows to smuggle non-Sync/Send types across the thread boundary.\n2. `Index` and `IndexMut` implementation does not check the array bound.\n3. `Array::new_from_template()` drops uninitialized memory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arr",
        "purl": "pkg:cargo/arr"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arr"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0034.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/sjep/array/issues/1"
    }
  ]
},"63":{
  "id": "RUSTSEC-2021-0090",
  "modified": "2021-08-23T12:04:28Z",
  "published": "2021-01-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Reading on uninitialized memory may cause UB ( `util::read_spv()` )",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ash",
        "purl": "pkg:cargo/ash"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.33.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ash"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0090.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/MaikKlein/ash/issues/354"
    }
  ]
},"64":{
  "id": "RUSTSEC-2018-0002",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-06-29T12:00:00Z",
  "aliases": [
    "CVE-2018-20990"
  ],
  "related": [],
  "summary": "Links in archives can overwrite any existing file",
  "details": "When unpacking a tarball with the `unpack_in`-family of functions it's intended\nthat only files within the specified directory are able to be written. Tarballs\nwith hard links or symlinks, however, can be used to overwrite any file on the\nfilesystem.\n\nTarballs can contain multiple entries for the same file. A tarball which first\ncontains an entry for a hard link or symlink pointing to any file on the\nfilesystem will have the link created, and then afterwards if the same file is\nlisted in the tarball the hard link will be rewritten and any file can be\nrewritten on the filesystem.\n\nThis has been fixed in https://github.com/alexcrichton/tar-rs/pull/156 and is\npublished as `tar` 0.4.16. Thanks to Max Justicz for discovering this and\nemailing about the issue!",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tar",
        "purl": "pkg:cargo/tar"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.16"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tar"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0002.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/alexcrichton/tar-rs/pull/156"
    }
  ]
},"65":{
  "id": "RUSTSEC-2020-0063",
  "modified": "2020-11-02T14:43:36Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `safe-nd`",
  "details": "This crate has been renamed from `safe-nd` to `sn_data_types`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_data_types>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe-nd",
        "purl": "pkg:cargo/safe-nd"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe-nd"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0063.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_data_types/pull/218"
    }
  ]
},"66":{
  "id": "RUSTSEC-2020-0126",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-15T12:00:00Z",
  "aliases": [
    "CVE-2020-36446"
  ],
  "related": [],
  "summary": "SyncChannel<T> can move 'T: !Send' to other threads",
  "details": "Affected versions of this crate unconditionally implement Send/Sync for `SyncChannel<T>`.\n`SyncChannel<T>` doesn't provide access to `&T` but merely serves as a channel that consumes and returns owned `T`.\n\nUsers can create UB in safe Rust by sending `T: !Send` to other threads with `SyncChannel::send/recv` APIs. Using `T = Arc<Cell<_>` allows to create data races (which can lead to memory corruption), and using `T = MutexGuard<T>` allows to unlock a mutex from a thread that didn't lock the mutex.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "signal-simple",
        "purl": "pkg:cargo/signal-simple"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/signal-simple"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0126.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/kitsuneninetails/signal-rust/issues/2"
    }
  ]
},"67":{
  "id": "RUSTSEC-2021-0028",
  "modified": "2021-03-19T21:21:58Z",
  "published": "2021-02-19T12:00:00Z",
  "aliases": [
    "CVE-2021-28028",
    "CVE-2021-28029"
  ],
  "related": [],
  "summary": "Multiple memory safety issues in insert_row",
  "details": "When inserting rows from an iterator at a particular index, `toodee` would shift\nitems over, duplicating their ownership. The space reserved for the new elements\nwas based on the `len()` returned by the `ExactSizeIterator`.\n\nThis could result in elements in the array being freed twice if the iterator\npanics. Uninitialized or previously freed elements could also be exposed if the\n`len()` didn't match the number of elements.\n\nThese issues were fixed in commit `ced70c17` by temporarily setting the length\nof the array smaller while processing it and adding assertions on the number\nof elements returned by the iterator.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "toodee",
        "purl": "pkg:cargo/toodee"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "toodee::TooDee::insert_row"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/toodee"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0028.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/antonmarsden/toodee/issues/13"
    }
  ]
},"68":{
  "id": "RUSTSEC-2019-0008",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-06-24T12:00:00Z",
  "aliases": [
    "CVE-2019-15550"
  ],
  "related": [],
  "summary": "Flaw in string parsing can lead to crashes due to invalid memory access.",
  "details": "The affected version of this crate did not guard against accessing memory\nbeyond the range of its input data. A pointer cast to read the data into\na 256-bit register could lead to a segmentation fault when the end plus\nthe 32 bytes (256 bit) read would overlap into the next page during string\nparsing.\n\n```\npage   |  ...  page 1  ...  | ... page 2  ... |\ndata   | x[n * 32 byte]xx__ |                 |\naccess | ..][ 32 byte ]     |                 |\nsegflt |               [ 32 | byte ]          |\n```\n\nThis allows an attacker to eventually crash a service.\n\nThe flaw was corrected by using a padding buffer for the last read from the\ninput. So that we are we never read over the boundary of the input data.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "simd-json",
        "purl": "pkg:cargo/simd-json"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [
            "x86",
            "x86_64"
          ],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.14-0","<": "0.1.15"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/simd-json"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0008.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/Licenser/simdjson-rs/pull/27"
    }
  ]
},"69":{
  "id": "RUSTSEC-2020-0075",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-29T12:00:00Z",
  "aliases": [
    "CVE-2020-35918"
  ],
  "related": [],
  "summary": "Unexpected panic when decoding tokens",
  "details": "Prior to `0.10.0` it was possible to have both decoding functions panic unexpectedly,\nby supplying tokens with an incorrect base62 encoding.\n\nThe documentation stated that an error should have been reported instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "branca",
        "purl": "pkg:cargo/branca"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "branca::Branca::decode",
            "branca::decode"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.10.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/branca"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0075.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/return/branca/issues/24"
    }
  ]
},"70":{
  "id": "RUSTSEC-2020-0130",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-12T12:00:00Z",
  "aliases": [
    "CVE-2020-36450"
  ],
  "related": [],
  "summary": "Bunch<T> unconditionally implements Send/Sync",
  "details": "Affected versions of this crate unconditionally implements `Send`/`Sync` for `Bunch<T>`.\nThis allows users to insert `T: !Sync` to `Bunch<T>`. It is possible to create a data race to a `T: !Sync` by invoking the `Bunch::get()` API (which returns `&T`) from multiple threads. It is also possible to send `T: !Send` to other threads by inserting `T` inside `Bunch<T>` and sending `Bunch<T>` to another thread, allowing to create a data race by inserting types like `T = Rc<_>`.\n\nSuch data races can lead to memory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bunch",
        "purl": "pkg:cargo/bunch"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bunch"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0130.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/krl/bunch/issues/1"
    }
  ]
},"71":{
  "id": "RUSTSEC-2020-0022",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-07-04T12:00:00Z",
  "aliases": [
    "CVE-2020-35877",
    "CVE-2020-35878"
  ],
  "related": [],
  "summary": "Ozone contains several memory safety issues",
  "details": "Ozone contains several memory safety issues including [out-of-bound access](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/buffer.rs#L38-L48)\nand dropping of [uninitialized memory](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/map.rs#L94-L101).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ozone",
        "purl": "pkg:cargo/ozone"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ozone"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0022.html"
    }
  ]
},"72":{
  "id": "RUSTSEC-2017-0006",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2017-11-21T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Unchecked vector pre-allocation",
  "details": "Affected versions of this crate pre-allocate memory on deserializing raw\nbuffers without checking whether there is sufficient data available.\n\nThis allows an attacker to do denial-of-service attacks by sending small\nmsgpack messages that allocate gigabytes of memory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rmpv",
        "purl": "pkg:cargo/rmpv"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rmpv"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0006.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/3Hren/msgpack-rust/issues/151"
    }
  ]
},"73":{
  "id": "RUSTSEC-2021-0086",
  "modified": "2021-08-22T01:25:44Z",
  "published": "2021-01-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`Read` on uninitialized buffer may cause UB ( `read_entry()` )",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\nThere are two of such cases (`go_offset_log::read_entry()` & `offset_log::read_entry()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "flumedb",
        "purl": "pkg:cargo/flumedb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/flumedb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0086.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/sunrise-choir/flumedb-rs/issues/10"
    }
  ]
},"74":{
  "id": "RUSTSEC-2018-0014",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2018-07-31T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "chan is end-of-life; use crossbeam-channel instead",
  "details": "**`chan` has reached its end-of-life and is now deprecated.**\n\nThe intended successor of this crate is\n[`crossbeam-channel`](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel).\nIts API is strikingly similar, but comes with a much better `select!` macro,\nbetter performance, a better test suite and an all-around better\nimplementation.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "chan",
        "purl": "pkg:cargo/chan"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.24-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/chan"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0014.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/BurntSushi/chan/commit/0a5c0d4ad4adc90a54ee04a427389acf2e157275"
    }
  ]
},"75":{
  "id": "RUSTSEC-2021-0069",
  "modified": "2021-10-19T19:56:47Z",
  "published": "2021-05-22T12:00:00Z",
  "aliases": [
    "GHSA-qc36-q22q-cjw3",
    "CVE-2021-38189"
  ],
  "related": [],
  "summary": "SMTP command injection in body",
  "details": "Affected versions of lettre allowed SMTP command injection through an attacker's controlled message body. The module for escaping lines starting with a period wouldn't catch a period that was placed after a double CRLF sequence, allowing the attacker to end the current message and write arbitrary SMTP commands after it.\n\nThe flaw is fixed by correctly handling consecutive CRLF sequences.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lettre",
        "purl": "pkg:cargo/lettre"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "lettre::smtp::SmtpTransport::send",
            "lettre::transport::smtp::SmtpTransport::send",
            "lettre::transport::smtp::SmtpTransport::send_raw"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.7.0","<": "0.9.6"
            },
            {
              ">=": "0.10.0-alpha.1","<": "0.10.0-rc.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lettre"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0069.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/lettre/lettre/pull/627/commits/93458d01fed0ec81c0e7b4e98e6f35961356fae2"
    }
  ]
},"76":{
  "id": "RUSTSEC-2019-0028",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-10-20T12:00:00Z",
  "aliases": [
    "CVE-2019-25004"
  ],
  "related": [],
  "summary": "Unsound `impl Follow for bool`",
  "details": "The implementation of `impl Follow for bool` allows to reinterpret arbitrary bytes as a `bool`.\n\nIn Rust `bool` has stringent requirements for its in-memory representation. Use of this function\nallows to violate these requirements and invoke undefined behaviour in safe code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "flatbuffers",
        "purl": "pkg:cargo/flatbuffers"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "flatbuffers::Follow::follow"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/flatbuffers"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0028.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/google/flatbuffers/issues/5530"
    }
  ]
},"77":{
  "id": "RUSTSEC-2020-0055",
  "modified": "2021-06-29T22:08:30Z",
  "published": "2020-10-21T12:00:00Z",
  "withdrawn": "2020-10-22T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Please see RUSTSEC-2018-0020",
  "details": "This vulnerability was misfiled under the wrong year and has been withdrawn.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libpulse-binding",
        "purl": "pkg:cargo/libpulse-binding"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.0.1-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libpulse-binding"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0055.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0020.html"
    }
  ]
},"78":{
  "id": "RUSTSEC-2021-0049",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-18T12:00:00Z",
  "aliases": [
    "CVE-2021-29940"
  ],
  "related": [],
  "summary": "`through` and `through_and` causes a double free if the map function panics",
  "details": "`through` and `through_and` take a mutable reference as well as a mapping\nfunction to change the provided reference. They do this by calling `ptr::read`\non the reference which duplicates ownership and then calling the mapping\nfunction.\n\nIf the mapping function panics, both the original object and the one\nduplicated by `ptr::read` get dropped, causing a double free.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "through",
        "purl": "pkg:cargo/through"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/through"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0049.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gretchenfrage/through/issues/1"
    }
  ]
},"79":{
  "id": "RUSTSEC-2020-0147",
  "modified": "2021-03-04T13:58:02Z",
  "published": "2020-02-11T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "rulinalg is unmaintained, use nalgebra instead",
  "details": "The `rulinalg` crate is no longer maintained, use [nalgebra](https://crates.io/crates/nalgebra)\ninstead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rulinalg",
        "purl": "pkg:cargo/rulinalg"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rulinalg"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0147.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/AtheMathmo/rulinalg/issues/201#issuecomment-584749313"
    }
  ]
},"80":{
  "id": "RUSTSEC-2020-0002",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-16T12:00:00Z",
  "aliases": [
    "CVE-2020-35858"
  ],
  "related": [],
  "summary": "Parsing a specially crafted message can result in a stack overflow",
  "details": "Affected versions of this crate contained a bug in which decoding untrusted\ninput could overflow the stack.\n\nOn architectures with stack probes (like x86), this can be used for denial of\nservice attacks, while on architectures without stack probes (like ARM)\noverflowing the stack is unsound and can result in potential memory corruption\n(or even RCE).\n \nThe flaw was quickly corrected by @danburkert and released in version 0.6.1.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "prost",
        "purl": "pkg:cargo/prost"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service",
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/prost"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0002.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/danburkert/prost/issues/267"
    }
  ]
},"81":{
  "id": "RUSTSEC-2020-0151",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-16T12:00:00Z",
  "aliases": [
    "CVE-2020-36471"
  ],
  "related": [],
  "summary": "Generators can cause data races if non-Send types are used in their generator functions",
  "details": "The `Generator` type is an iterable which uses a generator function that yields\nvalues. In affected versions of the crate, the provided function yielding values\nhad no `Send` bounds despite the `Generator` itself implementing `Send`.\n\nThe generator function lacking a `Send` bound means that types that are\ndangerous to send across threads such as `Rc` could be sent as part of a\ngenerator, potentially leading to data races.\n\nThis flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)\nby enforcing that the generator function be bound by `Send`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "generator",
        "purl": "pkg:cargo/generator"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/generator"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0151.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Xudong-Huang/generator-rs/issues/27"
    }
  ]
},"82":{
  "id": "RUSTSEC-2020-0014",
  "modified": "2021-01-04T17:02:59Z",
  "published": "2020-04-23T12:00:00Z",
  "aliases": [
    "CVE-2020-35866",
    "CVE-2020-35867",
    "CVE-2020-35868",
    "CVE-2020-35869",
    "CVE-2020-35870",
    "CVE-2020-35871",
    "CVE-2020-35872",
    "CVE-2020-35873"
  ],
  "related": [],
  "summary": "Various memory safety issues",
  "details": "Several memory safety issues have been uncovered in an audit of\nrusqlite.\n\nSee https://github.com/rusqlite/rusqlite/releases/tag/0.23.0 for a complete list.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rusqlite",
        "purl": "pkg:cargo/rusqlite"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rusqlite::Connection::get_aux",
            "rusqlite::Connection::set_aux",
            "rusqlite::session::Session::attach",
            "rusqlite::session::Session::diff",
            "rusqlite::trace::log",
            "rusqlite::vtab::create_module"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.23.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rusqlite"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0014.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rusqlite/rusqlite/releases/tag/0.23.0"
    }
  ]
},"83":{
  "id": "RUSTSEC-2021-0008",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-02T12:00:00Z",
  "aliases": [
    "CVE-2021-25905"
  ],
  "related": [],
  "summary": "reading on uninitialized buffer can cause UB (`impl<R> BufRead for GreedyAccessReader<R>`)",
  "details": "Affected versions of this crate creates an uninitialized buffer and passes it to user-provided `Read` implementation.\n\nThis is unsound, because it allows safe Rust code to exhibit an undefined behavior (read from uninitialized memory).\n\nThe flaw was corrected in version 0.1.1 by zero-initializing a newly allocated buffer\nbefore handing it to a user-provided `Read` implementation.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bra",
        "purl": "pkg:cargo/bra"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bra"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0008.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Enet4/bra-rs/issues/1"
    }
  ]
},"84":{
  "id": "RUSTSEC-2020-0106",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-19T12:00:00Z",
  "aliases": [
    "CVE-2020-36214"
  ],
  "related": [],
  "summary": "Queues allow non-Send types to be sent to other threads, allowing data races",
  "details": "Affected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).\n\nThis allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.\n\nThe flaw was corrected in v0.1.7 by adding `T: Send` bound to to the `Send` impl of four data types explained above.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "multiqueue2",
        "purl": "pkg:cargo/multiqueue2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.7"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/multiqueue2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0106.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/abbychau/multiqueue2/issues/10"
    }
  ]
},"85":{
  "id": "RUSTSEC-2020-0043",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-25T12:00:00Z",
  "aliases": [
    "CVE-2020-35896"
  ],
  "related": [],
  "summary": "Insufficient size checks in outgoing buffer in ws allows remote attacker to run the process out of memory",
  "details": "Affected versions of this crate did not properly check and cap the growth of the outgoing buffer.\n\nThis allows a remote attacker to take down the process by growing the buffer of their (single) connection until the process runs out of memory it can allocate and is killed.\n\nThe flaw was corrected in the [`parity-ws` fork](https://crates.io/crates/parity-ws) (>=0.10.0) by [disconnecting a client when the buffer runs full](https://github.com/housleyjk/ws-rs/pull/328).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ws",
        "purl": "pkg:cargo/ws"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ws"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0043.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/housleyjk/ws-rs/issues/291"
    }
  ]
},"86":{
  "id": "RUSTSEC-2021-0073",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-07-08T12:00:00Z",
  "aliases": [
    "CVE-2021-38192"
  ],
  "related": [],
  "summary": "Conversion from `prost_types::Timestamp` to `SystemTime` can cause an overflow and panic",
  "details": "Affected versions of this crate contained a bug in which untrusted input could cause an overflow and panic when converting a `Timestamp` to `SystemTime`.\n\nIt is recommended to upgrade to `prost-types` v0.8 and switch the usage of `From<Timestamp> for SystemTime` to `TryFrom<Timestamp> for SystemTime`.\n\nSee [#438] for more information.\n\n[#438]: https://github.com/tokio-rs/prost/issues/438",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "prost-types",
        "purl": "pkg:cargo/prost-types"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "prost_types::Timestamp::Into<SystemTime>"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.8.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/prost-types"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0073.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tokio-rs/prost/issues/438"
    }
  ]
},"87":{
  "id": "RUSTSEC-2020-0038",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-03T12:00:00Z",
  "aliases": [
    "CVE-2020-35890",
    "CVE-2020-35891"
  ],
  "related": [],
  "summary": "Memory safety issues in `compact::Vec`",
  "details": "`compact::Vec` contains multiple memory safety issues.\n\n1. It mishandles large capacity and causes out-of-bound access in 32-bit / allocator layout mismatch in 64-bit.\n2. `remove()` is not panic-safe and causes double-free when an index larger than the length is provided.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ordnung",
        "purl": "pkg:cargo/ordnung"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ordnung"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0038.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/maciejhirsz/ordnung/issues/8"
    }
  ]
},"88":{
  "id": "RUSTSEC-2021-0024",
  "modified": "2021-02-15T16:43:30Z",
  "published": "2021-02-15T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_api`",
  "details": "This crate has been renamed from `safe-api` to `sn_api`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_api>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe-api",
        "purl": "pkg:cargo/safe-api"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe-api"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0024.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_api/pull/619"
    }
  ]
},"89":{
  "id": "RUSTSEC-2019-0012",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-07-19T12:00:00Z",
  "aliases": [
    "CVE-2019-15554"
  ],
  "related": [],
  "summary": "Memory corruption in SmallVec::grow()",
  "details": "Attempting to call `grow` on a spilled SmallVec with a value less than the current capacity causes corruption of memory allocator data structures.\n\nAn attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.\n\nCredits to @ehuss for discovering, reporting and fixing the bug.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "smallvec",
        "purl": "pkg:cargo/smallvec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "smallvec::SmallVec::grow"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption"
        ],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.3","<": "0.6.10"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/smallvec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0012.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/servo/rust-smallvec/issues/149"
    }
  ]
},"90":{
  "id": "RUSTSEC-2020-0080",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-13T12:00:00Z",
  "aliases": [
    "CVE-2020-35921"
  ],
  "related": [],
  "summary": "`miow` invalidly assumes the memory layout of std::net::SocketAddr",
  "details": "The [`miow`](https://crates.io/crates/miow) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "miow",
        "purl": "pkg:cargo/miow"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.2"
            },
            {
              ">=": "0.3.0-0","<": "0.3.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/miow"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0080.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/yoshuawuyts/miow/issues/38"
    }
  ]
},"91":{
  "id": "RUSTSEC-2021-0032",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-03-01T12:00:00Z",
  "aliases": [
    "CVE-2021-28033"
  ],
  "related": [],
  "summary": "Deserializing an array can drop uninitialized memory on panic",
  "details": "The `read_bytes_default_le` function for `[T; n]` arrays, used to deserialize\narrays of `T` from bytes created a `[T; n]` array with `std::mem::uninitialized`\nand then called `T`'s deserialization method.\n\nIf `T`'s deserialization method panicked, the uninitialized memory could drop\ninvalid objects.\n\nThis flaw was corrected in `a535678` by removing the unsafe block and using\na `.map` function to deserialize each element of the array instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "byte_struct",
        "purl": "pkg:cargo/byte_struct"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/byte_struct"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0032.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/wwylele/byte-struct-rs/issues/1"
    }
  ]
},"92":{
  "id": "RUSTSEC-2020-0079",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-06T12:00:00Z",
  "aliases": [
    "CVE-2020-35920"
  ],
  "related": [],
  "summary": "`socket2` invalidly assumes the memory layout of std::net::SocketAddr",
  "details": "The [`socket2`](https://crates.io/crates/socket2) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "socket2",
        "purl": "pkg:cargo/socket2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.16"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/socket2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0079.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-lang/socket2-rs/issues/119"
    }
  ]
},"93":{
  "id": "RUSTSEC-2019-0004",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-05-15T12:00:00Z",
  "aliases": [
    "CVE-2019-15545"
  ],
  "related": [],
  "summary": "Failure to properly verify ed25519 signatures makes any signature valid",
  "details": "Affected versions of this crate did not properly verify ed25519 signatures.\nAny signature with a correct length was considered valid.\n\nThis allows an attacker to impersonate any node identity.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libp2p-core",
        "purl": "pkg:cargo/libp2p-core"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.0","<": "0.7.1"
            },
            {
              ">=": "0.8.0-0","<": "0.8.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libp2p-core"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0004.html"
    }
  ]
},"94":{
  "id": "RUSTSEC-2020-0096",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-09T12:00:00Z",
  "aliases": [
    "CVE-2020-36204"
  ],
  "related": [],
  "summary": "TreeFocus lacks bounds on its Send and Sync traits",
  "details": "Affected versions of `im` contains `TreeFocus` that unconditionally implements `Send` and `Sync`.\n\nThis allows a data race in safe Rust code if `TreeFocus` is extracted from `Focus` type.\nTypical users that only use `Focus` type are not affected.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "im",
        "purl": "pkg:cargo/im"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "12.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/im"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0096.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bodil/im-rs/issues/157"
    }
  ]
},"95":{
  "id": "RUSTSEC-2021-0120",
  "modified": "2021-10-17T21:33:02Z",
  "published": "2021-10-17T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "abomonation transmutes &T to and from &[u8] without sufficient constraints",
  "details": "This transmute is at the core of the abomonation crates. It's so easy to use it to violate alignment requirements that no test in the crate's test suite passes under miri.\nThe use of this transmute in serialization/deserialization also incorrectly assumes that the layout of a repr(Rust) type is stable.\nThis transmute can also disclose both the contents of padding bytes which may be an information leak and the contents of pointers, which may be used to defeat ASLR.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "abomonation",
        "purl": "pkg:cargo/abomonation"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/abomonation"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0120.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/TimelyDataflow/abomonation/issues/23"
    }
  ]
},"96":{
  "id": "RUSTSEC-2021-0065",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-05-07T12:00:00Z",
  "aliases": [
    "CVE-2021-38187"
  ],
  "related": [],
  "summary": "anymap is unmaintained.",
  "details": "The `anymap` crate does not appear to be maintained, and the most recent\npublished version 0.12.1 includes a soundness bug. This has been\n[fixed](https://github.com/chris-morgan/anymap/pull/32) a few years ago, but\nwas never released.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "anymap",
        "purl": "pkg:cargo/anymap"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/anymap"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0065.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/chris-morgan/anymap/issues/37"
    }
  ]
},"97":{
  "id": "RUSTSEC-2018-0018",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2018-09-25T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "smallvec creates uninitialized value of any type",
  "details": "Affected versions of this crate called `mem::uninitialized()` to create values of a user-supplied type `T`.\nThis is unsound e.g. if `T` is a reference type (which must be non-null and thus may not remain uninitialized).\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "smallvec",
        "purl": "pkg:cargo/smallvec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.13"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/smallvec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0018.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/servo/rust-smallvec/issues/126"
    }
  ]
},"98":{
  "id": "RUSTSEC-2021-0081",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-06-16T12:00:00Z",
  "aliases": [
    "CVE-2021-38512"
  ],
  "related": [],
  "summary": "Potential request smuggling capabilities due to lack of input validation",
  "details": "Affected versions of this crate did not properly detect invalid requests that could allow HTTP/1 request smuggling (HRS) attacks when running alongside a vulnerable front-end proxy server. This can result in leaked internal and/or user data, including credentials, when the front-end proxy is also vulnerable.\n\nPopular front-end proxies and load balancers already mitigate HRS attacks so it is recommended that they are also kept up to date; check your specific set up. You should upgrade even if the front-end proxy receives exclusively HTTP/2 traffic and connects to the back-end using HTTP/1; several downgrade attacks are known that can also expose HRS vulnerabilities.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "actix-http",
        "purl": "pkg:cargo/actix-http"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.2.1"
            },
            {
              ">=": "3.0.0-0","<": "3.0.0-beta.9"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/actix-http"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0081.html"
    }
  ]
},"99":{
  "id": "RUSTSEC-2018-0013",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-11-27T12:00:00Z",
  "aliases": [
    "CVE-2018-21000"
  ],
  "related": [],
  "summary": "Vec-to-vec transmutations could lead to heap overflow/corruption",
  "details": "Affected versions of this crate switched the length and capacity arguments in the Vec::from_raw_parts() constructor,\nwhich could lead to memory corruption or data leakage.\n\nThe flaw was corrected by using the constructor correctly.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe-transmute",
        "purl": "pkg:cargo/safe-transmute"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.0","<": "0.10.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe-transmute"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0013.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/nabijaczleweli/safe-transmute-rs/pull/36"
    }
  ]
},"100":{
  "id": "RUSTSEC-2020-0025",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-07T12:00:00Z",
  "aliases": [
    "CVE-2020-35880"
  ],
  "related": [],
  "summary": "bigint is unmaintained, use uint instead",
  "details": "The `bigint` crate is not maintained any more and contains several known bugs (including a soundness bug);\nuse [`uint`](https://crates.io/crates/uint) instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bigint",
        "purl": "pkg:cargo/bigint"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bigint"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0025.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/paritytech/bigint/commit/7e71521a61b009afc94c91135353102658550d42"
    }
  ]
},"101":{
  "id": "RUSTSEC-2020-0160",
  "modified": "2021-12-27T19:42:26Z",
  "published": "2020-01-21T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Threshold value is ignored (all shares are n=3)",
  "details": "Affected versions of this crate did not properly calculate secret shares requirements.\n\nThis reduces the security of the algorithm by restricting the crate to always\nusing a threshold value of three, rather than a configurable limit.\n\nThe flaw was corrected by correctly configuring the threshold.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "shamir",
        "purl": "pkg:cargo/shamir"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/shamir"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0160.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Nebulosus/shamir/issues/3"
    }
  ]
},"102":{
  "id": "RUSTSEC-2017-0001",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2017-01-26T12:00:00Z",
  "aliases": [
    "CVE-2017-1000168"
  ],
  "related": [],
  "summary": "scalarmult() vulnerable to degenerate public keys",
  "details": "The `scalarmult()` function included in previous versions of this crate\naccepted all-zero public keys, for which the resulting Diffie-Hellman shared\nsecret will always be zero regardless of the private key used.\n\nThis issue was fixed by checking for this class of keys and rejecting them\nif they are used.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "sodiumoxide",
        "purl": "pkg:cargo/sodiumoxide"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.0.14"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/sodiumoxide"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0001.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/dnaq/sodiumoxide/issues/154"
    }
  ]
},"103":{
  "id": "RUSTSEC-2021-0039",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-04T12:00:00Z",
  "aliases": [
    "CVE-2021-29929"
  ],
  "related": [],
  "summary": "panic in user-provided `Endian` impl triggers double drop of T",
  "details": "Affected versions of the crate does not guard against panic from user-provided impl of `Endian` trait, which is a safe trait that users can implement.\nIf a user-provided implementation of the `Endian` trait panics, double-drop is triggered due to the duplicated ownership of `T` created by `ptr::read()`.\n\nDouble-drop (or double free) can cause memory corruption in the heap.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "endian_trait",
        "purl": "pkg:cargo/endian_trait"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/endian_trait"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0039.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.com/myrrlyn/endian_trait/-/issues/1"
    }
  ]
},"104":{
  "id": "RUSTSEC-2020-0072",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-10-31T12:00:00Z",
  "aliases": [
    "CVE-2020-35915"
  ],
  "related": [],
  "summary": "GenericMutexGuard allows data races of non-Sync types across threads",
  "details": "`GenericMutexGuard<T>` was given the `Sync` auto trait as long as `T` is `Send`\ndue to its contained members. However, since the guard is supposed to represent\nan **acquired lock** and allows concurrent access to the underlying data from\ndifferent threads, it should only be `Sync` when the underlying data is.\n\nThis is a soundness issue and allows data races, potentially leading to crashes\nand segfaults from safe Rust code.\n\nThe flaw was corrected by adding a `T: Send + Sync` bound for\n`GenericMutexGuard`'s `Sync` trait.\n\nThis bug is [similar to one](https://github.com/rust-lang/rust/issues/41622) in\n`std::sync::Mutex`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "futures-intrusive",
        "purl": "pkg:cargo/futures-intrusive"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/futures-intrusive"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0072.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Matthias247/futures-intrusive/issues/53"
    }
  ]
},"105":{
  "id": "RUSTSEC-2020-0137",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36457"
  ],
  "related": [],
  "summary": "AtomicBox<T> lacks bound on its Send and Sync traits allowing data races",
  "details": "`AtomicBox<T>` is a `Box` type designed to be used across threads, however, it\nimplements the `Send` and `Sync` traits for all types `T`.\n\nThis allows non-Send types such as `Rc` and non-Sync types such as `Cell` to\nbe used across thread boundaries which can trigger undefined behavior and\nmemory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lever",
        "purl": "pkg:cargo/lever"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lever"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0137.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/vertexclique/lever/issues/15"
    }
  ]
},"106":{
  "id": "RUSTSEC-2020-0064",
  "modified": "2020-11-02T14:45:15Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_ffi_utils`",
  "details": "This crate has been renamed from `ffi_utils` to `sn_ffi_utils`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_ffi_utils>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ffi_utils",
        "purl": "pkg:cargo/ffi_utils"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ffi_utils"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0064.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_ffi_utils/pull/45"
    }
  ]
},"107":{
  "id": "RUSTSEC-2019-0019",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-08-25T12:00:00Z",
  "aliases": [
    "CVE-2019-16143"
  ],
  "related": [],
  "summary": "HMAC-BLAKE2 algorithms compute incorrect results",
  "details": "When used in conjunction with the Hash-based Message Authentication Code (HMAC),\nthe BLAKE2b and BLAKE2s implementations in `blake2` crate versions prior to\nv0.8.1 used an incorrect block size (32-bytes instead of 64-bytes for BLAKE2s,\nand 64-bytes instead of 128-bytes for BLAKE2b), causing them to miscompute the\n`MacResult`.\n\nThe v0.8.1 release of the `blake2` crate uses the correct block sizes.\n\nNote that this advisory only impacts usage of BLAKE2 with HMAC, and does not\nimpact `Digest` functionality.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "blake2",
        "purl": "pkg:cargo/blake2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.8.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/blake2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0019.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustCrypto/MACs/issues/19"
    }
  ]
},"108":{
  "id": "RUSTSEC-2020-0121",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36441"
  ],
  "related": [],
  "summary": "AtomicBox<T> implements Send/Sync for any `T: Sized`",
  "details": "Affected versions of this crate implements `Send`/`Sync` for `AtomicBox<T>` without requiring `T: Send`/`T: Sync`. This allows to create data races to `T: !Sync` and send `T: !Send` to another thread.\n\nSuch behavior breaks the compile-time thread safety guarantees of Rust, and allows users to incur undefined behavior using safe Rust (e.g. memory corruption from data race).\n\nThe flaw was corrected in commit 34c2b9e by adding trait bound `T: Send` to `Send` impl for `AtomicBox<T>` and trait bound `T: Sync` to `Sync` impl for `AtomicBox<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "abox",
        "purl": "pkg:cargo/abox"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/abox"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0121.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/SonicFrog/abox/issues/1"
    }
  ]
},"109":{
  "id": "RUSTSEC-2021-0097",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-08-24T12:00:00Z",
  "aliases": [
    "CVE-2021-3711"
  ],
  "related": [],
  "summary": "SM2 Decryption Buffer Overflow",
  "details": "In order to decrypt SM2 encrypted data an application is expected to call the\nAPI function `EVP_PKEY_decrypt()`. Typically an application will call this\nfunction twice. The first time, on entry, the \"out\" parameter can be NULL and,\non exit, the \"outlen\" parameter is populated with the buffer size required to\nhold the decrypted plaintext. The application can then allocate a sufficiently\nsized buffer and call `EVP_PKEY_decrypt()` again, but this time passing a non-NULL\nvalue for the \"out\" parameter.\n\nA bug in the implementation of the SM2 decryption code means that the\ncalculation of the buffer size required to hold the plaintext returned by the\nfirst call to `EVP_PKEY_decrypt()` can be smaller than the actual size required by\nthe second call. This can lead to a buffer overflow when `EVP_PKEY_decrypt()` is\ncalled by the application a second time with a buffer that is too small.\n\nA malicious attacker who is able present SM2 content for decryption to an\napplication could cause attacker chosen data to overflow the buffer by up to a\nmaximum of 62 bytes altering the contents of other data held after the\nbuffer, possibly changing application behaviour or causing the application to\ncrash. The location of the buffer is application dependent but is typically\nheap allocated.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "111.16.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0097.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20210824.txt"
    }
  ]
},"110":{
  "id": "RUSTSEC-2021-0078",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-07-07T12:00:00Z",
  "aliases": [
    "CVE-2021-32715",
    "GHSA-f3pg-qwvg-p99c"
  ],
  "related": [],
  "summary": "Lenient `hyper` header parsing of `Content-Length` could allow request smuggling",
  "details": "`hyper`'s HTTP header parser accepted, according to RFC 7230, illegal contents inside `Content-Length` headers.\nDue to this, upstream HTTP proxies that ignore the header may still forward them along if it chooses to ignore the error.\n\nTo be vulnerable, `hyper` must be used as an HTTP/1 server and using an HTTP proxy upstream that ignores the header's contents\nbut still forwards it. Due to all the factors that must line up, an attack exploiting this vulnerability is unlikely.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hyper",
        "purl": "pkg:cargo/hyper"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.14.10"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hyper"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0078.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/hyperium/hyper/security/advisories/GHSA-f3pg-qwvg-p99c"
    }
  ]
},"111":{
  "id": "RUSTSEC-2018-0005",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2018-09-17T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Uncontrolled recursion leads to abort in deserialization",
  "details": "Affected versions of this crate did not properly check for recursion\nwhile deserializing aliases.\n\nThis allows an attacker to make a YAML file with an alias referring\nto itself causing an abort.\n\nThe flaw was corrected by checking the recursion depth.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "serde_yaml",
        "purl": "pkg:cargo/serde_yaml"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.0-rc1","<": "0.8.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/serde_yaml"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0005.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/dtolnay/serde-yaml/pull/105"
    }
  ]
},"112":{
  "id": "RUSTSEC-2020-0033",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-08-25T12:00:00Z",
  "aliases": [
    "CVE-2020-36432"
  ],
  "related": [],
  "summary": "Matrix::new() drops uninitialized memory",
  "details": "`Matrix::new()` internally calls `Matrix::fill_with()` which uses `*ptr = value` pattern to initialize the buffer.\nThis pattern assumes that there is an initialized struct at the address and drops it, which results in dropping of uninitialized struct.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "alg_ds",
        "purl": "pkg:cargo/alg_ds"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/alg_ds"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0033.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.com/dvshapkin/alg-ds/-/issues/1"
    }
  ]
},"113":{
  "id": "RUSTSEC-2021-0003",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-08T12:00:00Z",
  "aliases": [
    "CVE-2021-25900"
  ],
  "related": [],
  "summary": "Buffer overflow in SmallVec::insert_many",
  "details": "A bug in the `SmallVec::insert_many` method caused it to allocate a buffer that was smaller than needed.  It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap.\n\nThis bug was only triggered if the iterator passed to `insert_many` yielded more items than the lower bound returned from its `size_hint` method.\n \nThe flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted.  The fix also simplified the implementation of `insert_many` to use less unsafe code, so it is easier to verify its correctness.\n\nThank you to Yechan Bae (@Qwaz) and the Rust group at Georgia Tech’s SSLab for finding and reporting this bug.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "smallvec",
        "purl": "pkg:cargo/smallvec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "smallvec::SmallVec::insert_many"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.3","<": "0.6.14"
            },
            {
              ">=": "1.0.0","<": "1.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/smallvec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0003.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/servo/rust-smallvec/issues/252"
    }
  ]
},"114":{
  "id": "RUSTSEC-2019-0035",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-04-19T12:00:00Z",
  "aliases": [
    "GHSA-mmc9-pwm7-qj5w",
    "CVE-2020-25576"
  ],
  "related": [],
  "summary": "Unaligned memory access",
  "details": "Affected versions of this crate violated alignment when casting byte slices to\ninteger slices, resulting in undefined behavior.\n\nThe flaw was corrected by Ralf Jung and Diggory Hardy.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rand_core",
        "purl": "pkg:cargo/rand_core"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rand_core::BlockRng::fill_bytes",
            "rand_core::BlockRng::next_u64"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1"
            },
            {
              ">=": "0.4.0-0","<": "0.4.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rand_core"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0035.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-random/rand/blob/master/rand_core/CHANGELOG.md#050---2019-06-06"
    }
  ]
},"115":{
  "id": "RUSTSEC-2020-0048",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-24T12:00:00Z",
  "aliases": [
    "CVE-2020-35901"
  ],
  "related": [],
  "summary": "Use-after-free in BodyStream due to lack of pinning",
  "details": "Affected versions of this crate did not require the buffer wrapped in `BodyStream` to be pinned,\nbut treated it as if it had a fixed location in memory. This may result in a use-after-free.\n \nThe flaw was corrected by making the trait `MessageBody` require `Unpin`\nand making `poll_next()` function accept `Pin<&mut Self>` instead of `&mut self`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "actix-http",
        "purl": "pkg:cargo/actix-http"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.0-alpha.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/actix-http"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0048.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/actix/actix-web/issues/1321"
    }
  ]
},"116":{
  "id": "RUSTSEC-2021-0054",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-04-28T12:00:00Z",
  "aliases": [
    "CVE-2021-31919"
  ],
  "related": [],
  "summary": "Archives may contain uninitialized memory",
  "details": "`rkyv` is a serialization framework that writes struct-compatible memory to be stored or\ntransmitted. During serialization, struct padding bytes and unused enum bytes may not be\ninitialized. These bytes may be written to disk or sent over unsecured channels.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rkyv",
        "purl": "pkg:cargo/rkyv"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rkyv::Archive::resolve"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rkyv"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0054.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/djkoloski/rkyv/issues/113"
    }
  ]
},"117":{
  "id": "RUSTSEC-2022-0001",
  "modified": "2022-01-05T16:02:27Z",
  "published": "2022-01-05T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "lmdb is unmaintained, use lmdb-rkv instead",
  "details": "The lmdb crate hasn't had any updates since August 2018.\n\nMozilla's [lmdb-rkv](https://github.com/mozilla/lmdb-rs) fork of the crate has received additional maintenance work beyond that and is the best available replacement.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lmdb",
        "purl": "pkg:cargo/lmdb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lmdb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0001.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/danburkert/lmdb-rs"
    }
  ]
},"118":{
  "id": "RUSTSEC-2021-0111",
  "modified": "2021-09-18T18:10:57Z",
  "published": "2021-09-16T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Memory Safety Issue when using `patch` or `merge` on `state` and assign the result back to `state`",
  "details": "Affected versions of this crate maintains references to memory that might have been freed already.\nIf affects the following two `tremor-script` language constructs:\n\n* A [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) where we assign the result back to the target expression\n  and the expression to be merged needs to reference the `event`:\n\n```\nlet state = merge state of event end;\n```\n\n* A [Patch](https://www.tremor.rs/docs/tremor-script/index#patch) where we assign the result back to the target expression\n  and the patch operations used need to reference the `event`:\n\n```\nlet state = patch state of insert event.key => event.value end;\n```\n\nFor constructs like this (it doesnt matter what is references in the expression to be merged or the patch operations) an optimization\nwas applied to manipulate the target value in-place, instead of cloning it.\n\nOur `Value` struct which underpins all event data in `tremor-script`, is representing as borrowed strings `beef::Cow<'lifetime, str>` \nthat reference the actual `Vec<u8>` the event is based upon. We keep the raw byte-array next to the event structure inside our `Event` struct as a self-referential struct,\nso we make sure that the structured `Value` and its references are valid across its whole lifetime.\n\nThe optimization was considered safe as long as it was only possible to merge or patche `event` data or static data.\nWhen `state` was introduced to `tremor-script` a new possibility existed, to keep `Value` data around for longer than the lifetime of an event.\nIf `event` data is merged or patched into `state` without cloning `state` first, it can still reference keys or values from\nthe previous event, which will now be invalid. This allows access to those already freed regions of memory and to get their content out over the wire.\n\n\n## Workaround\n\nIf an upgrade is not possible, a possible workaround is to avoid the optimization\nby introducing a temporary variable and not immediately reassigning to `state`:\n\n```\nlet tmp = merge state of event end;\nlet state = tmp\n```\n\n## Fix\n\nThe flaw was corrected in `tremor-script` version 0.11.6 via commit [1a2efcd](https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e) by removing the optimization\nand always clone the target expression of a [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) or [Patch](https://www.tremor.rs/docs/tremor-script/index#patch.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tremor-script",
        "purl": "pkg:cargo/tremor-script"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.7.3-0","<": "0.11.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tremor-script"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0111.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/tremor-rs/tremor-runtime/pull/1217"
    }
  ]
},"119":{
  "id": "RUSTSEC-2021-0042",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-26T12:00:00Z",
  "aliases": [
    "CVE-2021-29933"
  ],
  "related": [],
  "summary": "insert_many can drop elements twice on panic",
  "details": "Affected versions of `insert_many` used `ptr::copy` to move over items in a\nvector to make space before inserting, duplicating their ownership. It then\niterated over a provided `Iterator` to insert the new items.\n\nIf the iterator's `.next()` method panics then the vector would drop the same\nelements twice.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "insert_many",
        "purl": "pkg:cargo/insert_many"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/insert_many"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0042.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rphmeier/insert_many/issues/1"
    }
  ]
},"120":{
  "id": "RUSTSEC-2021-0107",
  "modified": "2021-09-10T15:50:27Z",
  "published": "2021-07-25T12:00:00Z",
  "aliases": [
    "GHSA-v666-6w97-pcwm"
  ],
  "related": [],
  "summary": "Miner fails to get block template when a cell used as a cell dep has been destroyed.",
  "details": "## Impact\n\nThe RPC get_block_template fails when a cell has been used as a cell dep and an input in the different transactions.\n\nSay cell C is used as a dep group in the transaction A, and is destroyed in the transaction B.\n\nThe node adds transaction A first, then B into the transaction pool. They are both valid. But when generating the block template, if the fee rate of B is higher, it comes before A, which will invalidate A. Currently the RPC get_block_template will fail instead of dropping A.\n\n## Patch\n\nFirst, the get_block_template should not fail but dropping the conflict transactions.\n\nThen we can propose solution to this issue. Here is an example. When a transaction is added to the pool, the pool must consider it depending on all the transactions which dep cell (direct or indirect via dep group) has been destroyed in this transaction. Because future transactions using the destroyed cells as dep will be rejected, the spending transaction only need to wait for all the existing dep transactions on chain.\n\n## Workaround\n\n    Submit transaction B when A is already on chain.\n    Let B depend on A explicitly, there are several solutions:\n        a. Add any output cell on A as a dep cell or input in B.\n        b. Merge A and B. CKB allows using the same cell as both dep and input in the same transaction.\n    Ensure the fee rate of B is less than A so A always has higher priority.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ckb",
        "purl": "pkg:cargo/ckb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.40.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ckb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0107.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-v666-6w97-pcwm"
    }
  ]
},"121":{
  "id": "RUSTSEC-2020-0009",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-04-11T12:00:00Z",
  "aliases": [
    "CVE-2020-35864"
  ],
  "related": [],
  "summary": "`read_scalar` and `read_scalar_at` allow transmuting values without `unsafe` blocks",
  "details": "The `read_scalar` and `read_scalar_at` functions are unsound\nbecause they allow transmuting values without `unsafe` blocks.\n\nThe following example shows how to create a dangling reference:\n\n```\nfn main() {\n    #[derive(Copy, Clone, PartialEq, Debug)]\n    struct S(&'static str);\n    impl flatbuffers::EndianScalar for S {\n        fn to_little_endian(self) -> Self { self }\n        fn from_little_endian(self) -> Self { self }\n    }\n    println!(\"{:?}\", flatbuffers::read_scalar::<S>(&[1; std::mem::size_of::<S>()]));\n}\n```",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "flatbuffers",
        "purl": "pkg:cargo/flatbuffers"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "flatbuffers::read_scalar",
            "flatbuffers::read_scalar_at"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.0","<": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/flatbuffers"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0009.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/google/flatbuffers/issues/5825"
    }
  ]
},"122":{
  "id": "RUSTSEC-2021-0015",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-06T12:00:00Z",
  "aliases": [
    "CVE-2021-26951"
  ],
  "related": [],
  "summary": "`Sectors::get` accesses unclaimed/uninitialized memory",
  "details": "Affected versions of this crate arbitrarily calls `Vec::set_len` to increase length of a vector without claiming more memory for the vector. Affected versions of this crate\nalso calls user-provided `Read` on the uninitialized memory of the vector that was\nextended with `Vec::set_len`.\n\nThis can overwrite active entities in adjacent heap memory and seems to be a major security issue. Also, calling user-provided `Read` on uninitialized memory is defined as UB in Rust.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "calamine",
        "purl": "pkg:cargo/calamine"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.17.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/calamine"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0015.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tafia/calamine/issues/199"
    }
  ]
},"123":{
  "id": "RUSTSEC-2019-0023",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-08-24T12:00:00Z",
  "aliases": [
    "CVE-2019-16882"
  ],
  "related": [],
  "summary": "Cloned interners may read already dropped strings",
  "details": "Affected versions of this crate did not clone contained strings when an interner is cloned.\nInterners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned.\nIf a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.\n\nThis allows an attacker to read the already freed memory.\nThe dangling pointers are used by the interners to check a string is already interned.\nAn attacker can do brute force attack to get the data pointed by the dangling pointer.\n\nThe flaw was corrected by <https://github.com/Robbepop/string-interner/pull/10>.\nThis patch implements `Clone` manually to the interner type, so that the internal raw pointers always point the strings owned by the same interner.\n\nPR #10 was also backported to the 0.6 release line in\n<https://github.com/Robbepop/string-interner/pull/14> and was released in 0.6.4.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "string-interner",
        "purl": "pkg:cargo/string-interner"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.4"
            },
            {
              ">=": "0.7.0-0","<": "0.7.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/string-interner"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0023.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Robbepop/string-interner/issues/9"
    }
  ]
},"124":{
  "id": "RUSTSEC-2020-0029",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-06-14T12:00:00Z",
  "aliases": [
    "CVE-2020-25016"
  ],
  "related": [],
  "summary": "Allows viewing and modifying arbitrary structs as bytes",
  "details": "Affected versions of rgb crate allow viewing and modifying data of any type `T` wrapped in `RGB<T>` as bytes,\nand do not correctly constrain `RGB<T>` and other wrapper structures to the types for which it is safe to do so.\n\nSafety violation possible for a type wrapped in `RGB<T>` and similar wrapper structures:\n\n * If `T` contains padding, viewing it as bytes may lead to exposure of contents of uninitialized memory.\n * If `T` contains a pointer, modifying it as bytes may lead to dereferencing of arbitrary pointers.\n * Any safety and/or validity invariants for `T` may be violated.\n \nThe issue was resolved by requiring all types wrapped in structures provided by RGB crate to implement an unsafe marker trait.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rgb",
        "purl": "pkg:cargo/rgb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.5.4","<": "0.8.20"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rgb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0029.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/kornelski/rust-rgb/issues/35"
    }
  ]
},"125":{
  "id": "RUSTSEC-2021-0127",
  "modified": "2021-12-01T14:04:55Z",
  "published": "2021-08-15T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "serde_cbor is unmaintained",
  "details": "The `serde_cbor` crate is unmaintained. The author has archived the github repository.\n\nAlternatives proposed by the author:\n\n * [`ciborium`](https://crates.io/crates/ciborium)\n * [`minicbor`](https://crates.io/crates/minicbor)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "serde_cbor",
        "purl": "pkg:cargo/serde_cbor"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/serde_cbor"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0127.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/pyfisch/cbor"
    }
  ]
},"126":{
  "id": "RUSTSEC-2021-0062",
  "modified": "2021-05-03T19:05:09Z",
  "published": "2021-02-28T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "project abandoned; migrate to the `aes-siv` crate",
  "details": "The Miscreant project has been abandoned and archived.\n\nThe Rust implementation has been adapted into the new `aes-siv` crate which\nimplements both the AES-CMAC-SIV and AES-PMAC-SIV constructions:\n\n<https://github.com/RustCrypto/AEADs/tree/master/aes-siv>\n\nPlease migrate to the `aes-siv` crate.\n\nAlternatively see the `aes-gcm-siv` crate for a newer, faster construction\nwhich provides similar properties:\n\n<https://github.com/RustCrypto/AEADs/tree/master/aes-gcm-siv>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "miscreant",
        "purl": "pkg:cargo/miscreant"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/miscreant"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0062.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/miscreant/miscreant.rs/commit/5d921f579e0c2b9960d472cf377b8487d97fbcec"
    }
  ]
},"127":{
  "id": "RUSTSEC-2019-0003",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-06-08T12:00:00Z",
  "aliases": [
    "CVE-2019-15544"
  ],
  "related": [],
  "summary": "Out of Memory in stream::read_raw_bytes_into()",
  "details": "Affected versions of this crate called Vec::reserve() on user-supplied input.\n\nThis allows an attacker to cause an Out of Memory condition while calling the\nvulnerable method on untrusted data.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "protobuf",
        "purl": "pkg:cargo/protobuf"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "protobuf::stream::read_raw_bytes_into"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.7.5"
            },
            {
              ">=": "2.0.0-0","<": "2.6.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/protobuf"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0003.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/stepancheg/rust-protobuf/issues/411"
    }
  ]
},"128":{
  "id": "RUSTSEC-2020-0091",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-10T12:00:00Z",
  "aliases": [
    "CVE-2020-35711"
  ],
  "related": [],
  "summary": "Dangling reference in `access::Map` with Constant",
  "details": "Using the `arc_swap::access::Map` with the `Constant` test helper (or with\nuser-provided implementation of the `Access` trait) could sometimes lead to the\nmap returning dangling references.\n\nReplaced by implementation without `unsafe`, at the cost of added `Clone` bound\non the closure and small penalty on performance.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arc-swap",
        "purl": "pkg:cargo/arc-swap"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "arc_swap::access::MapGuard::deref"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.2","<": "0.4.8"
            },
            {
              ">=": "1.0.0-0","<": "1.1.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arc-swap"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0091.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/vorner/arc-swap/issues/45"
    }
  ]
},"129":{
  "id": "RUSTSEC-2021-0035",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-03-04T12:00:00Z",
  "aliases": [
    "CVE-2021-28036"
  ],
  "related": [],
  "summary": "`quinn` invalidly assumes the memory layout of std::net::SocketAddr",
  "details": "The [`quinn`](https://crates.io/crates/quinn) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "quinn",
        "purl": "pkg:cargo/quinn"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.4"
            },
            {
              ">=": "0.6.0-0","<": "0.6.2"
            },
            {
              ">=": "0.7.0-0","<": "0.7.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/quinn"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0035.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/quinn-rs/quinn/issues/968"
    }
  ]
},"130":{
  "id": "RUSTSEC-2019-0015",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-05-21T12:00:00Z",
  "aliases": [
    "CVE-2019-16139"
  ],
  "related": [],
  "summary": "Flaw in generativity allows out-of-bounds access",
  "details": "Affected versions of this crate did not properly implement the generativity,\nbecause the invariant lifetimes were not necessarily `drop`ped.\n\nThis allows an attacker to mix up two arenas, using indices created from one\narena with another one. This might lead to an out-of-bounds read or write\naccess into the memory reserved for the arena.\n\nThe flaw was corrected by implementing generativity correctly in version 0.4.0.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "compact_arena",
        "purl": "pkg:cargo/compact_arena"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "compact_arena::SmallArena::new"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/compact_arena"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0015.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/llogiq/compact_arena/issues/22"
    }
  ]
},"131":{
  "id": "RUSTSEC-2020-0068",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-08T12:00:00Z",
  "aliases": [
    "CVE-2020-35909"
  ],
  "related": [],
  "summary": "Unexpected panic in multihash `from_slice` parsing code",
  "details": "In versions prior 0.11.3 it's possible to make `from_slice` panic by feeding it certain malformed input.\nIt's never documented that `from_slice` (and `from_bytes` which wraps it) can panic, and its' return type (`Result<Self, DecodeError>`) suggests otherwise.\n\nIn practice, `from_slice`/`from_bytes` is frequently used in networking code (for example [in rust-libp2p](https://github.com/libp2p/rust-libp2p/blob/7b415d5e7040e45c541f76f2c409e63d4d3249c6/core/src/peer_id.rs#L89)) and is being called with unsanitized data from untrusted sources.\nThis can allow attackers to cause DoS by causing an unexpected `panic` in the network client's code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "multihash",
        "purl": "pkg:cargo/multihash"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "multihash::digests::MultihashGeneric::from_bytes",
            "multihash::digests::MultihashRefGeneric::from_slice"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.11.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/multihash"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0068.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/multiformats/rust-multihash/pull/72"
    }
  ]
},"132":{
  "id": "RUSTSEC-2020-0087",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-17T12:00:00Z",
  "aliases": [
    "CVE-2020-35924"
  ],
  "related": [],
  "summary": "TryMutex<T> allows sending non-Send type across threads",
  "details": "Affected versions of this crate unconditionally implemented Sync trait for `TryMutex<T>` type.\n\nThis allows users to put non-Send `T` type in `TryMutex` and send it to another thread, which can cause a data race.\n\nThe flaw was corrected in the 0.3.0 release by adding `T: Send` bound for the Sync trait implementation.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "try-mutex",
        "purl": "pkg:cargo/try-mutex"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/try-mutex"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0087.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/mpdn/try-mutex/issues/2"
    }
  ]
},"133":{
  "id": "RUSTSEC-2021-0023",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-12T12:00:00Z",
  "aliases": [
    "CVE-2021-27378"
  ],
  "related": [],
  "summary": "Incorrect check on buffer length when seeding RNGs",
  "details": "Summary: rand_core::le::read_u32_into and read_u64_into have incorrect checks on the source buffer length, allowing the destination buffer to be under-filled.\n\nImplications: some downstream RNGs, including Hc128Rng (but not the more widely used ChaCha*Rng), allow seeding using the SeedableRng::from_seed trait-function with too short keys.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rand_core",
        "purl": "pkg:cargo/rand_core"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rand_core::le::read_u32_into",
            "rand_core::le::read_u64_into"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.0","<": "0.6.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rand_core"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0023.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-random/rand/pull/1096"
    }
  ]
},"134":{
  "id": "RUSTSEC-2021-0131",
  "modified": "2021-12-21T20:51:30Z",
  "published": "2021-12-20T12:00:00Z",
  "aliases": [
    "CVE-2020-8927"
  ],
  "related": [],
  "summary": "Integer overflow in the bundled Brotli C library",
  "details": "A buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a \"one-shot\" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.\n\nAn updated version of `brotli-sys` has not been released. If one cannot update the C library, its authors recommend to use the \"streaming\" API as opposed to the \"one-shot\" API, and impose chunk size limits.\n\nIn Rust the issue can be mitigated by migrating to the `brotli` crate, which provides a Rust implementation of Brotli compression and decompression that is not affected by this issue.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "brotli-sys",
        "purl": "pkg:cargo/brotli-sys"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/brotli-sys"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0131.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bitemyapp/brotli2-rs/issues/45"
    },
    {
      "type": "WEB",
      "url": "https://github.com/google/brotli/releases/tag/v1.0.9"
    }
  ]
},"135":{
  "id": "RUSTSEC-2018-0009",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-12-09T12:00:00Z",
  "aliases": [
    "CVE-2018-20996"
  ],
  "related": [],
  "summary": "MsQueue and SegQueue suffer from double-free",
  "details": "Even if an element is popped from a queue, crossbeam would run its\ndestructor inside the epoch-based garbage collector. This is a source\nof double frees.\n\nThe flaw was corrected by wrapping elements inside queues in a\n`ManuallyDrop`.\n\nThanks to @c0gent for reporting the issue.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "crossbeam",
        "purl": "pkg:cargo/crossbeam"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.0","<": "0.4.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/crossbeam"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0009.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/crossbeam-rs/crossbeam-epoch/issues/82"
    }
  ]
},"136":{
  "id": "RUSTSEC-2021-0074",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-07-08T12:00:00Z",
  "aliases": [
    "CVE-2021-38193"
  ],
  "related": [],
  "summary": "Incorrect handling of embedded SVG and MathML leads to mutation XSS",
  "details": "Affected versions of this crate did not account for namespace-related parsing\ndifferences between HTML, SVG, and MathML. Even if the `svg` and `math` elements\nare not allowed, the underlying HTML parser still treats them differently.\nRunning cleanup without accounting for these differing namespaces resulted in an \"impossible\"\nDOM, which appeared \"safe\" when examining the DOM tree, but when serialized and deserialized,\ncould be exploited to inject abitrary markup.\n\nTo exploit this, the application using this library must allow a tag that is parsed as raw text in HTML.\nThese [elements] are:\n\n* title\n* textarea\n* xmp\n* iframe\n* noembed\n* noframes\n* plaintext\n* noscript\n* style\n* script\n\nApplications that do not explicitly allow any of these tags should not be affected, since none are allowed by default.\n\n[elements]: https://github.com/servo/html5ever/blob/57eb334c0ffccc6f88d563419f0fbeef6ff5741c/html5ever/src/tree_builder/rules.rs",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ammonia",
        "purl": "pkg:cargo/ammonia"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.1.3"
            },
            {
              ">=": "3.0.0","<": "3.1.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ammonia"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0074.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-ammonia/ammonia/pull/142"
    }
  ]
},"137":{
  "id": "RUSTSEC-2020-0101",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-22T12:00:00Z",
  "aliases": [
    "CVE-2020-36208"
  ],
  "related": [],
  "summary": "conquer-once's OnceCell lacks Send bound for its Sync trait.",
  "details": "Affected versions of `conquer-once` implements `Sync` for its `OnceCell` type\nwithout restricting it to `Send`able types.\n\nThis allows non-`Send` but `Sync` types such as `MutexGuard` to be sent across\nthreads leading to undefined behavior and memory corruption in concurrent\nprograms.\n\nThe issue was fixed by adding a `Send` constraint to `OnceCell`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "conquer-once",
        "purl": "pkg:cargo/conquer-once"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/conquer-once"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0101.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/oliver-giersch/conquer-once/issues/3"
    }
  ]
},"138":{
  "id": "RUSTSEC-2020-0044",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-21T12:00:00Z",
  "aliases": [
    "CVE-2020-35897"
  ],
  "related": [],
  "summary": "Unsafe Send implementation in Atom allows data races",
  "details": "The `atom` crate contains a security issue revolving around its implementation\nof the Send trait. It incorrectly allows any arbitrary type to be sent across\nthreads potentially leading to use-after-free issues through memory races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "atom",
        "purl": "pkg:cargo/atom"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/atom"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0044.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/slide-rs/atom/issues/13"
    }
  ]
},"139":{
  "id": "RUSTSEC-2020-0156",
  "modified": "2021-09-10T16:03:52Z",
  "published": "2020-01-22T12:00:00Z",
  "aliases": [
    "CVE-2019-20399",
    "GHSA-7cqg-8449-rmfv"
  ],
  "related": [],
  "summary": "Observable Discrepancy in libsecp256k1-rs",
  "details": "A timing vulnerability in the Scalar::check_overflow function in Parity libsecp256k1-rs before 0.3.1 potentially allows an attacker to leak information via a side-channel attack.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libsecp256k1-rs",
        "purl": "pkg:cargo/libsecp256k1-rs"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libsecp256k1-rs"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0156.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2019-20399"
    }
  ]
},"140":{
  "id": "RUSTSEC-2020-0013",
  "modified": "2021-01-14T17:57:27Z",
  "published": "2020-04-24T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "fake-static allows converting any reference into a `'static` reference",
  "details": "fake-static allows converting a reference with any lifetime into\na reference with `'static` lifetime without the `unsafe` keyword.\n\nInternally, this crate does not use unsafe code, it instead\nexploits a soundness bug in rustc:\n\nhttps://github.com/rust-lang/rust/issues/25860",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "fake-static",
        "purl": "pkg:cargo/fake-static"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/fake-static"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0013.html"
    }
  ]
},"141":{
  "id": "RUSTSEC-2021-0058",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-05-01T12:00:00Z",
  "aliases": [
    "CVE-2021-23841"
  ],
  "related": [],
  "summary": "Null pointer deref in `X509_issuer_and_serial_hash()`",
  "details": "The OpenSSL public API function `X509_issuer_and_serial_hash()` attempts to\ncreate a unique hash value based on the issuer and serial number data contained\nwithin an X509 certificate. However it fails to correctly handle any errors\nthat may occur while parsing the issuer field (which might occur if the issuer\nfield is maliciously constructed). This may subsequently result in a NULL\npointer deref and a crash leading to a potential denial of service attack.\n\nThe function `X509_issuer_and_serial_hash()` is never directly called by OpenSSL\nitself so applications are only vulnerable if they use this function directly\nand they use it on certificates that may have been obtained from untrusted\nsources.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "111.14.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0058.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20210216.txt"
    }
  ]
},"142":{
  "id": "RUSTSEC-2020-0140",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36460"
  ],
  "related": [],
  "summary": "`Shared` can cause a data race",
  "details": "`Shared` data structure in `model` crate implements `Send` and `Sync` traits regardless of the inner type.\nThis allows safe Rust code to trigger a data race, which is undefined behavior in Rust.\n\nUsers are advised to treat `Shared` as an unsafe type.\nIt should not be used outside of the testing context,\nand care must be taken so that the testing code does not have a data race\nbesides a race condition that is expected to be caught by the test.\n\nCheck [the Rustonomicon](https://doc.rust-lang.org/nomicon/races.html) for the difference between\na data race and a general race condition.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "model",
        "purl": "pkg:cargo/model"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/model"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0140.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/spacejam/model/issues/3"
    }
  ]
},"143":{
  "id": "RUSTSEC-2020-0005",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-03-19T12:00:00Z",
  "aliases": [
    "CVE-2020-35860"
  ],
  "related": [],
  "summary": "CBox API allows to de-reference raw pointers without `unsafe` code",
  "details": "`CBox` and `CSemiBox` are part of the public API of the cbox crate\nand they allow to create smart pointers from raw pointers and de-reference\nthem without the need of `unsafe` code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cbox",
        "purl": "pkg:cargo/cbox"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cbox"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0005.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/TomBebbington/cbox-rs/issues/2"
    }
  ]
},"144":{
  "id": "RUSTSEC-2020-0117",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-24T12:00:00Z",
  "aliases": [
    "CVE-2020-36437"
  ],
  "related": [],
  "summary": "QueueSender<T>/QueueReceiver<T>: Send/Sync impls need `T: Send`",
  "details": "Affected versions of this crate unconditionally implemented `Send`/`Sync` for `QueueSender<T>`,\nallowing to send non-Send `T` to other threads by invoking `(&QueueSender<T>).send()`.\n\nThis fails to prevent users from creating data races by sending types like `Rc<T>` or `Arc<Cell<T>>` to other threads, which can lead to memory corruption.\n\nThe flaw was corrected in commit 1e462c3 by imposing `T: Send` to both `Send`/`Sync` impls for `QueueSender<T>`/`QueueReceiver<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "conqueue",
        "purl": "pkg:cargo/conqueue"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/conqueue"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0117.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/longshorej/conqueue/issues/9"
    }
  ]
},"145":{
  "id": "RUSTSEC-2020-0052",
  "modified": "2021-01-04T17:02:59Z",
  "published": "2020-06-26T12:00:00Z",
  "aliases": [
    "CVE-2020-35904",
    "CVE-2020-15254",
    "GHSA-v5m7-53cv-f3hx"
  ],
  "related": [],
  "summary": "Undefined Behavior in bounded channel",
  "details": "The affected version of this crate's the `bounded` channel incorrectly assumes that `Vec::from_iter` has allocated capacity that same as the number of iterator elements. `Vec::from_iter` does not actually guarantee that and may allocate extra memory. The destructor of the `bounded` channel reconstructs `Vec` from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when `Vec::from_iter` has allocated different sizes with the number of iterator elements.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "crossbeam-channel",
        "purl": "pkg:cargo/crossbeam-channel"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.3","<": "0.4.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/crossbeam-channel"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0052.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/crossbeam-rs/crossbeam/pull/533"
    }
  ]
},"146":{
  "id": "RUSTSEC-2021-0019",
  "modified": "2022-03-06T11:11:48Z",
  "published": "2021-02-04T12:00:00Z",
  "aliases": [
    "CVE-2021-26955",
    "CVE-2021-26956",
    "CVE-2021-26957",
    "CVE-2021-26958"
  ],
  "related": [],
  "summary": "Multiple soundness issues",
  "details": "## Calls `std::str::from_utf8_unchecked()` without any checks\n\nThe function `xcb::xproto::GetAtomNameReply::name()` calls\n`std::str::from_utf8_unchecked()` on the raw bytes that were received from the\nX11 server without any validity checks. The X11 server only prevents interior\nnull bytes, but otherwise allows any X11 client to create an atom for arbitrary\nbytes.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/96\n\n## `xcb::xproto::GetPropertyReply::value()` allows arbitrary return types\n\nThe function `xcb::xproto::GetPropertyReply::value()` returns a slice of type\n`T` where `T` is an unconstrained type parameter. The raw bytes received from\nthe X11 server are interpreted as the requested type.\n\nThe users of the `xcb` crate are advised to only call this function with the\nintended types. These are `u8`, `u16`, and `u32`.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/95\n\n## Out of bounds read in `xcb::xproto::change_property()`\n\n`xcb::xproto::change_property` has (among others) the arguments `format: u8` and\n`data: &[T]`. The intended use is one of the following cases:\n- `format = 8` and `T = u8`\n- `format = 16` and `T = u16`\n- `format = 32` and `T = u32`\nHowever, this constraint is not enforced. For example, it is possible to call\nthe function with `format = 32` and `T = u8`. In this case, a read beyond the\nend of the `data` slice is performed and the bytes are sent to the X11 server.\n\nThe users of the `xcb` crate are advised to only call this function with one of\nthe intended argument combinations.\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/94\n\n## 'Safe' wrapper around `std::mem::transmute()`\n\nThe function `xcb::base::cast_event()` takes a reference to a\n`xcb::base::GenericEvent` and returns a reference to an arbitrary type, as\nrequested by the caller (or found via type interference). The function is\nimplemented as a direct call to `std::mem::transmute()`. Since the return type\nis not constrained, this allows transmution to an incorrect type or a type that\nis larger than the X11 event that was passed in.\n\nX11 events are mostly always 32 bytes large and this function works as intended.\n\nUsers are advised to only cast to the event structs provided by the `xcb` crate\n(and hope for the best).\n\nThis issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/78",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "xcb",
        "purl": "pkg:cargo/xcb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/xcb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0019.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/653"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-x-bindings/rust-xcb/issues/78"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-x-bindings/rust-xcb/issues/94"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-x-bindings/rust-xcb/issues/95"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-x-bindings/rust-xcb/issues/96"
    }
  ]
},"147":{
  "id": "RUSTSEC-2021-0018",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-03T12:00:00Z",
  "aliases": [
    "CVE-2021-26954"
  ],
  "related": [],
  "summary": "insert_slice_clone can double drop if Clone panics.",
  "details": "Affected versions of this crate used `ptr::copy` when inserting into the middle\nof a `Vec`. When ownership was temporarily duplicated during this copy, it calls\nthe clone method of a user provided element.\n\nThis issue can result in an element being double-freed if the clone call panics.\n\nCommit `20cb73d` fixed this issue by adding a `set_len(0)` call before\noperating on the vector to avoid dropping the elements during a panic.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "qwutils",
        "purl": "pkg:cargo/qwutils"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "qwutils::imp::vec::VecExt::insert_slice_clone"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/qwutils"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0018.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/qwertz19281/rust_utils/issues/3"
    }
  ]
},"148":{
  "id": "RUSTSEC-2020-0116",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-15T12:00:00Z",
  "aliases": [
    "CVE-2020-36436"
  ],
  "related": [],
  "summary": "PinSlab<T> and Unordered<T, S> need bounds on their Send/Sync traits",
  "details": "Affected versions of this crate unconditionally implemented `Send` & `Sync` for types `PinSlab<T>` & `Unordered<T, S>`. This allows sending non-Send types to other threads and concurrently accessing non-Sync types from multiple threads.\n\nThis can result in a data race & memory corruption when types that provide internal mutability without synchronization are contained within `PinSlab<T>` or `Unordered<T, S>` and accessed concurrently from multiple threads.\n\nThe flaw was corrected in commits 92f40b4 & 6a6c367 by adding trait bound `T: Send` to `Send` impls for `PinSlab<T>` & `Unordered<T, S>` and adding `T: Sync` to `Sync` impls for `PinSlab<T>` & `Unordered<T, S>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "unicycle",
        "purl": "pkg:cargo/unicycle"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/unicycle"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0116.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/udoprog/unicycle/issues/8"
    }
  ]
},"149":{
  "id": "RUSTSEC-2020-0053",
  "modified": "2021-06-29T22:08:30Z",
  "published": "2020-10-16T12:00:00Z",
  "withdrawn": "2021-04-19T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "dirs is unmaintained, use dirs-next instead",
  "details": "The `dirs` crate is not maintained any more;\nuse [`dirs-next`](https://crates.io/crates/dirs-next) instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "dirs",
        "purl": "pkg:cargo/dirs"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/dirs"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0053.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/dirs-dev/dirs-rs"
    }
  ]
},"150":{
  "id": "RUSTSEC-2020-0141",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36461"
  ],
  "related": [],
  "summary": "MvccRwLock allows data races & aliasing violations",
  "details": "Affected versions of this crate unconditionally implement Send/Sync for `MvccRwLock`.\nThis can lead to data races when types that are either `!Send` or `!Sync` (e.g. `Rc<T>`, `Arc<Cell<_>>`) are contained inside `MvccRwLock` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).\n\nAlso, safe APIs of `MvccRwLock` allow aliasing violations by allowing `&T` and `LockResult<MutexGuard<Box<T>>>` to co-exist in conflicting lifetime regions. The APIs of `MvccRwLock` should either be marked as `unsafe` or `MbccRwLock` should be changed to private or pub(crate).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "noise_search",
        "purl": "pkg:cargo/noise_search"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/noise_search"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0141.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/pipedown/noise/issues/72"
    }
  ]
},"151":{
  "id": "RUSTSEC-2020-0004",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-24T12:00:00Z",
  "aliases": [
    "CVE-2020-35859"
  ],
  "related": [],
  "summary": "sigstack allocation bug can cause memory corruption or leak",
  "details": "An embedding using affected versions of lucet-runtime configured to use\nnon-default Wasm globals sizes of more than 4KiB, or compiled in debug mode\nwithout optimizations, could leak data from the signal handler stack to guest\nprograms. This can potentially cause data from the embedding host to leak to\nguest programs or cause corruption of guest program memory.\n\nThis flaw was resolved by correcting the sigstack allocation logic.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lucet-runtime-internals",
        "purl": "pkg:cargo/lucet-runtime-internals"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.3"
            },
            {
              ">=": "0.5.0","<": "0.5.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lucet-runtime-internals"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0004.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/bytecodealliance/lucet/pull/401"
    }
  ]
},"152":{
  "id": "RUSTSEC-2021-0059",
  "modified": "2021-05-04T01:28:43Z",
  "published": "2021-04-29T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`aesni` has been merged into the `aes` crate",
  "details": "Please use the `aes` crate going forward. The new repository location is at:\n\n<https://github.com/RustCrypto/block-ciphers/tree/master/aes>\n\nAES-NI is now autodetected at runtime on `i686`/`x86-64` platforms.\nIf AES-NI is not present, the `aes` crate will fallback to a constant-time\nportable software implementation.\n\nTo prevent this fallback (and have absence of AES-NI result in an illegal\ninstruction crash instead), continue to pass the same RUSTFLAGS which were\npreviously required for the `aesni` crate to compile:\n\n```\nRUSTFLAGS=-Ctarget-feature=+aes,+ssse3\n```",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "aesni",
        "purl": "pkg:cargo/aesni"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/aesni"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0059.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/block-ciphers/pull/200"
    }
  ]
},"153":{
  "id": "RUSTSEC-2020-0157",
  "modified": "2021-09-10T15:50:27Z",
  "published": "2020-06-02T12:00:00Z",
  "aliases": [
    "CVE-2020-13759",
    "GHSA-mm4m-qg48-f7wc"
  ],
  "related": [],
  "summary": "Improper Synchronization and Race Condition in vm-memory",
  "details": "rust-vmm vm-memory before 0.1.1 and 0.2.x before 0.2.1 allows attackers to cause a denial of service (loss of IP networking) because read_obj and write_obj do not properly access memory. This affects aarch64 (with musl or glibc) and x86_64 (with musl).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "vm-memory",
        "purl": "pkg:cargo/vm-memory"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.1"
            },
            {
              ">=": "0.2.0-0","<": "0.2.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/vm-memory"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0157.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2020-13759"
    }
  ]
},"154":{
  "id": "RUSTSEC-2020-0012",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-04-24T12:00:00Z",
  "aliases": [
    "CVE-2020-35865"
  ],
  "related": [],
  "summary": "Relies on undefined behavior of `char::from_u32_unchecked`",
  "details": "The Windows implementation of this crate relied on the behavior of\n`std::char::from_u32_unchecked` when its safety clause is violated.\nEven though this worked with Rust versions up to 1.42 (at least),\nthat behavior could change with any new Rust version, possibly leading\na security issue.\n\nThe flaw was corrected in version 2.0.0.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "os_str_bytes",
        "purl": "pkg:cargo/os_str_bytes"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/os_str_bytes"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0012.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/dylni/os_str_bytes/pull/1"
    }
  ]
},"155":{
  "id": "RUSTSEC-2020-0100",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-31T12:00:00Z",
  "aliases": [
    "CVE-2020-36434"
  ],
  "related": [],
  "summary": "Double free when calling `sys_info::disk_info` from multiple threads",
  "details": "Affected versions of `sys-info` use a static, global, list to store temporary disk information while running. The function that cleans up this list,\n`DFCleanup`, assumes a single threaded environment and will try to free the same memory twice in a multithreaded environment.\n\nThis results in consistent double-frees and segfaults when calling `sys_info::disk_info` from multiple threads at once.\n\nThe issue was fixed by moving the global variable into a local scope.\n\n## Safer Alternatives:\n - [`sysinfo`](https://crates.io/crates/sysinfo)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "sys-info",
        "purl": "pkg:cargo/sys-info"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "linux"
          ],
          "functions": [
            "sys_info::disk_info"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.8.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/sys-info"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0100.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/FillZpp/sys-info-rs/issues/63"
    }
  ]
},"156":{
  "id": "RUSTSEC-2020-0045",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-08T12:00:00Z",
  "aliases": [
    "CVE-2020-35898"
  ],
  "related": [],
  "summary": "bespoke Cell implementation allows obtaining several mutable references to the same data",
  "details": "The custom implementation of a Cell primitive in the affected versions of this crate\ndoes not keep track of mutable references to the underlying data.\n\nThis allows obtaining several mutable references to the same object\nwhich may result in arbitrary memory corruption, most likely use-after-free.\n\nThe flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "actix-utils",
        "purl": "pkg:cargo/actix-utils"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/actix-utils"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0045.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/actix/actix-net/issues/160"
    }
  ]
},"157":{
  "id": "RUSTSEC-2019-0038",
  "modified": "2020-10-25T19:19:23Z",
  "published": "2019-03-10T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Fix for UB in failure to catch panics crossing FFI boundaries",
  "details": "Affected versions of this crate failed to catch panics crossing FFI boundaries via callbacks, which\nis a form of UB. This flaw was corrected by [this commit][1] which was included in version 2.6.0.\n\n[1]: https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libpulse-binding",
        "purl": "pkg:cargo/libpulse-binding"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.6.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libpulse-binding"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0038.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494"
    }
  ]
},"158":{
  "id": "RUSTSEC-2021-0130",
  "modified": "2021-12-21T15:50:24Z",
  "published": "2021-12-21T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Use after free in lru crate",
  "details": "Lru crate has use after free vulnerability.\n\nLru crate has two functions for getting an iterator. Both iterators give\nreferences to key and value. Calling specific functions, like pop(), will remove\nand free the value, and but it's still possible to access the reference of value\nwhich is already dropped causing use after free.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lru",
        "purl": "pkg:cargo/lru"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "lru::LruCache::iter",
            "lru::LruCache::iter_mut"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lru"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0130.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/jeromefroe/lru-rs/issues/120"
    }
  ]
},"159":{
  "id": "RUSTSEC-2018-0008",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-12-05T12:00:00Z",
  "aliases": [
    "CVE-2018-20995"
  ],
  "related": [],
  "summary": "Bug in SliceDeque::move_head_unchecked allows read of corrupted memory",
  "details": "Affected versions of this crate did not properly update the\nhead and tail of the deque when inserting and removing elements from the front\nif, before insertion or removal, the tail of the deque was in the mirrored\nmemory region, and if, after insertion or removal, the head of the deque is\nexactly at the beginning of the mirrored memory region.\n\nAn attacker that controls both element insertion and removal into the deque\ncould put it in a corrupted state. Once the deque enters such an state, its head\nand tail are corrupted, but in bounds of the allocated memory. This can result\nin partial reads and writes, reads of uninitialized memory, reads of memory\ncontaining previously dropped objects, etc. An attacker could exploit this to\nalter program execution.\n\nThe flaw was corrected by properly updating the head and tail of the deque in\nthis case.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "slice-deque",
        "purl": "pkg:cargo/slice-deque"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.16"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/slice-deque"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0008.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gnzlbg/slice_deque/issues/57"
    }
  ]
},"160":{
  "id": "RUSTSEC-2021-0075",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-07-08T12:00:00Z",
  "aliases": [
    "CVE-2021-38194"
  ],
  "related": [],
  "summary": "Flaw in `FieldVar::mul_by_inverse` allows unsound R1CS constraint systems",
  "details": "Versions `0.2.0` to `0.3.0` of ark-r1cs-std did not enforce any constraints in the `FieldVar::mul_by_inverse` method, allowing a malicious prover to produce an unsound proof that passes all verifier checks.\nThis method was used primarily in scalar multiplication for [`short_weierstrass::ProjectiveVar`](https://docs.rs/ark-r1cs-std/0.3.0/ark_r1cs_std/groups/curves/short_weierstrass/struct.ProjectiveVar.html).\n\nThis bug was fixed in commit `47ddbaa`, and was released as part of version `0.3.1` on `crates.io`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ark-r1cs-std",
        "purl": "pkg:cargo/ark-r1cs-std"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "ark_r1cs_std::FieldVar::mul_by_inverse"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ark-r1cs-std"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0075.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/arkworks-rs/r1cs-std/pull/70"
    }
  ]
},"161":{
  "id": "RUSTSEC-2016-0006",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2016-12-15T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`cassandra` crate is unmaintained; use `cassandra-cpp` instead",
  "details": "The `cassandra` crate has not seen a release since December 2016, and its author\nis unresponsive.\n\nThe `cassandra-cpp` crate is a maintained fork:\n\nhttps://github.com/Metaswitch/cassandra-rs",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cassandra",
        "purl": "pkg:cargo/cassandra"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.8.2-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cassandra"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2016-0006.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tupshin/cassandra-rs/issues/52"
    }
  ]
},"162":{
  "id": "RUSTSEC-2021-0022",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-09T12:00:00Z",
  "aliases": [
    "CVE-2021-27377"
  ],
  "related": [],
  "summary": "Use-after-free in `subscript_next` and `subscript_prev` wrappers",
  "details": "Affected versions of this crate had an unsound implementation which could pass\na pointer to freed memory to `ydb_subscript_next_st` and\n`ydb_subscript_prev_st` if the variable and subscripts did not have enough\nmemory allocated on the first call to hold the next variable in the database.\n\nFor example, the following code had undefined behavior:\n\n```rust\nlet mut key = Key::variable(String::from(\"a\"));\nKey::variable(\"averylongkeywithlotsofletters\")\n    .set_st(YDB_NOTTP, Vec::new(), b\"some val\")\n    .unwrap();\nkey.sub_next_self_st(YDB_NOTTP, Vec::new()).unwrap();\n```\n\n`yottadb` has no reverse-dependencies on crates.io and there are no known\ninstances of this API being used incorrectly in practice. The fix is backwards\ncompatible.\n\nThe flaw was corrected by recalculating the pointer each time it was reallocated.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "yottadb",
        "purl": "pkg:cargo/yottadb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "yottadb::Key::sub_next_self_st",
            "yottadb::Key::sub_prev_self_st",
            "yottadb::KeyContext::sub_next_self_st",
            "yottadb::KeyContext::sub_prev_self_st"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.2.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/yottadb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0022.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/40"
    }
  ]
},"163":{
  "id": "RUSTSEC-2019-0014",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-08-21T12:00:00Z",
  "aliases": [
    "CVE-2019-16138"
  ],
  "related": [],
  "summary": "Flaw in interface may drop uninitialized instance of arbitrary types",
  "details": "Affected versions of this crate would call `Vec::set_len` on an uninitialized\nvector with user-provided type parameter, in an interface of the HDR image\nformat decoder. They would then also call other code that could panic before\ninitializing all instances.\n\nThis could run Drop implementations on uninitialized types, equivalent to\nuse-after-free, and allow an attacker arbitrary code execution.\n\nTwo different fixes were applied. It is possible to conserve the interface by\nensuring proper initialization before calling `Vec::set_len`. Drop is no longer\ncalled in case of panic, though.\n\nStarting from version `0.22`, a breaking change to the interface requires\ncallers to pre-allocate the output buffer and pass a mutable slice instead,\navoiding all unsafe code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "image",
        "purl": "pkg:cargo/image"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "image::hdr::HDRDecoder::read_image_transform"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.10.2","<": "0.21.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/image"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0014.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/image-rs/image/pull/985"
    }
  ]
},"164":{
  "id": "RUSTSEC-2020-0069",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-11T12:00:00Z",
  "aliases": [
    "CVE-2020-28247"
  ],
  "related": [],
  "summary": "Argument injection in sendmail transport",
  "details": "Affected versions of lettre allowed argument injection\nto the sendmail command. It was possible, using forged `to` addresses,\nto pass arbitrary arguments to the sendmail executable.\n\nDepending on the implementation (original sendmail, postfix, exim, etc.)\nit could be possible in some cases to write email data into arbitrary files (using sendmail's\nlogging features).\n \nThe flaw is corrected by modifying the executed command to stop parsing arguments\nbefore passing the destination addresses.\n\nNOTE: This vulnerability only affects the `sendmail` transport. Others, including `smtp`, are not\naffected.\n\nThis vulnerability was reported by vin01.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lettre",
        "purl": "pkg:cargo/lettre"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "lettre::sendmail::SendmailTransport::send",
            "lettre::transport::sendmail::SendmailTransport::send",
            "lettre::transport::sendmail::SendmailTransport::send_raw"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "file-disclosure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.7.0","<": "0.7.1"
            },
            {
              ">=": "0.8.0","<": "0.8.4"
            },
            {
              ">=": "0.9.0","<": "0.9.5"
            },
            {
              ">=": "0.10.0-alpha.1","<": "0.10.0-alpha.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lettre"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0069.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b"
    }
  ]
},"165":{
  "id": "RUSTSEC-2020-0086",
  "modified": "2020-12-07T17:22:02Z",
  "published": "2020-12-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_client`",
  "details": "This crate has been renamed from `safe_core` to `sn_client`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_client>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe_core",
        "purl": "pkg:cargo/safe_core"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe_core"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0086.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_client/pull/1267"
    }
  ]
},"166":{
  "id": "RUSTSEC-2021-0034",
  "modified": "2021-03-03T18:06:07Z",
  "published": "2021-02-04T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "office is unmaintained, use calamine instead",
  "details": "The `office` crate is unmaintained. Use [calamine](https://crates.io/crates/calamine)\nfor reading excel files.\n\nContact the `office` author for ownership of the package name.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "office",
        "purl": "pkg:cargo/office"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/office"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0034.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/742#issuecomment-773313783"
    }
  ]
},"167":{
  "id": "RUSTSEC-2019-0002",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-05-07T12:00:00Z",
  "aliases": [
    "CVE-2019-15543"
  ],
  "related": [
    "RUSTSEC-2018-0008"
  ],
  "summary": "Bug in SliceDeque::move_head_unchecked corrupts its memory",
  "details": "Affected versions of this crate entered a corrupted state if\n`mem::size_of::<T>() % allocation_granularity() != 0` and a specific allocation\npattern was used: sufficiently shifting the deque elements over the mirrored\npage boundary.\n\nThis allows an attacker that controls controls both element insertion and\nremoval to corrupt the deque, such that reading elements from it would read\nbytes corresponding to other elements in the deque. (e.g. a read of T could read\nsome bytes from one value and some bytes from an adjacent one, resulting in a T\nwhose value representation is not meaningful). This is undefined behavior.\n \nThe flaw was corrected by using a pair of pointers to track the head and tail of\nthe deque instead of a pair of indices. This pair of pointers are represented\nusing a Rust slice.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "slice-deque",
        "purl": "pkg:cargo/slice-deque"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/slice-deque"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0002.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gnzlbg/slice_deque/issues/57"
    }
  ]
},"168":{
  "id": "RUSTSEC-2020-0090",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-08T12:00:00Z",
  "aliases": [
    "CVE-2020-35927"
  ],
  "related": [],
  "summary": "Thex<T> allows data races of non-Send types across threads",
  "details": "`thex::Thex<T>` implements `Sync` for all types `T`. However, it is missing a\nbound for `T: Send`.\n\nThis allows non-Send types such as `Rc` to be sent across thread boundaries\nwhich can trigger undefined behavior and memory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "thex",
        "purl": "pkg:cargo/thex"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/thex"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0090.html"
    }
  ]
},"169":{
  "id": "RUSTSEC-2021-0126",
  "modified": "2021-11-29T18:32:40Z",
  "published": "2021-11-29T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "RustEmbed generated `get` method allows for directory traversal when reading files from disk",
  "details": "When running in debug mode and the `debug-embed` (off by default) feature is\nnot enabled, the generated `get` method does not check that the input path is\na child of the folder given. \n\nThis allows attackers to read arbitrary files in the file system if they have\ncontrol over the filename given. The following code will print the contents of\nyour `/etc/passwd` if adjusted with a correct number of `../`s depending on\nwhere it is run from.\n\n```rust\n#[derive(rust_embed::RustEmbed)]\n#[folder = \"src/\"]\npub struct Asset;\n\nfn main() {\n    let d = Asset::get(\"../../../etc/passwd\").unwrap().data;\n    println!(\"{}\", String::from_utf8_lossy(&d));\n}\n```\n\nThe flaw was corrected by canonicalizing the input filename and ensuring that\nit starts with the canonicalized folder path.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rust-embed",
        "purl": "pkg:cargo/rust-embed"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "file-disclosure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "6.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rust-embed"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0126.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/pyros2097/rust-embed/issues/159"
    }
  ]
},"170":{
  "id": "RUSTSEC-2021-0063",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-05-04T12:00:00Z",
  "aliases": [
    "CVE-2021-38186"
  ],
  "related": [],
  "summary": "XSS in `comrak`",
  "details": "[comrak](https://github.com/kivikakk/comrak) operates by default in a \"safe\"\nmode of operation where unsafe content, such as arbitrary raw HTML or URLs with\nnon-standard schemes, are not permitted in the output.  This is per the\nreference GFM implementation, [cmark-gfm](https://github.com/github/cmark).\n\nAmpersands were not being correctly escaped in link targets, making it possible\nto fashion unsafe URLs using schemes like `data:` or `javascript:` by entering\nthem as HTML entities, e.g. `&#x64&#x61&#x74&#x61&#x3a`.  The intended\nbehaviour, demonstrated upstream, is that these should be escaped and therefore\nharmless, but this behaviour was broken in comrak.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "comrak",
        "purl": "pkg:cargo/comrak"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.10.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/comrak"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0063.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/kivikakk/comrak/releases/tag/0.10.1"
    }
  ]
},"171":{
  "id": "RUSTSEC-2020-0028",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-27T12:00:00Z",
  "aliases": [
    "CVE-2020-35882"
  ],
  "related": [],
  "summary": "`LocalRequest::clone` creates multiple mutable references to the same object",
  "details": "The affected version of `rocket` contains a `Clone` trait implementation of\n`LocalRequest` that reuses the pointer to inner `Request` object.\nThis causes data race in rare combinations of APIs if the original and the\ncloned objects are modified at the same time.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rocket",
        "purl": "pkg:cargo/rocket"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rocket::local::LocalRequest::clone"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.4.0","<": "0.4.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rocket"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0028.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/SergioBenitez/Rocket/issues/1312"
    }
  ]
},"172":{
  "id": "RUSTSEC-2019-0022",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-09-14T12:00:00Z",
  "aliases": [
    "CVE-2019-16881"
  ],
  "related": [],
  "summary": "Stream callback function is not unwind safe",
  "details": "Affected versions of this crate is not panic safe within callback functions `stream_callback` and `stream_finished_callback`.\n\nThe call to user-provided closure might panic before a `mem::forget` call, which then causes a use after free that grants attacker to control the callback function pointer.\n\nThis allows an attacker to construct an arbitrary code execution .\n \nThe flaw was reported by Phosphorus15.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "portaudio-rs",
        "purl": "pkg:cargo/portaudio-rs"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.2-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/portaudio-rs"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0022.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/mvdnes/portaudio-rs/issues/20"
    }
  ]
},"173":{
  "id": "RUSTSEC-2021-0014",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-26T12:00:00Z",
  "aliases": [
    "CVE-2021-26308"
  ],
  "related": [],
  "summary": "Record::read : Custom `Read` on uninitialized buffer may cause UB",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. (`Record::read()`)\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThis flaw was fixed in commit 6299af0 by zero-initializing the newly allocated memory (via `data.resize(len, 0)`) instead of exposing uninitialized memory (`unsafe { data.set_len(len) }`).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "marc",
        "purl": "pkg:cargo/marc"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/marc"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0014.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/blackbeam/rust-marc/issues/7"
    }
  ]
},"174":{
  "id": "RUSTSEC-2020-0008",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-03-19T12:00:00Z",
  "aliases": [
    "CVE-2020-35863"
  ],
  "related": [],
  "summary": "Flaw in hyper allows request smuggling by sending a body in GET requests",
  "details": "Vulnerable versions of hyper allow GET requests to have bodies, even if there is\nno Transfer-Encoding or Content-Length header.  As per the HTTP 1.1\nspecification, such requests do not have bodies, so the body will be interpreted\nas a separate HTTP request.\n\nThis allows an attacker who can control the body and method of an HTTP request\nmade by hyper to inject a request with headers that would not otherwise be\nallowed, as demonstrated by sending a malformed HTTP request from a Substrate\nruntime.  This allows bypassing CORS restrictions.  In combination with other\nvulnerabilities, such as an exploitable web server listening on loopback, it may\nallow remote code execution.\n\nThe flaw was corrected in hyper version 0.12.34.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hyper",
        "purl": "pkg:cargo/hyper"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.11.0","<": "0.12.34"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hyper"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0008.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/hyperium/hyper/issues/1925"
    }
  ]
},"175":{
  "id": "RUSTSEC-2021-0043",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-17T12:00:00Z",
  "aliases": [
    "CVE-2021-29934"
  ],
  "related": [],
  "summary": "PartialReader passes uninitialized memory to user-provided Read",
  "details": "Affected versions of this crate passed an uniniitalized buffer to a\nuser-provided `Read` instance in `PartialReader::read`.\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.\n\nThe flaw was fixed in commit [`39d62c6`](https://github.com/uutils/coreutils/commit/39d62c6c1f809022c903180471c10fde6ecd12d1)\nby zero-initializing the passed buffer.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "uu_od",
        "purl": "pkg:cargo/uu_od"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.0.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/uu_od"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0043.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/uutils/coreutils/issues/1729"
    }
  ]
},"176":{
  "id": "RUSTSEC-2021-0106",
  "modified": "2021-09-10T16:11:09Z",
  "published": "2021-07-15T12:00:00Z",
  "aliases": [
    "CVE-2021-36753",
    "GHSA-p24j-h477-76q3"
  ],
  "related": [],
  "summary": "Uncontrolled Search Path Element in sharkdp/bat",
  "details": "bat on windows before 0.18.2 executes programs named less.exe from the current working directory. This can lead to unintended code execution.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bat",
        "purl": "pkg:cargo/bat"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "code-execution"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.18.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bat"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0106.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-36753"
    }
  ]
},"177":{
  "id": "RUSTSEC-2021-0055",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-05-01T12:00:00Z",
  "aliases": [
    "CVE-2021-3449"
  ],
  "related": [],
  "summary": "NULL pointer deref in signature_algorithms processing",
  "details": "An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation\nClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits\nthe signature_algorithms extension (where it was present in the initial\nClientHello), but includes a signature_algorithms_cert extension then a NULL\npointer dereference will result, leading to a crash and a denial of service\nattack.\n\nA server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which\nis the default configuration). OpenSSL TLS clients are not impacted by this\nissue.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "111.15.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0055.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20210325.txt"
    }
  ]
},"178":{
  "id": "RUSTSEC-2021-0110",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-09-17T12:00:00Z",
  "aliases": [
    "CVE-2021-39216",
    "CVE-2021-39219",
    "CVE-2021-39218"
  ],
  "related": [],
  "summary": "Multiple Vulnerabilities in Wasmtime",
  "details": "* [Use after free passing `externref`s to Wasm in\n  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf)\n\n* [Out-of-bounds read/write and invalid free with `externref`s and GC safepoints\n  in\n  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49)\n\n* [Wrong type for `Linker`-define functions when used across two\n  `Engine`s](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "wasmtime",
        "purl": "pkg:cargo/wasmtime"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "wasmtime::Linker::func_new",
            "wasmtime::Linker::func_wrap",
            "wasmtime::Store::gc"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.30.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/wasmtime"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0110.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx"
    }
  ]
},"179":{
  "id": "RUSTSEC-2019-0034",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-11-16T12:00:00Z",
  "aliases": [
    "CVE-2019-25009"
  ],
  "related": [],
  "summary": "HeaderMap::Drain API is unsound",
  "details": "Affected versions of this crate incorrectly used raw pointer,\nwhich introduced unsoundness in its public safe API.\n\n[Failing to drop the Drain struct causes double-free](https://github.com/hyperium/http/issues/354),\nand [it is possible to violate Rust's alias rule and cause data race with Drain's Iterator implementation](https://github.com/hyperium/http/issues/355).\n\nThe flaw was corrected in 0.1.20 release of `http` crate.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "http",
        "purl": "pkg:cargo/http"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "http::header::HeaderMap::drain"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.20"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/http"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0034.html"
    }
  ]
},"180":{
  "id": "RUSTSEC-2020-0049",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-30T12:00:00Z",
  "aliases": [
    "CVE-2020-35902"
  ],
  "related": [],
  "summary": "Use-after-free in Framed due to lack of pinning",
  "details": "Affected versions of this crate did not require the buffer wrapped in `Framed` to be pinned,\nbut treated it as if it had a fixed location in memory. This may result in a use-after-free.\n \nThe flaw was corrected by making the affected functions accept `Pin<&mut Self>` instead of `&mut self`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "actix-codec",
        "purl": "pkg:cargo/actix-codec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0-beta.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/actix-codec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0049.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/actix/actix-net/issues/91"
    }
  ]
},"181":{
  "id": "RUSTSEC-2021-0002",
  "modified": "2021-01-06T16:07:19Z",
  "published": "2021-01-04T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "interfaces2 is unmaintained, use interfaces instead",
  "details": "The `interfaces2` crate is not maintained any more;\nuse [`interfaces`](https://crates.io/crates/interfaces) instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "interfaces2",
        "purl": "pkg:cargo/interfaces2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/interfaces2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0002.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/aep/interfaces-rs"
    }
  ]
},"182":{
  "id": "RUSTSEC-2020-0032",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-08-20T12:00:00Z",
  "aliases": [
    "CVE-2020-35885"
  ],
  "related": [],
  "summary": "StrcCtx deallocates a memory region that it doesn't own",
  "details": "`StrcCtx` deallocate a memory region that it doesn't own when `StrcCtx` is created without using `StrcCtx::new`.\nThis can introduce memory safety issues such as double-free and use-after-free to client programs.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "alpm-rs",
        "purl": "pkg:cargo/alpm-rs"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/alpm-rs"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0032.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/pigeonhands/rust-arch/issues/2"
    }
  ]
},"183":{
  "id": "RUSTSEC-2021-0096",
  "modified": "2021-08-23T14:34:15Z",
  "published": "2021-08-16T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "spirv_headers is unmaintained, use spirv instead",
  "details": "Because of versioning issues; the `spirv_headers` crate is unmaintained. Use [spirv](https://crates.io/crates/spirv)\nfor parsing spirv files.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "spirv_headers",
        "purl": "pkg:cargo/spirv_headers"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/spirv_headers"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0096.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gfx-rs/rspirv/issues/197"
    }
  ]
},"184":{
  "id": "RUSTSEC-2021-0079",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-07-07T12:00:00Z",
  "aliases": [
    "CVE-2021-32714",
    "GHSA-5h46-h7hh-c6x9"
  ],
  "related": [],
  "summary": "Integer overflow in `hyper`'s parsing of the `Transfer-Encoding` header leads to data loss",
  "details": "When decoding chunk sizes that are too large, `hyper`'s code would encounter an integer overflow. Depending on the situation,\nthis could lead to data loss from an incorrect total size, or in rarer cases, a request smuggling attack.\n\nTo be vulnerable, you must be using `hyper` for any HTTP/1 purpose, including as a client or server, and consumers must send\nrequests or responses that specify a chunk size greater than 18 exabytes. For a possible request smuggling attack to be possible,\nany upstream proxies must accept a chunk size greater than 64 bits.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hyper",
        "purl": "pkg:cargo/hyper"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.14.10"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hyper"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0079.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/hyperium/hyper/security/advisories/GHSA-5h46-h7hh-c6x9"
    }
  ]
},"185":{
  "id": "RUSTSEC-2018-0004",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-08-25T12:00:00Z",
  "aliases": [
    "CVE-2018-20992"
  ],
  "related": [],
  "summary": "Malicious input could cause uninitialized memory to be exposed",
  "details": "Affected versions of Claxon made an invalid assumption about the decode buffer\nsize being a multiple of a value read from the bitstream. This could cause parts\nof the decode buffer to not be overwritten. If the decode buffer was newly\nallocated and uninitialized, this uninitialized memory could be exposed.\n\nThis allows an attacker to observe parts of the uninitialized memory in the\ndecoded audio stream.\n\nThe flaw was corrected by checking that the value read from the bitstream divides\nthe decode buffer size, and returning a format error if it does not. If an error\nis returned, the decode buffer is not exposed. Regression tests and an\nadditional fuzzer have been added to prevent similar flaws in the future.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "claxon",
        "purl": "pkg:cargo/claxon"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.2"
            },
            {
              ">=": "0.4.0-0","<": "0.4.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/claxon"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0004.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/ruuda/claxon/commit/8f28ec275e412dd3af4f3cda460605512faf332c"
    }
  ]
},"186":{
  "id": "RUSTSEC-2020-0065",
  "modified": "2020-11-02T14:46:33Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_fake_clock`",
  "details": "This crate has been renamed from `fake_clock` to `sn_fake_clock`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_fake_clock>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "fake_clock",
        "purl": "pkg:cargo/fake_clock"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/fake_clock"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0065.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_fake_clock/pull/38"
    }
  ]
},"187":{
  "id": "RUSTSEC-2019-0018",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-09-02T12:00:00Z",
  "aliases": [
    "CVE-2019-16142"
  ],
  "related": [],
  "summary": "Internally mutating methods take immutable ref self",
  "details": "Affected versions of this crate exposed several methods which took `self` by\nimmutable reference, despite the requesting the RenderDoc API to set a mutable\nvalue internally.\n\nThis is technically unsound and calling these methods from multiple threads\nwithout synchronization could lead to unexpected and unpredictable behavior.\n\nThe flaw was corrected in release 0.5.0.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "renderdoc",
        "purl": "pkg:cargo/renderdoc"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "renderdoc::api::RenderDocV110::trigger_multi_frame_capture",
            "renderdoc::api::RenderDocV120::set_capture_file_comments"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/renderdoc"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0018.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/ebkalderon/renderdoc-rs/pull/32"
    }
  ]
},"188":{
  "id": "RUSTSEC-2020-0120",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36440"
  ],
  "related": [],
  "summary": "`Decoder<R>` can carry `R: !Send` to other threads",
  "details": "Affected versions of this crate implements `Send` for `Decoder<R>` for any `R: Read`. This allows `Decoder<R>` to contain `R: !Send` and carry (move) it to another thread.\n\nThis can result in undefined behavior such as memory corruption from data race on `R`, or dropping `R = MutexGuard<_>` from a thread that didn't lock the mutex.\n\nThe flaw was corrected in commit a34d6e1 by adding trait bound `R: Send` to the `Send` impl for `Decoder<R>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libsbc",
        "purl": "pkg:cargo/libsbc"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libsbc"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0120.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/mvertescher/libsbc-rs/issues/4"
    }
  ]
},"189":{
  "id": "RUSTSEC-2020-0073",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-12T12:00:00Z",
  "aliases": [
    "CVE-2020-35916"
  ],
  "related": [],
  "summary": "Mutable reference with immutable provenance",
  "details": "A mutable reference to a struct was constructed by dereferencing a pointer\nobtained from `slice::as_ptr`. Instead, `slice::as_mut_ptr` should have been\ncalled on the mutable slice argument. The former performs an implicit reborrow\nas an immutable shared reference which does not allow writing through the\nderived pointer.\n\nThere is no evidence for miscompilation, exploitable or otherwise, caused by\nthis bug. [Further investigation on Zulip][Zulip] suggests that the unoptimized\ngenerated LLVM IR does not contain any UB itself, effectively mitigating\nfurther effects.\n\n[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/146229-wg-secure-code/topic/Implications.20of.20using.20.60slice.3A.3Aas_ptr.60.20for.20mutable.20access/near/216499472",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "image",
        "purl": "pkg:cargo/image"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "image::Bgr::from_slice_mut",
            "image::Bgra::from_slice_mut",
            "image::Luma::from_slice_mut",
            "image::LumaA::from_slice_mut",
            "image::Rgb::from_slice_mut",
            "image::Rgba::from_slice_mut"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.23.12"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/image"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0073.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/image-rs/image/issues/1357"
    }
  ]
},"190":{
  "id": "RUSTSEC-2020-0136",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-15T12:00:00Z",
  "aliases": [
    "CVE-2020-36456"
  ],
  "related": [],
  "summary": "CopyCell lacks bounds on its Send trait allowing for data races",
  "details": "`CopyCell<T>` is a `Cell`-like type that is implemented for any type `T` that\nis `Copy`able. It's `Send` trait has no bounds on the contained type.\n\nAs not all `Copy`able types are thread safe, for example non-mutable references\nimplement the `Copy` trait, it is possible to send references to types with\ninterior mutability such as `Cell` across threads and cause data races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "toolshed",
        "purl": "pkg:cargo/toolshed"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/toolshed"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0136.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/ratel-rust/toolshed/issues/12"
    }
  ]
},"191":{
  "id": "RUSTSEC-2021-0038",
  "modified": "2021-03-19T21:21:58Z",
  "published": "2021-03-06T12:00:00Z",
  "aliases": [
    "CVE-2021-28306",
    "CVE-2021-28307",
    "CVE-2021-28308"
  ],
  "related": [],
  "summary": "Multiple memory safety issues",
  "details": "Affected versions contain multiple memory safety issues, such as:\n\n - Setting a multi label type where an image doesn't exist would lead to a NULL pointer dereference.\n - Setting a window icon using a non-raster image (which FLTK rasterizes lazily) would lead to a NULL dereference.\n - Pixmap constructor would not check for correct pixmaps which could lead to out-of bound reads.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "fltk",
        "purl": "pkg:cargo/fltk"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "fltk::image::Pixmap::new",
            "fltk::prelude::WidgetExt::set_label_type",
            "fltk::prelude::WindowExt::set_icon"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.15.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/fltk"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0038.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/MoAlyousef/fltk-rs/issues/519"
    }
  ]
},"192":{
  "id": "RUSTSEC-2020-0024",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-07-09T12:00:00Z",
  "aliases": [
    "CVE-2020-15093",
    "GHSA-5q2r-92f9-4m49"
  ],
  "related": [
    "CVE-2020-6174"
  ],
  "summary": "Improper uniqueness verification of signature threshold",
  "details": "The tough library, prior to 0.7.1, does not properly verify the uniqueness of\nkeys in the signatures provided to meet the threshold of cryptographic\nsignatures. It allows someone with access to a valid signing key to create\nmultiple valid signatures in order to circumvent TUF requiring a minimum\nthreshold of unique keys before the metadata is considered valid.\n\nAWS would like to thank Erick Tryzelaar of the Google Fuchsia Team for\nreporting this issue.\n\nA fix is available in version 0.7.1.\n\nCVE-2020-6174 is assigned to the same issue in the TUF reference\nimplementation.\n\nIf you have any questions or comments about this advisory, contact AWS Security\nat aws-security@amazon.com.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tough",
        "purl": "pkg:cargo/tough"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tough"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0024.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/awslabs/tough/security/advisories/GHSA-5q2r-92f9-4m49"
    }
  ]
},"193":{
  "id": "RUSTSEC-2020-0161",
  "modified": "2022-01-21T17:52:31Z",
  "published": "2020-05-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`array!` macro is unsound in presence of traits that implement methods it calls internally",
  "details": "Affected versions of this crate called some methods using auto-ref. The affected code looked like this.\n\n```rust\nlet mut arr = $crate::__core::mem::MaybeUninit::uninit();\nlet mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);\n```\n\nIn this case, the problem is that `as_mut_ptr` is a method of `&mut MaybeUninit`, not `MaybeUninit`. This made it possible for traits to hijack the method calls in order to cause unsoundness.\n\n```rust\ntrait AsMutPtr<T> {\n    fn as_mut_ptr(&self) -> *mut T;\n}\nimpl<T> AsMutPtr<T> for std::mem::MaybeUninit<T> {\n    fn as_mut_ptr(&self) -> *mut T {\n        std::ptr::null_mut()\n    }\n}\narray![0; 1];\n```\n\nThe flaw was corrected by explicitly referencing variables in macro body in order to avoid auto-ref.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "array-macro",
        "purl": "pkg:cargo/array-macro"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.2","<": "1.0.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/array-macro"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0161.html"
    },
    {
      "type": "WEB",
      "url": "https://gitlab.com/KonradBorowski/array-macro/-/commit/01940637dd8f3bfeeee3faf9639fa9ae52f19f4d"
    }
  ]
},"194":{
  "id": "RUSTSEC-2021-0080",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-07-19T12:00:00Z",
  "aliases": [
    "CVE-2021-38511"
  ],
  "related": [],
  "summary": "Links in archive can create arbitrary directories",
  "details": "When unpacking a tarball that contains a symlink the `tar` crate may create\ndirectories outside of the directory it's supposed to unpack into.\n\nThe function errors when it's trying to create a file, but the folders are\nalready created at this point.\n\n```rust\nuse std::{io, io::Result};\nuse tar::{Archive, Builder, EntryType, Header};\n\nfn main() -> Result<()> {\n    let mut buf = Vec::new();\n\n    {\n        let mut builder = Builder::new(&mut buf);\n\n        // symlink: parent -> ..\n        let mut header = Header::new_gnu();\n        header.set_path(\"symlink\")?;\n        header.set_link_name(\"..\")?;\n        header.set_entry_type(EntryType::Symlink);\n        header.set_size(0);\n        header.set_cksum();\n        builder.append(&header, io::empty())?;\n\n        // file: symlink/exploit/foo/bar\n        let mut header = Header::new_gnu();\n        header.set_path(\"symlink/exploit/foo/bar\")?;\n        header.set_size(0);\n        header.set_cksum();\n        builder.append(&header, io::empty())?;\n\n        builder.finish()?;\n    };\n\n    Archive::new(&*buf).unpack(\"demo\")\n}\n```\n\nThis has been fixed in https://github.com/alexcrichton/tar-rs/pull/259 and is\npublished as `tar` 0.4.36. Thanks to Martin Michaelis (@mgjm) for discovering\nand reporting this, and Nikhil Benesch (@benesch) for the fix!",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tar",
        "purl": "pkg:cargo/tar"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "tar::Archive::unpack"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.36"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tar"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0080.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/alexcrichton/tar-rs/issues/238"
    }
  ]
},"195":{
  "id": "RUSTSEC-2018-0012",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-12-20T12:00:00Z",
  "aliases": [
    "CVE-2018-20999"
  ],
  "related": [],
  "summary": "Flaw in streaming state reset() functions can create incorrect results.",
  "details": "Affected versions of this crate did not properly reset a streaming state.\n\nResetting a streaming state, without finalising it first, creates incorrect results.\n \nThe flaw was corrected by not first checking if the state had already been reset, when calling reset().",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "orion",
        "purl": "pkg:cargo/orion"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.11.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/orion"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0012.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/brycx/orion/issues/46"
    }
  ]
},"196":{
  "id": "RUSTSEC-2019-0021",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-09-14T12:00:00Z",
  "aliases": [
    "CVE-2019-16880"
  ],
  "related": [],
  "summary": "`Matrix::zip_elements` causes double free",
  "details": "Affected versions of this crate did not properly implements the `Matrix::zip_elements` method, which causes an double free when the given trait implementation might panic.\n\nThis allows an attacker to corrupt or take control of the memory.\n \nThe flaw was corrected by Phosphorus15.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "linea",
        "purl": "pkg:cargo/linea"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.5-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/linea"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0021.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/strake/linea.rs/issues/2"
    }
  ]
},"197":{
  "id": "RUSTSEC-2020-0119",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-17T12:00:00Z",
  "aliases": [
    "CVE-2020-36439"
  ],
  "related": [],
  "summary": "ReadTicket and WriteTicket should only be sendable when T is Send",
  "details": "Affected versions of this crate unconditionally implemented `Send` for `ReadTicket<T>` & `WriteTicket<T>`.\nThis allows to send non-Send `T` to other threads.\n\nThis can allows creating data races by cloning types with internal mutability and sending them to other threads (as `T` of `ReadTicket<T>`/`WriteTicket<T>`). Such data races can cause memory corruption or other undefined behavior.\n\nThe flaw was corrected in commit a986a93 by adding `T: Send` bounds to `Send` impls of `ReadTicket<T>`/`WriteTicket<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ticketed_lock",
        "purl": "pkg:cargo/ticketed_lock"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ticketed_lock"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0119.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/kvark/ticketed_lock/issues/7"
    }
  ]
},"198":{
  "id": "RUSTSEC-2021-0017",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-30T12:00:00Z",
  "aliases": [
    "CVE-2021-26953"
  ],
  "related": [],
  "summary": "`Read` on uninitialized buffer may cause UB (`impl Walue for Vec<u8>`)",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThis flaw was fixed in commit 8026286 by zero-initializing the buffer before handing to a user-provided `Read`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "postscript",
        "purl": "pkg:cargo/postscript"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.14.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/postscript"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0017.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bodoni/postscript/issues/1"
    }
  ]
},"199":{
  "id": "RUSTSEC-2021-0105",
  "modified": "2021-09-10T16:04:49Z",
  "published": "2021-07-12T12:00:00Z",
  "aliases": [
    "CVE-2021-36376",
    "GHSA-5xg3-j2j6-rcx4"
  ],
  "related": [],
  "summary": "Relative Path Traversal in git-delta",
  "details": "git-delta before 0.8.3 on Windows resolves an executable's pathname as a relative path from the current directory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "git-delta",
        "purl": "pkg:cargo/git-delta"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "file-disclosure"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.8.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/git-delta"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0105.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-36376"
    }
  ]
},"200":{
  "id": "RUSTSEC-2021-0040",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-12T12:00:00Z",
  "aliases": [
    "CVE-2021-29930",
    "CVE-2021-29931"
  ],
  "related": [],
  "summary": "panic safety: double drop or uninitialized drop of T upon panic",
  "details": "Affected versions of this crate did not guard against potential panics that may happen from user-provided functions `T::default()` and `T::drop()`.\n\nPanic within `T::default()` leads to dropping uninitialized `T`, when it is invoked from `common::Slice::<T, H>::new()`.\nPanic within `T::drop()` leads to double drop of `T`, when it is invoked either from `common::SliceVec::<T, H>::resize_with()` or `common::SliceVec::<T, H>::resize()`\n\nEither case causes memory corruption in the heap memory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arenavec",
        "purl": "pkg:cargo/arenavec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arenavec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0040.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/ibabushkin/arenavec/issues/1"
    }
  ]
},"201":{
  "id": "RUSTSEC-2020-0158",
  "modified": "2021-11-18T14:04:01Z",
  "published": "2020-02-10T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "slice-deque is unmaintained",
  "details": "The author of the `slice-deque` crate is unresponsive and is not receiving security patches.\n\nMaintained alternatives:\n\n- [`slice-ring-buffer`](https://crates.io/crates/slice-ring-buffer)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "slice-deque",
        "purl": "pkg:cargo/slice-deque"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/slice-deque"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0158.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gnzlbg/slice_deque/issues/94"
    }
  ]
},"202":{
  "id": "RUSTSEC-2021-0113",
  "modified": "2021-09-18T21:35:48Z",
  "published": "2021-04-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "AtomicBucket<T> unconditionally implements Send/Sync",
  "details": "In the affected versions of the crate, `AtomicBucket<T>` unconditionally implements `Send`/`Sync` traits. Therefore, users can create a data race to the inner\n`T: !Sync` by using the `AtomicBucket::data_with()` API.\nSuch data races can potentially cause memory corruption or other undefined behavior.\n\nThe flaw was fixed in commit 8e6daab by adding appropriate Send/Sync bounds to the Send/Sync impl of struct `Block<T>` (which is a data type contained inside `AtomicBucket<T>`).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "metrics-util",
        "purl": "pkg:cargo/metrics-util"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/metrics-util"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0113.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/metrics-rs/metrics/issues/190"
    }
  ]
},"203":{
  "id": "RUSTSEC-2022-0003",
  "modified": "2022-01-19T22:35:01Z",
  "published": "2022-01-19T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Space bug in `clean_text`",
  "details": "An incorrect mapping from HTML specification to ASCII codes was used.\nBecause HTML treats the Form Feed as whitespace, code like this has an injection bug:\n\n    let html = format!(\"<div title={}>\", clean_text(user_supplied_string));\n\nApplications are not affected if they quote their attributes, or if they don't use `clean_text` at all.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ammonia",
        "purl": "pkg:cargo/ammonia"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "ammonia::clean_text"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "3.0.0","<": "3.1.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ammonia"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0003.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-ammonia/ammonia/pull/147"
    }
  ]
},"204":{
  "id": "RUSTSEC-2021-0056",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-05-01T12:00:00Z",
  "aliases": [
    "CVE-2021-3450"
  ],
  "related": [],
  "summary": "CA certificate check bypass with X509_V_FLAG_X509_STRICT",
  "details": "The X509_V_FLAG_X509_STRICT flag enables additional security checks of the\ncertificates present in a certificate chain. It is not set by default.\n\nStarting from OpenSSL version 1.1.1h a check to disallow certificates in\nthe chain that have explicitly encoded elliptic curve parameters was added\nas an additional strict check.\n\nAn error in the implementation of this check meant that the result of a\nprevious check to confirm that certificates in the chain are valid CA\ncertificates was overwritten. This effectively bypasses the check\nthat non-CA certificates must not be able to issue other certificates.\n\nIf a \"purpose\" has been configured then there is a subsequent opportunity\nfor checks that the certificate is a valid CA.  All of the named \"purpose\"\nvalues implemented in libcrypto perform this check.  Therefore, where\na purpose is set the certificate chain will still be rejected even when the\nstrict flag has been used. A purpose is set by default in libssl client and\nserver certificate verification routines, but it can be overridden or\nremoved by an application.\n\nIn order to be affected, an application must explicitly set the\nX509_V_FLAG_X509_STRICT verification flag and either not set a purpose\nfor the certificate verification or, in the case of TLS client or server\napplications, override the default purpose.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "111.11.0","<": "111.15.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0056.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20210325.txt"
    }
  ]
},"205":{
  "id": "RUSTSEC-2019-0037",
  "modified": "2020-11-28T02:51:11Z",
  "published": "2019-06-11T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Compiler optimisation for next_with_timeout in pnet::transport::IcmpTransportChannelIterator flaws to SEGFAULT",
  "details": "Affected versions of this crate were optimized out by compiler,\nwhich caused dereference of uninitialized file descriptor which caused segfault.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "pnet",
        "purl": "pkg:cargo/pnet"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "pnet::transport::IcmpTransportChannelIterator"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.0/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.27.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/pnet"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0037.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/libpnet/libpnet/issues/449"
    }
  ]
},"206":{
  "id": "RUSTSEC-2021-0001",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-04T12:00:00Z",
  "aliases": [
    "CVE-2020-26297"
  ],
  "related": [],
  "summary": "XSS in mdBook's search page",
  "details": "> This is a cross-post of [the official security advisory][ml]. The official post\n> contains a signed version with our PGP key, as well.\n\n[ml]: https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0\n\nThe Rust Security Response Working Group was recently notified of a security\nissue affecting the search feature of mdBook, which could allow an attacker to\nexecute arbitrary JavaScript code on the page.\n\nThe CVE for this vulnerability is [CVE-2020-26297][1].\n\n## Overview\n\nThe search feature of mdBook (introduced in version 0.1.4) was affected by a\ncross site scripting vulnerability that allowed an attacker to execute\narbitrary JavaScript code on an user's browser by tricking the user into typing\na malicious search query, or tricking the user into clicking a link to the\nsearch page with the malicious search query prefilled.\n\nmdBook 0.4.5 fixes the vulnerability by properly escaping the search query.\n\n## Mitigations\n\nOwners of websites built with mdBook have to upgrade to mdBook 0.4.5 or greater\nand rebuild their website contents with it. It's possible to install mdBook\n0.4.5 on the local system with:\n\n```\ncargo install mdbook --version 0.4.5 --force\n```\n\n## Acknowledgements\n\nThanks to Kamil Vavra for responsibly disclosing the vulnerability to us\naccording to [our security policy][2].\n\n## Timeline of events\n\nAll times are listed in UTC.\n\n* 2020-12-30 20:14 - The issue is reported to the Rust Security Response WG\n* 2020-12-30 20:32 - The issue is acknowledged and the investigation began\n* 2020-12-30 21:21 - Found the cause of the vulnerability and prepared the patch\n* 2021-01-04 15:00 - Patched version released and vulnerability disclosed\n\n[1]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-26297\n[2]: https://www.rust-lang.org/policies/security",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "mdbook",
        "purl": "pkg:cargo/mdbook"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "code-execution"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.4-0","<": "0.4.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/mdbook"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0001.html"
    },
    {
      "type": "WEB",
      "url": "https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0"
    }
  ]
},"207":{
  "id": "RUSTSEC-2020-0031",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-06-16T12:00:00Z",
  "aliases": [
    "CVE-2020-35884"
  ],
  "related": [],
  "summary": "HTTP Request smuggling through malformed Transfer Encoding headers",
  "details": "HTTP pipelining issues and request smuggling attacks are possible due to incorrect \nTransfer encoding header parsing.\n\nIt is possible conduct HTTP request smuggling attacks (CL:TE/TE:TE) by sending invalid Transfer Encoding headers. \n\nBy manipulating the HTTP response the attacker could poison a web-cache, perform an XSS attack, or obtain sensitive information \nfrom requests other than their own.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tiny_http",
        "purl": "pkg:cargo/tiny_http"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.3"
            },
            {
              ">=": "0.7.0-0","<": "0.8.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tiny_http"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0031.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tiny-http/tiny-http/issues/173"
    }
  ]
},"208":{
  "id": "RUSTSEC-2018-0007",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-10-09T12:00:00Z",
  "aliases": [
    "CVE-2018-20994"
  ],
  "related": [],
  "summary": "Stack overflow when parsing malicious DNS packet",
  "details": "There's a stack overflow leading to a crash when Trust-DNS's parses a\nmalicious DNS packet.\n\nAffected versions of this crate did not properly handle parsing of DNS message\ncompression (RFC1035 section 4.1.4). The parser could be tricked into infinite\nloop when a compression offset pointed back to the same domain name to be\nparsed.\n\nThis allows an attacker to craft a malicious DNS packet which when consumed\nwith Trust-DNS could cause stack overflow and crash the affected software.\n\nThe flaw was corrected by trust-dns-proto 0.4.3 and upcoming 0.5.0 release.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "trust-dns-proto",
        "purl": "pkg:cargo/trust-dns-proto"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/trust-dns-proto"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0007.html"
    }
  ]
},"209":{
  "id": "RUSTSEC-2021-0095",
  "modified": "2021-08-22T01:48:14Z",
  "published": "2021-06-01T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`mopa` is technically unsound",
  "details": "The `mopa` crate redefines the deprecated `TraitObject` struct from `core::raw` like so:\n```rust\n#[repr(C)]\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n```\nThis is done to then transmute a reference to a trait object (`&dyn Trait` for any trait `Trait`) into this struct and retrieve the `data` field for the purpose of downcasting. This is used to implement `downcast_ref_unchecked()`, in terms of which `downcast_ref()` is also implemented. Same goes for mutable reference downcasting and `Box` downcasting.\n\nThe Rust compiler explicitly reserves the right to change the memory layout of `&dyn Trait` for any trait `Trait`. The worst case scenario is that it swaps `data` and `vtable`, making an executable location breach and compromisation of ASLR possible, since reads from `data` would read `vtable` instead. Likewise, arbitrary code execution is also theoretically possible if reads of `vtable` generated by the compiler read `data` instead.\n\nWhile, as of Rust 1.52, this unsound assumption still holds true, updating the compiler may silently create UB in a crate which previously compiled and run without issues, compromising the security of builds which are believed to be reproducible.\n\nA potential strategy to resolve this has already been suggested in an issue on the GitHub repository of the crate.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "mopa",
        "purl": "pkg:cargo/mopa"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure",
          "code-execution"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/mopa"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0095.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/chris-morgan/mopa/issues/13"
    }
  ]
},"210":{
  "id": "RUSTSEC-2020-0123",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-24T12:00:00Z",
  "aliases": [
    "CVE-2020-36443"
  ],
  "related": [],
  "summary": "Contents of uninitialized memory exposed in DeflateOutput's AsyncRead implementation",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided trait function `AsyncRead::poll_read()`.\n\nArbitrary `AsyncRead::poll_read()` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe flaw was fixed in commit 5ba266a by ensuring the newly allocated part of the buffer is zero-initialized before passing it to a user-provided `AsyncRead::poll_read()`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libp2p-deflate",
        "purl": "pkg:cargo/libp2p-deflate"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.27.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libp2p-deflate"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0123.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/libp2p/rust-libp2p/issues/1932"
    }
  ]
},"211":{
  "id": "RUSTSEC-2020-0089",
  "modified": "2021-01-04T17:02:59Z",
  "published": "2020-12-09T12:00:00Z",
  "aliases": [
    "CVE-2020-35926"
  ],
  "related": [],
  "summary": "nanorand 0.5.0 - RNGs failed to generate properly for non-64-bit numbers",
  "details": "In versions of `nanorand` prior to 0.5.1, `RandomGen` implementations for standard unsigned integers could\nfail to properly generate numbers, due to using bit-shifting to truncate a 64-bit number, rather than just\nan `as` conversion.\n\nThis often manifested as RNGs returning nothing but 0, including the cryptographically secure `ChaCha` random\nnumber generator..",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "nanorand",
        "purl": "pkg:cargo/nanorand"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/nanorand"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0089.html"
    },
    {
      "type": "WEB",
      "url": "https://twitter.com/aspenluxxxy/status/1336684692284772352"
    }
  ]
},"212":{
  "id": "RUSTSEC-2020-0066",
  "modified": "2020-11-02T14:48:54Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_bindgen`",
  "details": "This crate has been renamed from `safe_bindgen` to `sn_bindgen`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_bindgen>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe_bindgen",
        "purl": "pkg:cargo/safe_bindgen"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe_bindgen"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0066.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_bindgen/pull/67"
    }
  ]
},"213":{
  "id": "RUSTSEC-2020-0135",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-17T12:00:00Z",
  "aliases": [
    "CVE-2020-36455"
  ],
  "related": [],
  "summary": "Slock<T> allows sending non-Send types across thread boundaries",
  "details": "`Slock<T>` unconditionally implements `Send`/`Sync`.\n\nAffected versions of this crate allows sending non-Send types to other threads,\nwhich can lead to data races and memory corruption due to the data race.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "slock",
        "purl": "pkg:cargo/slock"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/slock"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0135.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/BrokenLamp/slock-rs/issues/2"
    }
  ]
},"214":{
  "id": "RUSTSEC-2020-0070",
  "modified": "2021-01-31T04:02:50Z",
  "published": "2020-11-08T12:00:00Z",
  "aliases": [
    "CVE-2020-35910",
    "CVE-2020-35911",
    "CVE-2020-35912",
    "CVE-2020-35913",
    "CVE-2020-35914"
  ],
  "related": [],
  "summary": "Some lock_api lock guard objects can cause data races",
  "details": "Affected versions of lock_api had unsound implementations of the `Send` or\n`Sync` traits for some guard objects, namely:\n\n* MappedMutexGuard\n* MappedRwLockReadGuard\n* MappedRwLockWriteGuard\n* RwLockReadGuard\n* RwLockWriteGuard\n\nThese guards could allow data races through types that are not safe to `Send`\nacross thread boundaries in safe Rust code.\n\nThis issue was fixed by changing the trait bounds on the `Mapped` guard types\nand removing the `Sync` trait for the `RwLock` guards.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lock_api",
        "purl": "pkg:cargo/lock_api"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "lock_api::MappedMutexGuard",
            "lock_api::MappedRwLockReadGuard",
            "lock_api::MappedRwLockWriteGuard",
            "lock_api::RwLockReadGuard",
            "lock_api::RwLockWriteGuard"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lock_api"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0070.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/Amanieu/parking_lot/pull/262"
    }
  ]
},"215":{
  "id": "RUSTSEC-2017-0003",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2017-03-15T12:00:00Z",
  "aliases": [
    "CVE-2017-18588"
  ],
  "related": [],
  "summary": "Hostname verification skipped when custom root certs used",
  "details": "If custom root certificates were registered with a `ClientBuilder`, the\nhostname of the target server would not be validated against its presented leaf\ncertificate.\n\nThis issue was fixed by properly configuring the trust evaluation logic to\nperform that check.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "security-framework",
        "purl": "pkg:cargo/security-framework"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.12"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/security-framework"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0003.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/sfackler/rust-security-framework/pull/27"
    }
  ]
},"216":{
  "id": "RUSTSEC-2020-0162",
  "modified": "2022-02-07T02:25:36Z",
  "published": "2020-02-06T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`tokio-proto` is deprecated/unmaintained",
  "details": "The [`tokio-proto`](https://crates.io/crates/tokio-proto) crate has been deprecated, and [its GitHub repository](https://github.com/tokio-rs/tokio-proto) has been archived.\nUsers may be interested in [`tokio-tower`](https://crates.io/crates/tokio-tower) instead, per https://github.com/tokio-rs/tokio/issues/118#issuecomment-452969665",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tokio-proto",
        "purl": "pkg:cargo/tokio-proto"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tokio-proto"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0162.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/tokio-rs/tokio-proto/commit/56c720ea3c74efa8f39e36c24e609628222b16a1"
    }
  ]
},"217":{
  "id": "RUSTSEC-2020-0027",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-06-01T12:00:00Z",
  "aliases": [
    "CVE-2020-35881"
  ],
  "related": [],
  "summary": "traitobject assumes the layout of fat pointers",
  "details": "This crate gets the data pointer from fat pointers assuming that the first\nelement in a fat pointer is the data pointer. This is currently true, but\nit may change in a future Rust version, leading to memory corruption.\n\nThis has been fixed in the master branch of the crate, but is has not\nbeen released into crates.io.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "traitobject",
        "purl": "pkg:cargo/traitobject"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "traitobject::data",
            "traitobject::data_mut"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/traitobject"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0027.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/reem/rust-traitobject/issues/7"
    }
  ]
},"218":{
  "id": "RUSTSEC-2018-0011",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-12-18T12:00:00Z",
  "aliases": [
    "CVE-2018-20998"
  ],
  "related": [],
  "summary": "Enum repr causing potential memory corruption",
  "details": "The attribute repr() added to enums to be compatible with C-FFI caused\nmemory corruption on MSVC toolchain.\n\narrayfire crates <= version 3.5.0 do not have this issue when used with\nRust versions 1.27 or earlier. The issue only started to appear since\nRust version 1.28.\n\nThe issue seems to be interlinked with which version of Rust is being used.\n\nThe issue was fixed in crate 3.6.0.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arrayfire",
        "purl": "pkg:cargo/arrayfire"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [
            "x86_64"
          ],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "3.5.1-0","<": "3.6.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arrayfire"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0011.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/arrayfire/arrayfire-rust/pull/177"
    }
  ]
},"219":{
  "id": "RUSTSEC-2021-0083",
  "modified": "2021-08-22T01:17:47Z",
  "published": "2021-01-20T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "QueryInterface should call AddRef before returning pointer",
  "details": "Affected version of this crate, which is a required dependency in com-impl, \nprovides a faulty implementation of the `IUnknown::QueryInterface` method.\n\n`QueryInterface` implementation must call `IUnknown::AddRef` before returning the pointer,\nas describe in this documentation:\n<https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)>\n\nAs it is not incrementing the refcount as expected, the following calls to `IUnknown::Release` method \nwill cause WMI to drop reference to the interface, and can lead to invalid reference.\n\nThis is documented in <https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting>\n\nThere is no simple workaround, as you can't know how many time QueryInterface will be called.\nThe only way to quick fix this is to use the macro expanded version of the code and modify \nthe QueryInterface method to add the AddRef call yourself.\n\nThe issue was corrected in commit `9803f31fbd1717d482d848f041044d061fca6da7`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "derive-com-impl",
        "purl": "pkg:cargo/derive-com-impl"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "derive_com_impl::derive_com_impl"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/derive-com-impl"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0083.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Connicpu/com-impl/issues/1"
    }
  ]
},"220":{
  "id": "RUSTSEC-2021-0129",
  "modified": "2021-12-15T00:18:24Z",
  "published": "2021-12-14T12:00:00Z",
  "aliases": [
    "CVE-2021-4044"
  ],
  "related": [],
  "summary": "Invalid handling of `X509_verify_cert()` internal errors in libssl",
  "details": "Internally libssl in OpenSSL calls `X509_verify_cert()` on the client side to\nverify a certificate supplied by a server. That function may return a negative\nreturn value to indicate an internal error (for example out of memory). Such a\nnegative return value is mishandled by OpenSSL and will cause an IO function\n(such as `SSL_connect()` or `SSL_do_handshake()`) to not indicate success and a\nsubsequent call to `SSL_get_error()` to return the value\n`SSL_ERROR_WANT_RETRY_VERIFY`. This return value is only supposed to be returned\nby OpenSSL if the application has previously called\n`SSL_CTX_set_cert_verify_callback()`. Since most applications do not do this the\n`SSL_ERROR_WANT_RETRY_VERIFY` return value from `SSL_get_error()` will be totally\nunexpected and applications may not behave correctly as a result. The exact\nbehaviour will depend on the application but it could result in crashes,\ninfinite loops or other similar incorrect responses.\n\nThis issue is made more serious in combination with a separate bug in OpenSSL\n3.0 that will cause `X509_verify_cert()` to indicate an internal error when\nprocessing a certificate chain. This will occur where a certificate does not\ninclude the Subject Alternative Name extension but where a Certificate Authority\nhas enforced name constraints. This issue can occur even with valid chains.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "300.0.0","<": "300.0.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0129.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20211214.txt"
    }
  ]
},"221":{
  "id": "RUSTSEC-2020-0050",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-27T12:00:00Z",
  "aliases": [
    "CVE-2020-35903"
  ],
  "related": [],
  "summary": "VecCopy allows misaligned access to elements",
  "details": "`VecCopy::data` is created as a Vec of u8 but can be used to store and retrieve\nelements of different types leading to misaligned access.\n\nThe issue was resolved in v0.5.0 by replacing data being stored by `Vec<u8>` with a custom managed\npointer.  Elements are now stored and retrieved using types with proper alignment corresponding to\noriginal types.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "dync",
        "purl": "pkg:cargo/dync"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/dync"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0050.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/elrnv/dync/issues/4"
    }
  ]
},"222":{
  "id": "RUSTSEC-2020-0115",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-16T12:00:00Z",
  "aliases": [
    "CVE-2020-36435"
  ],
  "related": [],
  "summary": "Singleton lacks bounds on Send and Sync.",
  "details": "`Singleton<T>` is meant to be a static object that can be initialized lazily. In\norder to satisfy the requirement that `static` items must implement `Sync`,\n`Singleton` implemented both `Sync` and `Send` unconditionally.\n\nThis allows for a bug where non-`Sync` types such as `Cell` can be used in\nsingletons and cause data races in concurrent programs.\n\nThe flaw was corrected in commit `b0d2bd20e` by adding trait bounds, requiring\nthe contaiend type to implement `Sync`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ruspiro-singleton",
        "purl": "pkg:cargo/ruspiro-singleton"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ruspiro-singleton"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0115.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RusPiRo/ruspiro-singleton/issues/10"
    }
  ]
},"223":{
  "id": "RUSTSEC-2021-0109",
  "modified": "2021-09-10T15:58:38Z",
  "published": "2021-07-25T12:00:00Z",
  "aliases": [
    "GHSA-45p7-c959-rgcm"
  ],
  "related": [],
  "summary": "Process crashes when the cell used as DepGroup is not alive",
  "details": "It's easy to create a malign transaction which uses the dead cell as the DepGroup in the DepCells. The transaction can crash all the receiving nodes.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ckb",
        "purl": "pkg:cargo/ckb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.40.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ckb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0109.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-45p7-c959-rgcm"
    }
  ]
},"224":{
  "id": "RUSTSEC-2020-0007",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-03-27T12:00:00Z",
  "aliases": [
    "CVE-2020-35862"
  ],
  "related": [],
  "summary": "use-after or double free of allocated memory",
  "details": "Conversion of `BitVec` to `BitBox` did not account for allocation movement.\n\nThe flaw was corrected by using the address after resizing, rather than the original base address.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bitvec",
        "purl": "pkg:cargo/bitvec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "bitvec::vec::BitVec::into_boxed_bitslice"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.11.0","<": "0.17.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bitvec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0007.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/myrrlyn/bitvec/issues/55"
    }
  ]
},"225":{
  "id": "RUSTSEC-2020-0142",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-29T12:00:00Z",
  "aliases": [
    "CVE-2020-36462"
  ],
  "related": [],
  "summary": "Send bound needed on T (for Send impl of `Bucket2`)",
  "details": "Affected versions of this crate unconditionally implements `Send` for `Bucket2`. This allows sending non-Send types to other threads.\n\nThis can lead to data races when non Send types like `Cell<T>` or `Rc<T>` are contained inside `Bucket2` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).\n\nThe flaw was corrected in commit 15b2828 by adding a `T: Send` bound to the `Send` impl of `Bucket2<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "syncpool",
        "purl": "pkg:cargo/syncpool"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/syncpool"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0142.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Chopinsky/byte_buffer/issues/2"
    }
  ]
},"226":{
  "id": "RUSTSEC-2020-0011",
  "modified": "2020-10-25T19:51:46Z",
  "published": "2020-04-23T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Library exclusively intended to obfuscate code.",
  "details": "This crate allows you to write safe functions with unsafe bodies without the `unsafe` keyword.\n\nThe value this adds is questionable, and hides `unsafe` usages from naive analysis.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "plutonium",
        "purl": "pkg:cargo/plutonium"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "notice"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/plutonium"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0011.html"
    },
    {
      "type": "WEB",
      "url": "https://docs.rs/plutonium"
    }
  ]
},"227":{
  "id": "RUSTSEC-2020-0154",
  "modified": "2021-08-22T01:30:23Z",
  "published": "2020-12-31T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "InputStream::read_exact : `Read` on uninitialized buffer causes UB",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "buffoon",
        "purl": "pkg:cargo/buffoon"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/buffoon"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0154.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/carllerche/buffoon/issues/2"
    }
  ]
},"228":{
  "id": "RUSTSEC-2020-0046",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-08T12:00:00Z",
  "aliases": [
    "CVE-2020-35899"
  ],
  "related": [],
  "summary": "bespoke Cell implementation allows obtaining several mutable references to the same data",
  "details": "The custom implementation of a Cell primitive in the affected versions of this crate\ndoes not keep track of mutable references to the underlying data.\n\nThis allows obtaining several mutable references to the same object\nwhich may result in arbitrary memory corruption, most likely use-after-free.\n\nThe flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "actix-service",
        "purl": "pkg:cargo/actix-service"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/actix-service"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0046.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/actix/actix-net/pull/158"
    }
  ]
},"229":{
  "id": "RUSTSEC-2020-0103",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-31T12:00:00Z",
  "aliases": [
    "CVE-2020-36210"
  ],
  "related": [],
  "summary": "`impl Random` on arrays can lead to dropping uninitialized memory",
  "details": "Affected versions of this crate had a panic safety issue to drop partially uninitialized array of `T` upon panic in a user provided function `T::random()`. Dropping uninitialized `T` can potentially cause memory corruption or undefined behavior.\n\nThe flaw was corrected in commit 565d508 by using `MaybeUninit<T>` to avoid possible dropping of uninitialized memory upon panic.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "autorand",
        "purl": "pkg:cargo/autorand"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/autorand"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0103.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/mersinvald/autorand-rs/issues/5"
    }
  ]
},"230":{
  "id": "RUSTSEC-2021-0076",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-07-13T12:00:00Z",
  "aliases": [
    "CVE-2021-38195"
  ],
  "related": [],
  "summary": "libsecp256k1 allows overflowing signatures",
  "details": "libsecp256k1 accepts signatures whose R or S parameter is larger than the\nsecp256k1 curve order, which differs from other implementations. This could\nlead to invalid signatures being verified.\n\nThe error is resolved in 0.5.0 by adding a `check_overflow` flag.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libsecp256k1",
        "purl": "pkg:cargo/libsecp256k1"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libsecp256k1"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0076.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/paritytech/libsecp256k1/pull/67"
    }
  ]
},"231":{
  "id": "RUSTSEC-2021-0099",
  "modified": "2021-08-25T14:54:10Z",
  "published": "2021-08-25T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Crate has been renamed to `cosmrs`",
  "details": "The `cosmos_sdk` crate, which provides a basic Rust SDK for the Cosmos ecosystem,\nhas rebranded to “CosmRS” in the spirit of other projects like CosmJS and CosmWasm.\n\nYou can find the new home here:\n\nhttps://github.com/cosmos/cosmos-rust/tree/main/cosmrs\n\nThe new crate name is `cosmrs`:\n\nhttps://crates.io/crates/cosmrs",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cosmos_sdk",
        "purl": "pkg:cargo/cosmos_sdk"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cosmos_sdk"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0099.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/cosmos/cosmos-rust/issues/113"
    }
  ]
},"232":{
  "id": "RUSTSEC-2021-0133",
  "modified": "2021-12-25T18:20:22Z",
  "published": "2021-12-25T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "cargo-download is unmaintained",
  "details": "The cargo download subcommand (via cargo-download crate) is broken and maintainer has disappeared from GitHub and hasn't had any commits for a year. \n\nUsing this downloader will result to corrupted crates.\n\nMaintainer has not responded to maintenance takeover.\n\nJust use wget / curl directly.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cargo-download",
        "purl": "pkg:cargo/cargo-download"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cargo-download"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0133.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/Xion/cargo-download"
    }
  ]
},"233":{
  "id": "RUSTSEC-2021-0021",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-14T12:00:00Z",
  "aliases": [
    "CVE-2021-27376"
  ],
  "related": [],
  "summary": "`nb-connect` invalidly assumes the memory layout of std::net::SocketAddr",
  "details": "The [`nb-connect`](https://crates.io/crates/nb-connect) crate has assumed `std::net::SocketAddrV4`\nand `std::net::SocketAddrV6` have the same memory layout as the system C representation\n`sockaddr`. It has simply casted the pointers to convert the socket addresses to the\nsystem representation. The standard library does not say anything about the memory\nlayout, and this will cause invalid memory access if the standard library\nchanges the implementation. No warnings or errors will be emitted once the\nchange happens.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "nb-connect",
        "purl": "pkg:cargo/nb-connect"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/nb-connect"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0021.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/smol-rs/nb-connect/issues/1"
    }
  ]
},"234":{
  "id": "RUSTSEC-2016-0005",
  "modified": "2022-01-09T20:07:15Z",
  "published": "2016-09-06T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "rust-crypto is unmaintained; switch to a modern alternative",
  "details": "The `rust-crypto` crate has not seen a release or GitHub commit since 2016,\nand its author is unresponsive.\n\n*NOTE: The (old) `rust-crypto` crate (with hyphen) should not be confused with\nsimilarly named (new) [RustCrypto GitHub Org] (without hyphen). The GitHub Org\nis actively maintained.*\n\nWe recommend you switch to one of the following crates instead, depending on\nwhich algorithms you need:\n\n- [dalek-cryptography GitHub Org]:\n  - Key agreement: [`x25519-dalek`]\n  - Signature algorithms: [`ed25519-dalek`]\n- [`ring`]:\n  - AEAD algorithms: AES-GCM, ChaCha20Poly1305\n  - Digest algorithms: SHA-256, SHA-384, SHA-512, SHA-512/256 (legacy: SHA-1)\n  - HMAC\n  - Key agreement: ECDH (P-256, P-384), X25519\n  - Key derivation: HKDF\n  - Password hashing: PBKDF2\n  - Signature algorithms: ECDSA (P-256, P-384), Ed25519, RSA (PKCS#1v1.5, PSS)\n- [RustCrypto GitHub Org]:\n  - AEAD algorithms: [`aes-gcm`], [`aes-gcm-siv`], [`aes-siv`], [`chacha20poly1305`], [`xsalsa20poly1305`]\n  - Block ciphers: [`aes`], [`cast5`], [`des`]\n  - Digest algorithms: [`sha2`], [`sha3`], [`blake2`], [`ripemd160`]\n    (legacy: [`sha-1`], [`md-5`])\n  - Key derivation: [`hkdf`]\n  - MACs: [`cmac`], [`hmac`], [`pmac`], [`poly1305`]\n  - Password hashing: [`pbkdf2`]\n  - Stream ciphers: [`aes-ctr`], [`chacha20`], [`hc-256`], [`salsa20`]\n- [`secp256k1`]:\n  - Key agreement: ECDH (secp256k1 only)\n  - Signature algorithms: ECDSA (secp256k1 only)\n- [`orion`]:\n  - AEAD algorithms: ChaCha20Poly1305 (IETF version), XChaCha20Poly1305\n  - Digest algorithms: SHA-512, BLAKE2b\n  - Key derivation: HKDF\n  - MACs: HMAC, Poly1305\n  - Password hashing: PBKDF2\n  - Stream ciphers: ChaCha20 (IETF version), XChaCha20\n\n[dalek-cryptography GitHub Org]: https://github.com/dalek-cryptography\n[RustCrypto GitHub Org]: https://github.com/RustCrypto\n[`aes`]: https://crates.io/crates/aes\n[`aes-ctr`]: https://crates.io/crates/aes-ctr\n[`aes-gcm`]: https://crates.io/crates/aes-gcm\n[`aes-gcm-siv`]: https://crates.io/crates/aes-gcm-siv\n[`aes-siv`]: https://crates.io/crates/aes-siv\n[`blake2`]: https://crates.io/crates/blake2\n[`cast5`]: https://crates.io/crates/cast5\n[`chacha20`]: https://crates.io/crates/chacha20\n[`chacha20poly1305`]: https://crates.io/crates/chacha20poly1305\n[`cmac`]: https://crates.io/crates/cmac\n[`des`]: https://crates.io/crates/des\n[`ed25519-dalek`]: https://crates.io/crates/ed25519-dalek\n[`hc-256`]: https://crates.io/crates/hc-256\n[`hkdf`]: https://crates.io/crates/hkdf\n[`hmac`]: https://crates.io/crates/hmac\n[`pbkdf2`]: https://crates.io/crates/pbkdf2\n[`pmac`]: https://crates.io/crates/pmac\n[`poly1305`]: https://crates.io/crates/poly1305\n[`ring`]: https://crates.io/crates/ring\n[`ripemd160`]: https://crates.io/crates/ripemd160\n[`salsa20`]: https://crates.io/crates/salsa20\n[`secp256k1`]: https://crates.io/crates/secp256k1\n[`sha-1`]: https://crates.io/crates/sha-1\n[`sha2`]: https://crates.io/crates/sha2\n[`sha3`]: https://crates.io/crates/sha3\n[`x25519-dalek`]: https://crates.io/crates/x25519-dalek\n[`xsalsa20poly1305`]: https://crates.io/crates/xsalsa20poly1305\n[`orion`]: https://crates.io/crates/orion",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rust-crypto",
        "purl": "pkg:cargo/rust-crypto"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.37-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rust-crypto"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2016-0005.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/DaGenix/rust-crypto/issues/440"
    }
  ]
},"235":{
  "id": "RUSTSEC-2020-0085",
  "modified": "2020-12-07T17:22:02Z",
  "published": "2020-12-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_node`",
  "details": "This crate has been renamed from `safe_vault` to `sn_node`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_node>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe_vault",
        "purl": "pkg:cargo/safe_vault"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe_vault"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0085.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_node/pull/1116"
    }
  ]
},"236":{
  "id": "RUSTSEC-2019-0017",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-09-01T12:00:00Z",
  "aliases": [
    "CVE-2019-16141"
  ],
  "related": [],
  "summary": "Panic during initialization of Lazy<T> might trigger undefined behavior",
  "details": "If during the first dereference of Lazy<T> the initialization function panics,\nsubsequent dereferences will execute `std::hints::unreachable_unchecked`.\n\nApplications with `panic = \"abort\"` are not affected, as there will be no\nsubsequent dereferences.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "once_cell",
        "purl": "pkg:cargo/once_cell"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "once_cell::sync::Lazy::deref",
            "once_cell::sync::Lazy::force",
            "once_cell::unsync::Lazy::deref",
            "once_cell::unsync::Lazy::force"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.2.5","<": "1.0.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/once_cell"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0017.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/matklad/once_cell/issues/46"
    }
  ]
},"237":{
  "id": "RUSTSEC-2021-0037",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-03-05T12:00:00Z",
  "aliases": [
    "CVE-2021-28305"
  ],
  "related": [],
  "summary": "Fix a use-after-free bug in diesels Sqlite backend",
  "details": "We've misused `sqlite3_column_name`. The\n[SQLite](https://www.sqlite.org/c3ref/column_name.html) documentation\nstates that the following:\n\n> The returned string pointer is valid until either the prepared statement\n> is destroyed by sqlite3_finalize() or until the statement is automatically\n> reprepared by the first call to sqlite3_step() for a particular\n> run or until the next call to sqlite3_column_name()\n> or sqlite3_column_name16() on the same column.\n\nAs part of our `query_by_name` infrastructure we've first received all\nfield names for the prepared statement and stored them as string slices\nfor later use. After that we called `sqlite3_step()` for the first time,\nwhich invalids the pointer and therefore the stored string slice.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "diesel",
        "purl": "pkg:cargo/diesel"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "diesel::SqliteConnection::query_by_name"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.4.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/diesel"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0037.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/diesel-rs/diesel/pull/2663"
    }
  ]
},"238":{
  "id": "RUSTSEC-2020-0139",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-09T12:00:00Z",
  "aliases": [
    "CVE-2020-36459"
  ],
  "related": [],
  "summary": "dces' World type can cause data races",
  "details": "The `World` type in `dces` is marked as `Send` without bounds on its\n`EntityStore` and `ComponentStore`.\n\nThis allows non-thread safe `EntityStore` and `ComponentStore`s to be sent\nacross threads and cause data races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "dces",
        "purl": "pkg:cargo/dces"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/dces"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0139.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.redox-os.org/redox-os/dces-rust/-/issues/8"
    }
  ]
},"239":{
  "id": "RUSTSEC-2020-0093",
  "modified": "2021-02-26T01:00:25Z",
  "published": "2020-12-17T12:00:00Z",
  "aliases": [
    "CVE-2020-26281",
    "CVE-2020-36202",
    "GHSA-4vr9-8cjf-vf9c"
  ],
  "related": [],
  "summary": "Async-h1 request smuggling possible with long unread bodies",
  "details": "This vulnerability affects any webserver that uses async-h1 behind a reverse proxy, including all such Tide applications.\n\nIf the server does not read the body of a request which is longer than some buffer length, async-h1 will attempt to read a subsequent request from the body content starting at that offset into the body.\n\nOne way to exploit this vulnerability would be for an adversary to craft a request such that the body contains a request that would not be noticed by a reverse proxy, allowing it to forge forwarded/x-forwarded headers. If an application trusted the authenticity of these headers, it could be misled by the smuggled request.\n\nAnother potential concern with this vulnerability is that if a reverse proxy is sending multiple http clients' requests along the same keep-alive connection, it would be possible for the smuggled request to specify a long content and capture another user's request in its body. This content could be captured in a post request to an endpoint that allows the content to be subsequently retrieved by the adversary.\n\nThe flaw was corrected in commit [7df79f](https://github.com/http-rs/async-h1/commit/7df79f1d5d99fc0f492b315eebc7f0d301a85212) by ensuring that the request body is always consumed from the tcp stream before attempting to read subsequent keep-alive request headers from it.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "async-h1",
        "purl": "pkg:cargo/async-h1"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "async_h1::server::accept",
            "async_h1::server::decode"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/async-h1"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0093.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/http-rs/async-h1/releases/tag/v2.3.0"
    }
  ]
},"240":{
  "id": "RUSTSEC-2019-0001",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-04-27T12:00:00Z",
  "aliases": [
    "CVE-2019-15542"
  ],
  "related": [],
  "summary": "Uncontrolled recursion leads to abort in HTML serialization",
  "details": "Affected versions of this crate did use recursion for serialization of HTML\nDOM trees.\n\nThis allows an attacker to cause abort due to stack overflow by providing\na pathologically nested input.\n\nThe flaw was corrected by serializing the DOM tree iteratively instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ammonia",
        "purl": "pkg:cargo/ammonia"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "ammonia::Document::to_string",
            "ammonia::Document::write_to",
            "ammonia::clean"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.1.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ammonia"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0001.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-ammonia/ammonia/blob/master/CHANGELOG.md#210"
    }
  ]
},"241":{
  "id": "RUSTSEC-2021-0060",
  "modified": "2021-05-04T01:28:43Z",
  "published": "2021-04-29T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`aes-soft` has been merged into the `aes` crate",
  "details": "Please use the `aes` crate going forward. The new repository location is at:\n\n<https://github.com/RustCrypto/block-ciphers/tree/master/aes>\n\nAES-NI is now autodetected at runtime on `i686`/`x86-64` platforms.\nIf AES-NI is not present, the `aes` crate will fallback to a constant-time\nportable software implementation.\n\nTo force the use of a constant-time portable implementation on these platforms,\neven if AES-NI is available, use the new `force-soft` feature of the `aes`\ncrate to disable autodetection.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "aes-soft",
        "purl": "pkg:cargo/aes-soft"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/aes-soft"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0060.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/block-ciphers/pull/200"
    }
  ]
},"242":{
  "id": "RUSTSEC-2021-0125",
  "modified": "2021-11-18T00:32:59Z",
  "published": "2021-11-14T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Panic on incorrect date input to `simple_asn1`",
  "details": "Version 0.6.0 of the `simple_asn1` crate panics on certain malformed\ninputs to its parsing functions, including `from_der` and `der_decode`.\nBecause this crate is frequently used with inputs from the network, this\nshould be considered a security vulnerability.\n\nThe issue occurs when parsing the old ASN.1 \"UTCTime\" time format.  If an\nattacker provides a UTCTime where the first character is ASCII but the\nsecond character is above 0x7f, a string slice operation in the\n`from_der_` function will try to slice into the middle of a UTF-8\ncharacter, and cause a panic.\n\nThis error was introduced in commit\n[`d7d39d709577710e9dc8`](https://github.com/acw/simple_asn1/commit/d7d39d709577710e9dc8833ee57d200eef366db8),\nwhich updated `simple_asn1` to use `time` instead of `chrono` because of\n[`RUSTSEC-2020-159`](https://rustsec.org/advisories/RUSTSEC-2020-0159).\nVersions of `simple_asn1` before 0.6.0 are not affected by this issue.\n\nThe [patch](https://github.com/acw/simple_asn1/pull/28) was applied in\n`simple_asn1` version 0.6.1.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "simple_asn1",
        "purl": "pkg:cargo/simple_asn1"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/simple_asn1"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0125.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/acw/simple_asn1/issues/27"
    }
  ]
},"243":{
  "id": "RUSTSEC-2021-0061",
  "modified": "2021-05-04T01:28:43Z",
  "published": "2021-04-29T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`aes-ctr` has been merged into the `aes` crate",
  "details": "Please use the `aes` crate going forward. The new repository location is at:\n\n<https://github.com/RustCrypto/block-ciphers/tree/master/aes>\n\nThe `aes` crate now has an optional `ctr` feature which autodetects SIMD\nfeatures on `i686`/`x86-64` targets and uses them if available, or otherwise\nfalls back to the implementation in the `ctr` crate.\n\nIf you would prefer not to have this autodetection performed, use the `aes`\ncrate directly with the `ctr` crate.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "aes-ctr",
        "purl": "pkg:cargo/aes-ctr"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/aes-ctr"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0061.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/block-ciphers/pull/200"
    }
  ]
},"244":{
  "id": "RUSTSEC-2021-0124",
  "modified": "2022-01-13T20:33:38Z",
  "published": "2021-11-16T12:00:00Z",
  "aliases": [
    "CVE-2021-45710"
  ],
  "related": [],
  "summary": "Data race when sending and receiving after closing a `oneshot` channel",
  "details": "If a `tokio::sync::oneshot` channel is closed (via the\n[`oneshot::Receiver::close`] method), a data race may occur if the\n`oneshot::Sender::send` method is called while the corresponding\n`oneshot::Receiver` is `await`ed or calling `try_recv`.\n\nWhen these methods are called concurrently on a closed channel, the two halves\nof the channel can concurrently access a shared memory location, resulting in a\ndata race. This has been observed to [cause memory corruption][corruption].\n\nNote that the race only occurs when **both** halves of the channel are used\nafter the `Receiver` half has called `close`. Code where `close` is not used, or where the\n`Receiver` is not `await`ed and `try_recv` is not called after calling `close`,\nis not affected.\n\nSee [tokio#4225][issue] for more details.\n\n[corruption]: https://github.com/tokio-rs/tokio/issues/4225#issuecomment-967434847\n[issue]: https://github.com/tokio-rs/tokio/issues/4225\n[`oneshot::Receiver::close`]: https://docs.rs/tokio/1.14.0/tokio/sync/oneshot/struct.Receiver.html#method.close",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tokio",
        "purl": "pkg:cargo/tokio"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "tokio::sync::oneshot::Receiver::close"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.14","<": "1.8.4"
            },
            {
              ">=": "1.9.0","<": "1.13.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tokio"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0124.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tokio-rs/tokio/issues/4225"
    }
  ]
},"245":{
  "id": "RUSTSEC-2020-0138",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36458"
  ],
  "related": [],
  "summary": "ReaderResult should be bounded by Sync",
  "details": "Affected versions of this crate implements `Sync` for `ReaderResult<T, E>` with the trait bound `T: Send, E: Send`.\n\nSince matching on the public enum `ReaderResult<T, E>` provides access to `&T` & `&E`,\nallowing data race to a non-Sync type `T` or `E`.\nThis can result in a memory corruption when multiple threads concurrently access `&T` or `&E`.\n\nSuggested fix for the bug is change the trait bounds imposed on `T` & `E` to be `T: Sync, E: Sync`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lexer",
        "purl": "pkg:cargo/lexer"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lexer"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0138.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.com/nathanfaucett/rs-lexer/-/issues/2"
    }
  ]
},"246":{
  "id": "RUSTSEC-2020-0092",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-13T12:00:00Z",
  "aliases": [
    "CVE-2020-35928"
  ],
  "related": [],
  "summary": "Send/Sync bound needed on V in `impl Send/Sync for ARCache<K, V>`",
  "details": "Affected versions of this crate unconditionally implemented `Send`/`Sync` traits for `ARCache<K, V>` type.\n\nThis allows users to send/access types that do not implement `Send`/`Sync`, which can cause a data race.\n\nThe flaw was corrected in the 0.2.6 release by adding bounds `K: Send + Sync` & `V: Send + Sync` to affected `Send`/`Sync` trait implementations.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "concread",
        "purl": "pkg:cargo/concread"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/concread"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0092.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/kanidm/concread/issues/48"
    }
  ]
},"247":{
  "id": "RUSTSEC-2021-0036",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-03-03T12:00:00Z",
  "aliases": [
    "CVE-2021-28037"
  ],
  "related": [],
  "summary": "Intern<T>: Data race allowed on T",
  "details": "Affected versions of this crate unconditionally implements `Sync` for `Intern<T>`.\nThis allows users to create data race on `T: !Sync`, which may lead to undefined behavior\n(for example, memory corruption).\n\nThe flaw was corrected in commit 2928a87 by adding the trait bound `T: Sync` in the `Sync` impl of `Intern<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "internment",
        "purl": "pkg:cargo/internment"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/internment"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0036.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/droundy/internment/issues/20"
    }
  ]
},"248":{
  "id": "RUSTSEC-2020-0084",
  "modified": "2020-12-07T17:22:02Z",
  "published": "2020-12-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been superseded by `sn_client`",
  "details": "This crate has been superseded by `sn_client`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_client>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe_authenticator",
        "purl": "pkg:cargo/safe_authenticator"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe_authenticator"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0084.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_client/pull/1267"
    }
  ]
},"249":{
  "id": "RUSTSEC-2019-0016",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-09-01T12:00:00Z",
  "aliases": [
    "CVE-2019-16140"
  ],
  "related": [],
  "summary": "Use-after-free in buffer conversion implementation",
  "details": "The From<Buffer> implementation for Vec<u8> was not properly implemented,\nreturning a vector backed by freed memory. This could lead to memory corruption\nor be exploited to cause undefined behavior.\n \nA fix was published in version 0.1.3.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "chttp",
        "purl": "pkg:cargo/chttp"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.1","<": "0.1.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/chttp"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0016.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/sagebind/isahc/issues/2"
    }
  ]
},"250":{
  "id": "RUSTSEC-2021-0020",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-05T12:00:00Z",
  "aliases": [
    "CVE-2021-21299",
    "GHSA-6hfq-h8hq-87mf"
  ],
  "related": [],
  "summary": "Multiple Transfer-Encoding headers misinterprets request payload",
  "details": "hyper's HTTP server code had a flaw that incorrectly understands some requests\nwith multiple transfer-encoding headers to have a chunked payload, when it\nshould have been rejected as illegal. This combined with an upstream HTTP proxy\nthat understands the request payload boundary differently can result in\n\"request smuggling\" or \"desync attacks\".",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hyper",
        "purl": "pkg:cargo/hyper"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.12.0","<": "0.12.36"
            },
            {
              ">=": "0.13.0-0","<": "0.13.10"
            },
            {
              ">=": "0.14.0-0","<": "0.14.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hyper"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0020.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/hyperium/hyper/security/advisories/GHSA-6hfq-h8hq-87mf"
    }
  ]
},"251":{
  "id": "RUSTSEC-2016-0004",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2016-09-10T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "libusb is unmaintained; use rusb instead",
  "details": "The `libusb` crate has not seen a release since September 2016, and its author\nis unresponsive.\n\nThe `rusb` crate is a maintained fork:\n\nhttps://github.com/a1ien/rusb",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libusb",
        "purl": "pkg:cargo/libusb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libusb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2016-0004.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/dcuddeback/libusb-rs/issues/33"
    }
  ]
},"252":{
  "id": "RUSTSEC-2021-0077",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-07-22T12:00:00Z",
  "aliases": [
    "CVE-2021-38196"
  ],
  "related": [],
  "summary": "`better-macro` has deliberate RCE to prove a point",
  "details": "[better-macro](https://crates.io/crates/better-macro) is a fake crate which is\n\"Proving A Point\" that proc-macros can run arbitrary code. This is not a particularly\nnovel or interesting observation.\n\nIt currently opens `https://github.com/raycar5/better-macro/blob/master/doc/hi.md`\nwhich doesn't appear to have any malicious content, but there's no guarantee that\nwill remain the case.\n\nThis crate has no useful functionality, and should not be used.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "better-macro",
        "purl": "pkg:cargo/better-macro"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "better_macro::println"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "code-execution"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/better-macro"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0077.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/raycar5/better-macro/blob/24ff1702397b9c19bbfa4c660e2316cd77d3b900/src/lib.rs#L36-L38"
    }
  ]
},"253":{
  "id": "RUSTSEC-2021-0098",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-08-24T12:00:00Z",
  "aliases": [
    "CVE-2021-3712"
  ],
  "related": [],
  "summary": "Read buffer overruns processing ASN.1 strings",
  "details": "ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING\nstructure which contains a buffer holding the string data and a field holding\nthe buffer length. This contrasts with normal C strings which are represented as\na buffer for the string data which is terminated with a NUL (0) byte.\n\nAlthough not a strict requirement, ASN.1 strings that are parsed using OpenSSL's\nown \"d2i\" functions (and other similar parsing functions) as well as any string\nwhose value has been set with the ASN1_STRING_set() function will additionally\nNUL terminate the byte array in the ASN1_STRING structure.\n\nHowever, it is possible for applications to directly construct valid ASN1_STRING\nstructures which do not NUL terminate the byte array by directly setting the\n\"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by\nusing the `ASN1_STRING_set0()` function.\n\nNumerous OpenSSL functions that print ASN.1 data have been found to assume that\nthe ASN1_STRING byte array will be NUL terminated, even though this is not\nguaranteed for strings that have been directly constructed. Where an application\nrequests an ASN.1 structure to be printed, and where that ASN.1 structure\ncontains ASN1_STRINGs that have been directly constructed by the application\nwithout NUL terminating the \"data\" field, then a read buffer overrun can occur.\n\nThe same thing can also occur during name constraints processing of certificates\n(for example if a certificate has been directly constructed by the application\ninstead of loading it via the OpenSSL parsing functions, and the certificate\ncontains non NUL terminated ASN1_STRING structures). It can also occur in the\n`X509_get1_email()`, `X509_REQ_get1_email()` and `X509_get1_ocsp()` functions.\n\nIf a malicious actor can cause an application to directly construct an\nASN1_STRING and then process it through one of the affected OpenSSL functions\nthen this issue could be hit. This might result in a crash (causing a Denial of\nService attack). It could also result in the disclosure of private memory\ncontents (such as private keys, or sensitive plaintext).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service",
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "111.16.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0098.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20210824.txt"
    }
  ]
},"254":{
  "id": "RUSTSEC-2021-0132",
  "modified": "2021-12-21T22:27:44Z",
  "published": "2021-12-20T12:00:00Z",
  "aliases": [
    "CVE-2020-8927"
  ],
  "related": [],
  "summary": "Integer overflow in the bundled Brotli C library",
  "details": "A buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a \"one-shot\" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.\n\nIf one cannot update the C library, its authors recommend to use the \"streaming\" API as opposed to the \"one-shot\" API, and impose chunk size limits.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "compu-brotli-sys",
        "purl": "pkg:cargo/compu-brotli-sys"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.9"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/compu-brotli-sys"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0132.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/google/brotli/releases/tag/v1.0.9"
    }
  ]
},"255":{
  "id": "RUSTSEC-2020-0047",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-26T12:00:00Z",
  "aliases": [
    "CVE-2020-35900"
  ],
  "related": [],
  "summary": "array_queue pop_back() may cause a use-after-free",
  "details": "array_queue implements a circular queue that wraps around an array. However, it\nfails to properly index into the array in the `pop_back` function allowing the\nreading of previously dropped or uninitialized memory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "array-queue",
        "purl": "pkg:cargo/array-queue"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/array-queue"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0047.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/raviqqe/array-queue/issues/2"
    }
  ]
},"256":{
  "id": "RUSTSEC-2020-0102",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36209"
  ],
  "related": [],
  "summary": "LateStatic has incorrect Sync bound",
  "details": "Affected versions of this crate implemented `Sync` for `LateStatic` with `T: Send`, so that it is possible to create a data race to a type `T: Send + !Sync` (e.g. `Cell<T>`).\n\nThis can result in a memory corruption or other kinds of undefined behavior.\n\nThe flaw was corrected in commit 11f396c by replacing the `T: Send` bound to `T: Sync` bound in the `Sync` impl for `LateStatic<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "late-static",
        "purl": "pkg:cargo/late-static"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/late-static"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0102.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Richard-W/late-static/issues/1"
    }
  ]
},"257":{
  "id": "RUSTSEC-2020-0010",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2020-02-28T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "tiberius is unmaintained",
  "details": "The author of `tiberius` has archived the GitHub repository and left the\nfollowing note:\n\n> I do not have the time to overhaul the library and do not intend to further\n> maintain the 0.3 version relying on the old futures ecosystem.\n\nSuggested alternatives are:\n\n- [`odbc`](https://crates.io/crates/odbc)\n- [`sqlx`](https://github.com/launchbadge/sqlx/issues/116) (forthcoming)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tiberius",
        "purl": "pkg:cargo/tiberius"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.3-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tiberius"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0010.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/261"
    }
  ]
},"258":{
  "id": "RUSTSEC-2020-0155",
  "modified": "2021-08-22T01:32:53Z",
  "published": "2020-12-27T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`Read` on uninitialized buffer in `fill_buf()` and `read_up_to()`",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "acc_reader",
        "purl": "pkg:cargo/acc_reader"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/acc_reader"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0155.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/netvl/acc_reader/issues/1"
    }
  ]
},"259":{
  "id": "RUSTSEC-2020-0006",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-03-24T12:00:00Z",
  "aliases": [
    "CVE-2020-35861"
  ],
  "related": [],
  "summary": "Flaw in `realloc` allows reading unknown memory",
  "details": "When `realloc`ing, if we allocate new space, we need to copy the old\nallocation's bytes into the new space. There are `old_size` number of bytes in\nthe old allocation, but we were accidentally copying `new_size` number of bytes,\nwhich could lead to copying bytes into the realloc'd space from past the chunk\nthat we're bump allocating out of, from unknown memory.\n\nIf an attacker can cause `realloc`s, and can read the `realoc`ed data back,\nthis could allow them to read things from other regions of memory that they\nshouldn't be able to. For example, if some crypto keys happened to live in\nmemory right after a chunk we were bump allocating out of, this could allow\nthe attacker to read the crypto keys.\n\nBeyond just fixing the bug and adding a regression test, I've also taken two\nadditional steps:\n\n1. While we were already running the testsuite under `valgrind` in CI, because\n   `valgrind` exits with the same code that the program did, if there are\n   invalid reads/writes that happen not to trigger a segfault, the program can\n   still exit OK and we will be none the wiser. I've enabled the\n   `--error-exitcode=1` flag for `valgrind` in CI so that tests eagerly fail\n   in these scenarios.\n\n2. I've written a quickcheck test to exercise `realloc`. Without the bug fix\n   in this patch, this quickcheck immediately triggers invalid reads when run\n   under `valgrind`. We didn't previously have quickchecks that exercised\n   `realloc` because `realloc` isn't publicly exposed directly, and instead\n   can only be indirectly called. This new quickcheck test exercises `realloc`\n   via `bumpalo::collections::Vec::resize` and\n   `bumpalo::collections::Vec::shrink_to_fit` calls.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bumpalo",
        "purl": "pkg:cargo/bumpalo"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "3.0.0","<": "3.2.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bumpalo"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0006.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/fitzgen/bumpalo/issues/69"
    }
  ]
},"260":{
  "id": "RUSTSEC-2020-0143",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-25T12:00:00Z",
  "aliases": [
    "CVE-2020-36463"
  ],
  "related": [],
  "summary": "Queues allow non-Send types to be sent to other threads, allowing data races",
  "details": "Affected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).\n\nThis allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "multiqueue",
        "purl": "pkg:cargo/multiqueue"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/multiqueue"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0143.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/schets/multiqueue/issues/31"
    }
  ]
},"261":{
  "id": "RUSTSEC-2021-0108",
  "modified": "2021-09-10T15:52:06Z",
  "published": "2021-07-25T12:00:00Z",
  "aliases": [
    "GHSA-48vq-8jqv-gm6f"
  ],
  "related": [],
  "summary": "Remote memory exhaustion in ckb",
  "details": "In the ckb sync protocol, SyncState maintains a HashMap called 'misbehavior' that keeps a score of a peer's violations of the protocol. This HashMap is keyed to PeerIndex (an alias for SessionId), and entries are never removed from it. SessionId is an integer that increases monotonically with every new connection.\n\nA remote attacker can manipulate this HashMap to grow forever, resulting in degraded performance and ultimately a panic on allocation failure or being killed by the OS, depending on the platform.\n\nThis is a critical severity security bug. It could be exploited to create a targeted or network-wide denial of service, to reduce the hash power of the network as part of a 51% attack, and perhaps in other creative ways.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ckb",
        "purl": "pkg:cargo/ckb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.40.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ckb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0108.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/nervosnetwork/ckb/security/advisories/GHSA-48vq-8jqv-gm6f"
    }
  ]
},"262":{
  "id": "RUSTSEC-2020-0051",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2020-10-01T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Obsolete versions of the `rustsec` crate do not support the new V3 advisory format",
  "details": "If you are seeing this message, you are running an obsolete version of\n`cargo-audit` which does not support the new V3 advisory format.\nThese versions are end-of-life.\n\nThis advisory is a notice that that it will soon be unable to parse the\nadvisory database.\n\nPlease upgrade `cargo-audit` to a newer release.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rustsec",
        "purl": "pkg:cargo/rustsec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.19.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rustsec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0051.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/414"
    }
  ]
},"263":{
  "id": "RUSTSEC-2020-0114",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-22T12:00:00Z",
  "aliases": [
    "CVE-2020-36220"
  ],
  "related": [],
  "summary": "`Demuxer` can carry non-Send types across thread boundaries",
  "details": "In the affected versions of this crate, `Demuxer<T>` unconditionally implemented `Send` with no trait bounds on `T`.\n\nThis allows sending a non-Send type `T` across thread boundaries, which can cause undefined behavior like unlocking a mutex from a thread that didn't lock the mutex, or memory corruption from data race.\n\nThe flaw was corrected in commit 0562cbf by adding a `T: Send` bound to the `Send` impl for `Demuxer<T>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "va-ts",
        "purl": "pkg:cargo/va-ts"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.0.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/va-ts"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0114.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/video-audio/va-ts/issues/4"
    }
  ]
},"264":{
  "id": "RUSTSEC-2018-0010",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-06-01T12:00:00Z",
  "aliases": [
    "CVE-2018-20997"
  ],
  "related": [],
  "summary": "Use after free in CMS Signing",
  "details": "Affected versions of the OpenSSL crate used structures after they'd been freed.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl",
        "purl": "pkg:cargo/openssl"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.10.8","<": "0.10.9"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0010.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/sfackler/rust-openssl/pull/942"
    }
  ]
},"265":{
  "id": "RUSTSEC-2021-0082",
  "modified": "2021-10-17T22:19:40Z",
  "published": "2021-08-14T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "vec-const attempts to construct a Vec from a pointer to a const slice",
  "details": "Affected versions of this crate claimed to construct a const `Vec` with nonzero length and capacity, but that cannot be done because such a `Vec` requires a pointer from an allocator.\n\nThe implementation was later changed to just construct a `std::borrow::Cow`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "vec-const",
        "purl": "pkg:cargo/vec-const"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/vec-const"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0082.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Eolu/vec-const/issues/1#issuecomment-898908241"
    }
  ]
},"266":{
  "id": "RUSTSEC-2021-0128",
  "modified": "2021-12-09T00:29:19Z",
  "published": "2021-12-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Incorrect Lifetime Bounds on Closures in `rusqlite`",
  "details": "The lifetime bound on several closure-accepting `rusqlite` functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.\n\nThe impacted functions are:\n\n- Under `cfg(feature = \"functions\")`: `Connection::create_scalar_function`, `Connection::create_aggregate_function` and `Connection::create_window_function`.\n- Under `cfg(feature = \"hooks\")`: `Connection::commit_hook`, `Connection::rollback_hook` and `Connection::update_hook`.\n- Under `cfg(feature = \"collation\")`: `Connection::create_collation`.\n\nThe issue exists in all `0.25.*` versions prior to `0.25.4`, and all `0.26.*` versions prior to 0.26.2 (specifically: `0.25.0`, `0.25.1`, `0.25.2`, `0.25.3`, `0.26.0`, and `0.26.1`).\n\nThe fix is available in versions `0.26.2` and newer, and also has been back-ported to `0.25.4`. As it does not exist in `0.24.*`, all affected versions should have an upgrade path to a semver-compatible release.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rusqlite",
        "purl": "pkg:cargo/rusqlite"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rusqlite::Connection::commit_hook",
            "rusqlite::Connection::create_aggregate_function",
            "rusqlite::Connection::create_collation",
            "rusqlite::Connection::create_scalar_function",
            "rusqlite::Connection::create_window_function",
            "rusqlite::Connection::rollback_hook",
            "rusqlite::Connection::update_hook"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.25.0","<": "0.25.4"
            },
            {
              ">=": "0.26.0-0","<": "0.26.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rusqlite"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0128.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rusqlite/rusqlite/issues/1048"
    }
  ]
},"267":{
  "id": "RUSTSEC-2017-0002",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2017-01-23T12:00:00Z",
  "aliases": [
    "CVE-2017-18587"
  ],
  "related": [],
  "summary": "headers containing newline characters can split messages",
  "details": "Serializing of headers to the socket did not filter the values for newline bytes (`\\r` or `\\n`),\nwhich allowed for header values to split a request or response. People would not likely include\nnewlines in the headers in their own applications, so the way for most people to exploit this\nis if an application constructs headers based on unsanitized user input.\n\nThis issue was fixed by replacing all newline characters with a space during serialization of\na header value.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hyper",
        "purl": "pkg:cargo/hyper"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.18"
            },
            {
              ">=": "0.10.0","<": "0.10.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hyper"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0002.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/hyperium/hyper/wiki/Security-001"
    }
  ]
},"268":{
  "id": "RUSTSEC-2020-0026",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-06-23T12:00:00Z",
  "aliases": [
    "CVE-2020-25573"
  ],
  "related": [],
  "summary": "linked-hash-map creates uninitialized NonNull pointer",
  "details": "Affected versions of this crate called `mem::uninitialized()` to create a `NonNull<T>`,\nwhich is undefined behavior.\n \nThe flaw was corrected by avoiding the use of `mem::uninitialized()`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "linked-hash-map",
        "purl": "pkg:cargo/linked-hash-map"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/linked-hash-map"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0026.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/contain-rs/linked-hash-map/pull/100"
    }
  ]
},"269":{
  "id": "RUSTSEC-2020-0134",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-14T12:00:00Z",
  "aliases": [
    "CVE-2020-36454"
  ],
  "related": [],
  "summary": "`LockWeak<T>` allows to create data race to `T`.",
  "details": "In the affected versions of this crate, `LockWeak<T>` unconditionally implemented `Send` with no trait bounds on `T`. `LockWeak<T>` doesn't own `T` and only provides `&T`.\n\nThis allows concurrent access to a non-Sync `T`, which can cause undefined behavior like data races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "parc",
        "purl": "pkg:cargo/parc"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/parc"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0134.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/hyyking/rustracts/pull/6"
    }
  ]
},"270":{
  "id": "RUSTSEC-2020-0071",
  "modified": "2021-10-19T22:13:58Z",
  "published": "2020-11-18T12:00:00Z",
  "aliases": [
    "CVE-2020-26235"
  ],
  "related": [],
  "summary": "Potential segfault in the time crate",
  "details": "### Impact\n\nUnix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.\n\nThe affected functions from time 0.2.7 through 0.2.22 are:\n\n- `time::UtcOffset::local_offset_at`\n- `time::UtcOffset::try_local_offset_at`\n- `time::UtcOffset::current_local_offset`\n- `time::UtcOffset::try_current_local_offset`\n- `time::OffsetDateTime::now_local`\n- `time::OffsetDateTime::try_now_local`\n\nThe affected functions in time 0.1 (all versions) are:\n\n- `at`\n- `at_utc`\n- `now`\n\nNon-Unix targets (including Windows and wasm) are unaffected.\n\n### Patches\n\nPending a proper fix, the internal method that determines the local offset has been modified to always return `None` on the affected operating systems. This has the effect of returning an `Err` on the `try_*` methods and `UTC` on the non-`try_*` methods.\n\nUsers and library authors with time in their dependency tree should perform `cargo update`, which will pull in the updated, unaffected code.\n\nUsers of time 0.1 do not have a patch and should upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.\n\n### Workarounds\n\nNo workarounds are known.\n\n### References\n\ntime-rs/time#293",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "time",
        "purl": "pkg:cargo/time"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "linux",
            "unknown",
            "unknown",
            "android",
            "ios",
            "macos",
            "netbsd",
            "openbsd",
            "unknown",
            "freebsd"
          ],
          "functions": [
            "time::OffsetDateTime::now_local",
            "time::OffsetDateTime::try_now_local",
            "time::UtcOffset::current_local_offset",
            "time::UtcOffset::local_offset_at",
            "time::UtcOffset::try_current_local_offset",
            "time::UtcOffset::try_local_offset_at",
            "time::at",
            "time::at_utc",
            "time::now"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.0"
            },
            {
              ">=": "0.2.1-0","<": "0.2.1"
            },
            {
              ">=": "0.2.2-0","<": "0.2.2"
            },
            {
              ">=": "0.2.3-0","<": "0.2.3"
            },
            {
              ">=": "0.2.4-0","<": "0.2.4"
            },
            {
              ">=": "0.2.5-0","<": "0.2.5"
            },
            {
              ">=": "0.2.6-0","<": "0.2.6"
            },
            {
              ">=": "0.2.7-0","<": "0.2.23"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/time"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0071.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/time-rs/time/issues/293"
    }
  ]
},"271":{
  "id": "RUSTSEC-2020-0122",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-10-28T12:00:00Z",
  "aliases": [
    "CVE-2020-36442"
  ],
  "related": [],
  "summary": "beef::Cow lacks a Sync bound on its Send trait allowing for data races",
  "details": "Affected versions of this crate did not have a `T: Sync` bound in the `Send` impl for `Cow<'_, T, U>`. This allows users to create data races by making `Cow` contain types that are (Send && !Sync) like `Cell<_>` or `RefCell<_>`.\n\nSuch data races can lead to memory corruption.\n\nThe flaw was corrected in commit d1c7658 by adding trait bounds `T: Sync` and `T::Owned: Send` to the `Send` impl for `Cow<'_, T, U>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "beef",
        "purl": "pkg:cargo/beef"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/beef"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0122.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/maciejhirsz/beef/issues/37"
    }
  ]
},"272":{
  "id": "RUSTSEC-2020-0088",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-29T12:00:00Z",
  "aliases": [
    "CVE-2020-35925"
  ],
  "related": [],
  "summary": "MPMCConsumer/Producer allows sending non-Send type across threads",
  "details": "Affected versions of this crate unconditionally implemented `Sync` and `Send` traits for `MPMCConsumer` and `MPMCProducer` types.\n\nThis allows users to send types that do not implement `Send` trait across thread boundaries, which can cause a data race.\n\nThe flaw was corrected in the 2.0.1 release by adding `T: Send` bound to affected Sync/Send trait implementations.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "magnetic",
        "purl": "pkg:cargo/magnetic"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/magnetic"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0088.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/johnshaw/magnetic/issues/9"
    }
  ]
},"273":{
  "id": "RUSTSEC-2020-0067",
  "modified": "2020-11-02T14:50:19Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `qp2p`",
  "details": "This crate has been renamed from `quic-p2p` to `qp2p`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/qp2p>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "quic-p2p",
        "purl": "pkg:cargo/quic-p2p"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/quic-p2p"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0067.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/qp2p/pull/141"
    }
  ]
},"274":{
  "id": "RUSTSEC-2018-0006",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-09-17T12:00:00Z",
  "aliases": [
    "CVE-2018-20993"
  ],
  "related": [],
  "summary": "Uncontrolled recursion leads to abort in deserialization",
  "details": "Affected versions of this crate did not prevent deep recursion while\ndeserializing data structures.\n\nThis allows an attacker to make a YAML file with deeply nested structures\nthat causes an abort while deserializing it.\n\nThe flaw was corrected by checking the recursion depth.\n\nNote: `clap 2.33` is not affected by this because it uses `yaml-rust`\nin a way that doesn't trigger the vulnerability. More specifically:\n\n1. The input to the YAML parser is always trusted - is included at compile\ntime via `include_str!`.\n\n2. The nesting level is never deep enough to trigger the overflow in practice\n(at most 5).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "yaml-rust",
        "purl": "pkg:cargo/yaml-rust"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/yaml-rust"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0006.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/chyh1990/yaml-rust/pull/109"
    }
  ]
},"275":{
  "id": "RUSTSEC-2021-0094",
  "modified": "2021-08-22T01:46:40Z",
  "published": "2021-02-03T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Window can read out of bounds if Read instance returns more bytes than buffer size",
  "details": "`rdiff` performs a diff of two provided strings or files. As part of its reading\ncode it uses the return value of a `Read` instance to set the length of\nits internal character vector.\n\nIf the `Read` implementation claims that it has read more bytes than the length\nof the provided buffer, the length of the vector will be set to longer than its\ncapacity. This causes `rdiff` APIs to return uninitialized memory in its API\nmethods.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rdiff",
        "purl": "pkg:cargo/rdiff"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rdiff"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0094.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/dyule/rdiff/issues/3"
    }
  ]
},"276":{
  "id": "RUSTSEC-2020-0030",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-08-18T12:00:00Z",
  "aliases": [
    "CVE-2020-35883"
  ],
  "related": [],
  "summary": "Missing sanitazion in mozwire allows local file overwrite of files ending in .conf",
  "details": "The client software downloaded a list of servers from mozilla's servers and created local files named\nafter the hostname field in the json document.\n\nNo verification of the content of the string was made, and it could therefore have included '../' leading to path traversal.\n\nThis allows an attacker in control of mozilla's servers to overwrite/create local files named .conf.\n\nThe flaw was corrected by sanitizing the hostname field.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "mozwire",
        "purl": "pkg:cargo/mozwire"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.2-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/mozwire"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0030.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/NilsIrl/MozWire/issues/14"
    }
  ]
},"277":{
  "id": "RUSTSEC-2019-0036",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-11-13T12:00:00Z",
  "aliases": [
    "CVE-2020-25575",
    "CVE-2019-25010"
  ],
  "related": [],
  "summary": "Type confusion if __private_get_type_id__ is overridden",
  "details": "Safe Rust code can implement malfunctioning `__private_get_type_id__` and cause\ntype confusion when downcasting, which is an undefined behavior.\n\nUsers who derive `Fail` trait are not affected.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "failure",
        "purl": "pkg:cargo/failure"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "failure::Fail::__private_get_type_id__"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/failure"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0036.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-lang-nursery/failure/issues/336"
    }
  ]
},"278":{
  "id": "RUSTSEC-2021-0112",
  "modified": "2021-09-18T21:35:48Z",
  "published": "2021-02-17T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`Read` on uninitialized buffer may cause UB ('tectonic_xdv' crate)",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer. Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe problem was fixed in commit `cdff034` by zero-initializing the buffer before passing it to a user-provided `Read` implementation.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tectonic_xdv",
        "purl": "pkg:cargo/tectonic_xdv"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.12"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tectonic_xdv"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0112.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tectonic-typesetting/tectonic/issues/752"
    }
  ]
},"279":{
  "id": "RUSTSEC-2021-0057",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-05-01T12:00:00Z",
  "aliases": [
    "CVE-2021-23840"
  ],
  "related": [],
  "summary": "Integer overflow in CipherUpdate",
  "details": "Calls to `EVP_CipherUpdate`, `EVP_EncryptUpdate` and `EVP_DecryptUpdate` may overflow\nthe output length argument in some cases where the input length is close to the\nmaximum permissable length for an integer on the platform. In such cases the\nreturn value from the function call will be 1 (indicating success), but the\noutput length value will be negative. This could cause applications to behave\nincorrectly or crash.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "openssl-src",
        "purl": "pkg:cargo/openssl-src"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "111.14.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/openssl-src"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0057.html"
    },
    {
      "type": "WEB",
      "url": "https://www.openssl.org/news/secadv/20210216.txt"
    }
  ]
},"280":{
  "id": "RUSTSEC-2022-0002",
  "modified": "2022-02-06T17:02:38Z",
  "published": "2022-01-10T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Unsoundness in `dashmap` references",
  "details": "Reference returned by some methods of `Ref` (and similar types) may outlive the `Ref` and escape the lock.\nThis causes undefined behavior and may result in a segfault.\n\nMore information in [`dashmap#167`](https://github.com/xacrimon/dashmap/issues/167) issue.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "dashmap",
        "purl": "pkg:cargo/dashmap"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "dashmap::mapref::multiple::RefMulti::key",
            "dashmap::mapref::multiple::RefMulti::pair",
            "dashmap::mapref::multiple::RefMulti::value",
            "dashmap::mapref::multiple::RefMutMulti::key",
            "dashmap::mapref::multiple::RefMutMulti::pair",
            "dashmap::mapref::multiple::RefMutMulti::pair_mut",
            "dashmap::mapref::one::Ref::key",
            "dashmap::mapref::one::Ref::pair",
            "dashmap::mapref::one::Ref::value",
            "dashmap::mapref::one::RefMut::key",
            "dashmap::mapref::one::RefMut::pair",
            "dashmap::mapref::one::RefMut::pair_mut",
            "dashmap::setref::multiple::RefMulti::key",
            "dashmap::setref::one::Ref::key"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure",
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "5.0.0","<": "5.1.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/dashmap"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0002.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/xacrimon/dashmap/issues/167"
    }
  ]
},"281":{
  "id": "RUSTSEC-2020-0159",
  "modified": "2021-10-18T16:19:09Z",
  "published": "2020-11-10T12:00:00Z",
  "aliases": [],
  "related": [
    "CVE-2020-26235",
    "RUSTSEC-2020-0071"
  ],
  "summary": "Potential segfault in `localtime_r` invocations",
  "details": "### Impact\n\nUnix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.\n\n### Workarounds\n\nNo workarounds are known.\n\n### References\n\n- [time-rs/time#293](https://github.com/time-rs/time/issues/293)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "chrono",
        "purl": "pkg:cargo/chrono"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/chrono"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0159.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/chronotope/chrono/issues/499"
    }
  ]
},"282":{
  "id": "RUSTSEC-2021-0104",
  "modified": "2021-09-10T16:01:55Z",
  "published": "2021-05-27T12:00:00Z",
  "aliases": [
    "CVE-2021-31153",
    "GHSA-f3fg-5j9p-vchc"
  ],
  "related": [],
  "summary": "File exposure in pleaser",
  "details": "pleaser before 0.4 allows a local unprivileged attacker to gain knowledge about the existence of files or directories in privileged locations via the search_path function, the --check option, or the -d option.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "pleaser",
        "purl": "pkg:cargo/pleaser"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "file-disclosure"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/pleaser"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0104.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31153"
    }
  ]
},"283":{
  "id": "RUSTSEC-2021-0041",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-03-18T12:00:00Z",
  "aliases": [
    "CAN-2021-1000007",
    "CVE-2021-29932"
  ],
  "related": [],
  "summary": "Denial of service through parsing payloads with too big exponent",
  "details": "The `parse_duration::parse` function allows for parsing duration strings with exponents like `5e5s` where under the hood, the [`BigInt` type along with the `pow` function are used for such payloads](https://github.com/zeta12ti/parse_duration/blob/26940ab5cd4e3a9d6bd97aa101f8d4bbfd18ee8c/src/parse.rs#L335). Passing an arbitrarily big exponent makes the `parse_duration::parse` function to process the payload for a very long time taking up CPU and memory.\n\nThis allows an attacker to cause a DoS if the `parse_duration::parse` function is used to process untrusted input.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "parse_duration",
        "purl": "pkg:cargo/parse_duration"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "parse_duration::parse"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/parse_duration"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0041.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/zeta12ti/parse_duration/issues/21"
    }
  ]
},"284":{
  "id": "RUSTSEC-2021-0016",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-26T12:00:00Z",
  "aliases": [
    "CVE-2021-26952"
  ],
  "related": [],
  "summary": "`IoReader::read()`: user-provided `Read` on uninitialized buffer may cause UB",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.\n\nThe flaw was fixed in commit 599313b by zero-initializing the buffer (via `self.buf.resize(len, 0)`) before passing it to `Read`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ms3d",
        "purl": "pkg:cargo/ms3d"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ms3d"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0016.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/andrewhickman/ms3d/issues/1"
    }
  ]
},"285":{
  "id": "RUSTSEC-2019-0020",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-09-06T12:00:00Z",
  "aliases": [
    "CVE-2019-16144"
  ],
  "related": [],
  "summary": "fix unsound APIs that could lead to UB",
  "details": "Affected versions of this crate API could use uninitialized memory with some APIs in special\ncases, like use the API in none generator context. This could lead to UB.\nThe flaw was corrected by <https://github.com/Xudong-Huang/generator-rs/issues/9>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/11>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/13>\n                          <https://github.com/Xudong-Huang/generator-rs/issues/14>                                                  \nThis patch fixes all those issues above.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "generator",
        "purl": "pkg:cargo/generator"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.18"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/generator"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0020.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Xudong-Huang/generator-rs/issues/9"
    }
  ]
},"286":{
  "id": "RUSTSEC-2020-0118",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-08T12:00:00Z",
  "aliases": [
    "CVE-2020-36438"
  ],
  "related": [],
  "summary": "Future<T> lacks bounds on Send and Sync.",
  "details": "`tiny_future` contains a light-weight implementation of `Future`s. The `Future`\ntype it has lacked bound on its `Send` and `Sync` traits.\n\nThis allows for a bug where non-thread safe types such as `Cell` can be used in\n`Future`s and cause data races in concurrent programs.\n\nThe flaw was corrected in commit `c791919` by adding trait bounds to `Future`'s\n`Send` and `Sync`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tiny_future",
        "purl": "pkg:cargo/tiny_future"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tiny_future"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0118.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/KizzyCode/tiny_future/issues/1"
    }
  ]
},"287":{
  "id": "RUSTSEC-2020-0056",
  "modified": "2020-10-25T18:57:46Z",
  "published": "2020-05-04T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "stdweb is unmaintained",
  "details": "The author of the `stdweb` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)\n- [`js-sys`](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys)\n- [`web-sys`](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stdweb",
        "purl": "pkg:cargo/stdweb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.21-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stdweb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0056.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/koute/stdweb/issues/403"
    }
  ]
},"288":{
  "id": "RUSTSEC-2020-0113",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-10-31T12:00:00Z",
  "aliases": [
    "CVE-2020-36219"
  ],
  "related": [],
  "summary": "AtomicOption should have Send + Sync bound on its type argument.",
  "details": "In the affected versions of this crate,\n`AtomicOption<T>` unconditionally implements `Sync`.\n\nThis allows programmers to move non-Sync types across thread boundaries (e.g. `Rc<T>`, `Arc<Cell<T>>`), which can lead to data races and undefined behavior. \nIt is also possible to send non-Send types like `std::sync::MutexGuard` to other threads, which can lead to undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "atomic-option",
        "purl": "pkg:cargo/atomic-option"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/atomic-option"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0113.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/reem/rust-atomic-option/issues/4"
    }
  ]
},"289":{
  "id": "RUSTSEC-2020-0001",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-01-06T12:00:00Z",
  "aliases": [
    "CVE-2020-35857"
  ],
  "related": [],
  "summary": "Stack overflow when resolving additional records from MX or SRV null targets",
  "details": "There's a stack overflow leading to a crash and potential DOS when processing\nadditional records for return of MX or SRV record types from the server.\n\nThis is only possible when a zone is configured with a null target for MX or SRV records, i.e. '.'.\n\nExample effected zone record:\n```text\nno-service 86400 IN MX 0 .\n```\n\nPrior to 0.16.0 the additional record processing was not supported by trust-dns-server. There\nAre no known issues with upgrading from 0.16 or 0.17 to 0.18.1. The remidy should be to upgrade to\n0.18.1. If unable to do so, MX, SRV or other record types with a target to the null type, should be avoided.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "trust-dns-server",
        "purl": "pkg:cargo/trust-dns-server"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.16.0","<": "0.18.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/trust-dns-server"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0001.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bluejekyll/trust-dns/issues/980"
    }
  ]
},"290":{
  "id": "RUSTSEC-2020-0144",
  "modified": "2021-02-10T18:27:15Z",
  "published": "2020-02-10T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "lzw is unmaintained",
  "details": "The author of the `lzw` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`weezl`](https://crates.io/crates/weezl)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "lzw",
        "purl": "pkg:cargo/lzw"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.10.1-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/lzw"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0144.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/nwin/lzw/issues/2"
    }
  ]
},"291":{
  "id": "RUSTSEC-2021-0119",
  "modified": "2021-10-08T16:17:22Z",
  "published": "2021-09-27T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Out-of-bounds write in nix::unistd::getgrouplist",
  "details": "On certain platforms, if a user has more than 16 groups, the\n`nix::unistd::getgrouplist` function will call the libc `getgrouplist`\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.\n\nThe libc `getgrouplist` function takes an in/out parameter `ngroups`\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify `ngroups`\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of `nix::unistd::getgrouplist` in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the `ngroups` variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n`getgrouplist` will then write past the end of the buffer.\n\nThe issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "nix",
        "purl": "pkg:cargo/nix"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "linux",
            "freebsd",
            "android",
            "netbsd",
            "dragonfly",
            "openbsd",
            "fuchsia"
          ],
          "functions": [
            "nix::unistd::getgrouplist"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.16.0","<": "0.20.2"
            },
            {
              ">=": "0.21.0-0","<": "0.21.2"
            },
            {
              ">=": "0.22.0-0","<": "0.22.2"
            },
            {
              ">=": "0.23.0-0","<": "0.23.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/nix"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0119.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/nix-rust/nix/issues/1541"
    }
  ]
},"292":{
  "id": "RUSTSEC-2022-0009",
  "modified": "2022-02-07T14:18:27Z",
  "published": "2022-02-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Failure to verify the public key of a `SignedEnvelope` against the `PeerId` in a `PeerRecord`",
  "details": "Affected versions of this crate did not check that the public key the signature was created with matches the peer ID of the peer record. \nAny combination was considered valid.\n\nThis allows an attacker to republish an existing `PeerRecord` with a different `PeerId`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libp2p-core",
        "purl": "pkg:cargo/libp2p-core"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "libp2p_core::PeerRecord::from_signed_envelope"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.30.0-rc.1","<": "0.30.2"
            },
            {
              ">=": "0.31.0-0","<": "0.31.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libp2p-core"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0009.html"
    }
  ]
},"293":{
  "id": "RUSTSEC-2018-0021",
  "modified": "2021-06-09T01:07:22Z",
  "published": "2018-06-15T12:00:00Z",
  "aliases": [
    "GHSA-ghpq-vjxw-ch5w"
  ],
  "related": [],
  "summary": "Use-after-free with objects returned by `Stream`'s `get_format_info` and `get_context` methods",
  "details": "Affected versions contained a pair of use-after-free issues with the objects returned by the `get_format_info` and `get_context` methods of `Stream` objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libpulse-binding",
        "purl": "pkg:cargo/libpulse-binding"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "libpulse_binding::stream::Stream::get_context",
            "libpulse_binding::stream::Stream::get_format_info"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.2.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libpulse-binding"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0021.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w"
    }
  ]
},"294":{
  "id": "RUSTSEC-2020-0017",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-28T12:00:00Z",
  "aliases": [
    "CVE-2020-35874"
  ],
  "related": [],
  "summary": "Use after free in ArcIntern::drop",
  "details": "`ArcIntern::drop` has a race condition where it can release memory\nwhich is about to get another user. The new user will get a reference\nto freed memory.\n\nThis was fixed by serializing access to an interned object while it\nis being deallocated.\n\nVersions prior to 0.3.12 used stronger locking which avoided the problem.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "internment",
        "purl": "pkg:cargo/internment"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "internment::ArcIntern::drop"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.3.12","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/internment"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0017.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/droundy/internment/issues/11"
    }
  ]
},"295":{
  "id": "RUSTSEC-2020-0152",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-18T12:00:00Z",
  "aliases": [
    "CVE-2020-36472"
  ],
  "related": [],
  "summary": "ImmediateIO and TransactionalIO can cause data races",
  "details": "The `ImmediateIO` and `TransactionalIO` types implement `Sync` for all contained\n`Expander<EI>` types regardless of if the `Expander` itself is safe to use\nacross threads.\n\nAs the `IO` types allow retrieving the `Expander`, this can lead to non-thread\nsafe types being sent across threads as part of the `Expander` leading to data\nraces.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "max7301",
        "purl": "pkg:cargo/max7301"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/max7301"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0152.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/edarc/max7301/issues/1"
    }
  ]
},"296":{
  "id": "RUSTSEC-2020-0040",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-03T12:00:00Z",
  "aliases": [
    "CVE-2020-35894"
  ],
  "related": [],
  "summary": "Obstack generates unaligned references",
  "details": "Obstack generates unaligned references for types that require a large alignment.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "obstack",
        "purl": "pkg:cargo/obstack"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/obstack"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0040.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/petertodd/rust-obstack/issues/4"
    }
  ]
},"297":{
  "id": "RUSTSEC-2020-0105",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-21T12:00:00Z",
  "aliases": [
    "CVE-2020-36212",
    "CVE-2020-36213"
  ],
  "related": [],
  "summary": "Update unsound DrainFilter and RString::retain",
  "details": "Affected versions of this crate contained code from the Rust standard library that contained soundness bugs rust-lang/rust#60977 (double drop) & rust-lang/rust#78498 (create invalid utf-8 string).\n\nThe flaw was corrected in v0.9.1 by making a similar fix to the one made in the Rust standard library.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "abi_stable",
        "purl": "pkg:cargo/abi_stable"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/abi_stable"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0105.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rodrimati1992/abi_stable_crates/issues/44"
    }
  ]
},"298":{
  "id": "RUSTSEC-2021-0070",
  "modified": "2021-11-06T20:37:35Z",
  "published": "2021-06-06T12:00:00Z",
  "aliases": [
    "CVE-2021-38190"
  ],
  "related": [],
  "summary": "VecStorage Deserialize Allows Violation of Length Invariant",
  "details": "The `Deserialize` implementation for `VecStorage` did not maintain the invariant that the number of elements must equal `nrows * ncols`. Deserialization of specially crafted inputs could allow memory access beyond allocation of the vector.\n\nThis flaw was introduced in v0.11.0 ([`086e6e`](https://github.com/dimforge/nalgebra/commit/086e6e719f53fecba6dadad2e953a487976387f5)) due to the addition of an automatically derived implementation of `Deserialize` for `MatrixVec`. `MatrixVec` was later renamed to `VecStorage` in v0.16.13 ([`0f66403`](https://github.com/dimforge/nalgebra/commit/0f66403cbbe9eeac15cedd8a906c0d6a3d8841f2)) and continued to use the automatically derived implementation of `Deserialize`.\n\nThis flaw was corrected in commit [`5bff536`](https://github.com/dimforge/nalgebra/commit/5bff5368bf38ddfa31416e4ae9897b163031a513) by returning an error during deserialization if the number of elements does not exactly match the expected size.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "nalgebra",
        "purl": "pkg:cargo/nalgebra"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.11.0","<": "0.27.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/nalgebra"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0070.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/dimforge/nalgebra/issues/883"
    }
  ]
},"299":{
  "id": "RUSTSEC-2021-0135",
  "modified": "2022-01-22T15:22:46Z",
  "published": "2021-01-21T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Improper validation of Windows paths could lead to directory traversal attack",
  "details": "`tower_http::services::fs::ServeDir` didn't correctly validate Windows paths\nmeaning paths like `/foo/bar/c:/windows/web/screen/img101.png` would be allowed\nand respond with the contents of `c:/windows/web/screen/img101.png`. Thus users\ncould potentially read files anywhere on the filesystem.\n\nThis only impacts Windows. Linux and other unix likes are not impacted by this.\n\nSee [tower-http#204] for more details.\n\n[tower-http#204]: https://github.com/tower-rs/tower-http/pull/204",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tower-http",
        "purl": "pkg:cargo/tower-http"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "file-disclosure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.3"
            },
            {
              ">=": "0.2.0","<": "0.2.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tower-http"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0135.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/tower-rs/tower-http/pull/204"
    }
  ]
},"300":{
  "id": "RUSTSEC-2021-0027",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-07T12:00:00Z",
  "aliases": [
    "CVE-2021-28027"
  ],
  "related": [],
  "summary": "Loading a bgzip block can write out of bounds if size overflows.",
  "details": "Affected versions of `bam` set the length of an internal buffer using\n`self.compressed.set_len(block_size - HEADER_SIZE - MIN_EXTRA_SIZE)` and then\nwrote into it. While `block_size` was constrained to a proper maximum, when it\nwas too small the subtraction could overflow negatively to a large number past\nthe capacity of `self.compressed`.\n\nThis can result in memory corruption in the form of writing out of bounds when\nloading a `bgzip` file with a small `block_size`.\n\nCommit `061eee38d4` fixed this issue by checking for the underflow when setting\nthe buffer size.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bam",
        "purl": "pkg:cargo/bam"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "bam::bgzip::Block::load"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bam"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0027.html"
    },
    {
      "type": "REPORT",
      "url": "https://gitlab.com/tprodanov/bam/-/issues/4"
    }
  ]
},"301":{
  "id": "RUSTSEC-2016-0003",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2016-08-01T12:00:00Z",
  "aliases": [
    "CVE-2016-10933"
  ],
  "related": [],
  "summary": "HTTP download and execution allows MitM RCE",
  "details": "The build script in the portaudio crate will attempt to download via HTTP\nthe portaudio source and build it.\n\nA Mallory in the middle can intercept the download with their own archive\nand get RCE.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "portaudio",
        "purl": "pkg:cargo/portaudio"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/portaudio"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2016-0003.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustAudio/rust-portaudio/issues/144"
    }
  ]
},"302":{
  "id": "RUSTSEC-2020-0083",
  "modified": "2020-12-07T17:22:02Z",
  "published": "2020-12-07T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been superseded by `sn_client`",
  "details": "This crate has been superseded by `sn_client`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_client>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "safe_app",
        "purl": "pkg:cargo/safe_app"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/safe_app"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0083.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_client/pull/1267"
    }
  ]
},"303":{
  "id": "RUSTSEC-2020-0129",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-18T12:00:00Z",
  "aliases": [
    "CVE-2020-36449"
  ],
  "related": [],
  "summary": "ShmWriter allows sending non-Send type across threads",
  "details": "Affected versions of this crate implement `Send` for `ShmWriter<H>` without requiring `H: Send`. This allows users to send `H: !Send` to other threads, which can potentially lead to data races and undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "kekbit",
        "purl": "pkg:cargo/kekbit"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/kekbit"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0129.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/motoras/kekbit/issues/34"
    }
  ]
},"304":{
  "id": "RUSTSEC-2019-0011",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-07-16T12:00:00Z",
  "aliases": [
    "CVE-2019-15553"
  ],
  "related": [],
  "summary": "Flaw in offset_of and span_of causes SIGILL, drops uninitialized memory of arbitrary type on panic in client code",
  "details": "Affected versions of this crate caused traps and/or memory unsafety by zero-initializing references.\nThey also could lead to uninitialized memory being dropped if the field for which the offset is requested was behind a deref coercion, and that deref coercion caused a panic.\n\nThe flaw was corrected by using `MaybeUninit`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "memoffset",
        "purl": "pkg:cargo/memoffset"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/memoffset"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0011.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Gilnaa/memoffset/issues/9#issuecomment-505461490"
    }
  ]
},"305":{
  "id": "RUSTSEC-2021-0031",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-31T12:00:00Z",
  "aliases": [
    "CVE-2021-28032"
  ],
  "related": [],
  "summary": "split_at allows obtaining multiple mutable references to the same data",
  "details": "Affected versions of this crate assumed that `Borrow<Idx>` was guaranteed to\nreturn the same value on `.borrow()`. The borrowed index value was used to\nretrieve a mutable reference to a value.\n\nIf the `Borrow<Idx>` implementation returned a different index, the split arena\nwould allow retrieving the index as a mutable reference creating two mutable\nreferences to the same element. This violates Rust's aliasing rules and allows\nfor memory safety issues such as writing out of bounds and use-after-frees.\n\nThe flaw was corrected in commit `6b83f9d` by storing the `.borrow()` value in\na temporary variable.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "nano_arena",
        "purl": "pkg:cargo/nano_arena"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "nano_arena::Arena::split_at",
            "nano_arena::ArenaSplit::split_at"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/nano_arena"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0031.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bennetthardwick/nano-arena/issues/1"
    }
  ]
},"306":{
  "id": "RUSTSEC-2020-0095",
  "modified": "2021-01-24T19:50:18Z",
  "published": "2020-12-20T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "difference is unmaintained",
  "details": "The author of the `difference` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`dissimilar`](https://crates.io/crates/dissimilar)\n\n- [`similar`](https://crates.io/crates/similar)\n\n- [`treediff`](https://crates.io/crates/treediff)\n\n- [`diffus`](https://crates.io/crates/diffus)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "difference",
        "purl": "pkg:cargo/difference"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "2.0.1-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/difference"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0095.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/johannhof/difference.rs/issues/45"
    }
  ]
},"307":{
  "id": "RUSTSEC-2019-0007",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-06-13T12:00:00Z",
  "aliases": [
    "CVE-2019-15549"
  ],
  "related": [],
  "summary": "Processing of maliciously crafted length fields causes memory allocation SIGABRTs",
  "details": "Affected versions of this crate tried to preallocate a vector for an arbitrary amount of bytes announced by the ASN.1-DER length field without further checks.\n\nThis allows an attacker to trigger a SIGABRT by creating length fields that announce more bytes than the allocator can provide.\n \nThe flaw was corrected by not preallocating memory.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "asn1_der",
        "purl": "pkg:cargo/asn1_der"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/asn1_der"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0007.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/KizzyCode/asn1_der/issues/1"
    }
  ]
},"308":{
  "id": "RUSTSEC-2021-0066",
  "modified": "2021-05-12T01:59:58Z",
  "published": "2021-05-11T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Denial of service on EVM execution due to memory over-allocation",
  "details": "Prior to the patch, when executing specific EVM opcodes related\nto memory operations that use `evm_core::Memory::copy_large`, the\ncrate can over-allocate memory when it is not needed, making it\npossible for an attacker to perform denial-of-service attack.\n\nThe flaw was corrected in commit `19ade85`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "evm-core",
        "purl": "pkg:cargo/evm-core"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.21.1"
            },
            {
              ">=": "0.22.0-0","<": "0.23.1"
            },
            {
              ">=": "0.24.0-0","<": "0.24.1"
            },
            {
              ">=": "0.25.0-0","<": "0.25.1"
            },
            {
              ">=": "0.26.0-0","<": "0.26.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/evm-core"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0066.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-blockchain/evm"
    }
  ]
},"309":{
  "id": "RUSTSEC-2021-0123",
  "modified": "2021-11-15T13:53:17Z",
  "published": "2021-11-14T12:00:00Z",
  "aliases": [
    "CVE-2021-43620"
  ],
  "related": [],
  "summary": "Converting `NSString` to a String Truncates at Null Bytes",
  "details": "Methods of [`NSString`] for conversion to a string may return a partial result.\nSince they call [`CStr::from_ptr`] on a pointer to the string buffer, the\nstring is terminated at the first null byte, which might not be the end of the\nstring.\n\nIn addition to the vulnerable functions listed for this issue, the\nimplementations of [`Display`], [`PartialEq`], [`PartialOrd`], and [`ToString`]\nfor [`NSString`] are also affected, since they call those functions.\n\n## Impact\n\nSince [`NSString`] is commonly used as the type for paths by the [Foundation]\nframework, null byte truncation might allow for easily bypassing file extension\nchecks. For example, if a file name is provided by a user and validated to have\none of a specific set of extensions, with validation taking place before\ntruncation, an attacker can add an accepted extension after a null byte (e.g.,\n`file.exe\\0.txt`). After truncation, the file name used by the application\nwould be `file.exe`.\n\nIt would be better to generate unique names for files, instead of using\nuser-provided names, but not all applications take this approach.\n\n## Example:\n\n```rust\nlet string = NSString::from_str(\"null\\0byte\");\nprintln!(\"{}\", string);\n```\n\nThat example only prints the string \"null\".\n\n[`CStr::from_ptr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_ptr\n[`Display`]: https://doc.rust-lang.org/std/fmt/trait.Display.html\n[Foundation]: https://developer.apple.com/documentation/foundation\n[`NSString`]: https://docs.rs/fruity/0.2.0/fruity/foundation/struct.NSString.html\n[`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n[`PartialOrd`]: https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html\n[`ToString`]: https://doc.rust-lang.org/std/string/trait.ToString.html",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "fruity",
        "purl": "pkg:cargo/fruity"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "fruity::foundation::NSString::to_str",
            "fruity::foundation::NSString::to_str_with_nul",
            "fruity::foundation::NSString::to_string",
            "fruity::foundation::NSString::to_string_with_nul"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/fruity"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0123.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/nvzqz/fruity/issues/14"
    }
  ]
},"310":{
  "id": "RUSTSEC-2021-0089",
  "modified": "2021-08-22T09:43:52Z",
  "published": "2021-01-20T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Optional `Deserialize` implementations lacking validation",
  "details": "When activating the non-default feature `serialize`, most structs implement\n`serde::Deserialize` without sufficient validation. This allows breaking\ninvariants in safe code, leading to:\n\n* Undefined behavior in `as_string()` methods (which use\n  `std::str::from_utf8_unchecked()` internally).\n* Panics due to failed assertions.\n\nSee https://github.com/gz/rust-cpuid/issues/43.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "raw-cpuid",
        "purl": "pkg:cargo/raw-cpuid"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "3.1.1-0","<": "9.1.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/raw-cpuid"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0089.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gz/rust-cpuid/issues/43"
    }
  ]
},"311":{
  "id": "RUSTSEC-2019-0027",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-10-14T12:00:00Z",
  "aliases": [
    "CVE-2019-25003"
  ],
  "related": [],
  "summary": "Flaw in Scalar::check_overflow allows side-channel timing attack",
  "details": "Versions of `libsecp256k1` prior to `0.3.1` did not execute\nScalar::check_overflow in constant time.\n\nThis allows an attacker to potentially leak information via a timing attack.\n\nThe flaw was corrected by modifying Scalar::check_overflow to execute in\nconstant time.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libsecp256k1",
        "purl": "pkg:cargo/libsecp256k1"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "libsecp256k1::Scalar::check_overflow"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libsecp256k1"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0027.html"
    }
  ]
},"312":{
  "id": "RUSTSEC-2021-0011",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-04T12:00:00Z",
  "aliases": [
    "CVE-2021-25908"
  ],
  "related": [],
  "summary": "EventList's From<EventList> conversions can double drop on panic.",
  "details": "Affected versions of this crate read from a container using `ptr::read` in\n`From<EventList>`, and then call a user specified `Into<Event>` function.\n\nThis issue can result in a double-free if the user provided function panics.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "fil-ocl",
        "purl": "pkg:cargo/fil-ocl"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.12.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/fil-ocl"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0011.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/cogciprocate/ocl/issues/194"
    }
  ]
},"313":{
  "id": "RUSTSEC-2020-0148",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36466",
    "CVE-2020-36467",
    "CVE-2020-36468"
  ],
  "related": [],
  "summary": "Multiple soundness issues in `Ptr`",
  "details": "Affected versions of this crate have the following issues:\n\n1. `Ptr` implements `Send` and `Sync` for all types, this can lead to data\n   races by sending non-thread safe types across threads.\n\n2. `Ptr::get` violates mutable alias rules by returning multiple mutable\n   references to the same object.\n\n3. `Ptr::write` uses non-atomic writes to the underlying pointer. This means\n   that when used across threads it can lead to data races.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cgc",
        "purl": "pkg:cargo/cgc"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cgc"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0148.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/playXE/cgc/issues/5"
    }
  ]
},"314":{
  "id": "RUSTSEC-2021-0103",
  "modified": "2021-09-10T16:10:58Z",
  "published": "2021-07-30T12:00:00Z",
  "aliases": [
    "GHSA-82hm-vh7g-hrh9"
  ],
  "related": [],
  "summary": " Partial read is incorrect in molecule",
  "details": "Anyone who uses total_size(..) function to partial read the length of any FixVec will get an incorrect result, due to an incorrect implementation. This has been resolved in the 0.7.2 release.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "molecule",
        "purl": "pkg:cargo/molecule"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/molecule"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0103.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/nervosnetwork/molecule/security/advisories/GHSA-82hm-vh7g-hrh9"
    }
  ]
},"315":{
  "id": "RUSTSEC-2021-0046",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-17T12:00:00Z",
  "aliases": [
    "CVE-2021-29937"
  ],
  "related": [],
  "summary": "misc::vec_with_size() can drop uninitialized memory if clone panics",
  "details": "`misc::vec_with_size` creates a vector of the provided `size` and immediately\ncalls `vec.set_len(size)` on it, initially filling it with uninitialized memory.\nIt then inserts elements using `vec[i] = value.clone()`.\n\nIf the `value.clone()` call panics, uninitialized items in the vector will be\ndropped leading to undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "telemetry",
        "purl": "pkg:cargo/telemetry"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/telemetry"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0046.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Yoric/telemetry.rs/issues/45"
    }
  ]
},"316":{
  "id": "RUSTSEC-2022-0013",
  "modified": "2022-03-08T15:14:30Z",
  "published": "2022-03-08T12:00:00Z",
  "aliases": [
    "CVE-2022-24713"
  ],
  "related": [],
  "summary": "Regexes with large repetitions on empty sub-expressions take a very long time to parse",
  "details": "The Rust Security Response WG was notified that the `regex` crate did not\nproperly limit the complexity of the regular expressions (regex) it parses. An\nattacker could use this security issue to perform a denial of service, by\nsending a specially crafted regex to a service accepting untrusted regexes. No\nknown vulnerability is present when parsing untrusted input with trusted\nregexes.\n\nThis issue has been assigned CVE-2022-24713. The severity of this vulnerability\nis \"high\" when the `regex` crate is used to parse untrusted regexes. Other uses\nof the `regex` crate are not affected by this vulnerability.\n\n## Overview\n\nThe `regex` crate features built-in mitigations to prevent denial of service\nattacks caused by untrusted regexes, or untrusted input matched by trusted\nregexes. Those (tunable) mitigations already provide sane defaults to prevent\nattacks. This guarantee is documented and it's considered part of the crate's\nAPI.\n\nUnfortunately a bug was discovered in the mitigations designed to prevent\nuntrusted regexes to take an arbitrary amount of time during parsing, and it's\npossible to craft regexes that bypass such mitigations. This makes it possible\nto perform denial of service attacks by sending specially crafted regexes to\nservices accepting user-controlled, untrusted regexes.\n\n## Affected versions\n\nAll versions of the `regex` crate before or equal to 1.5.4 are affected by this\nissue. The fix is include starting from  `regex` 1.5.5.\n\n## Mitigations\n\nWe recommend everyone accepting user-controlled regexes to upgrade immediately\nto the latest version of the `regex` crate.\n\nUnfortunately there is no fixed set of problematic regexes, as there are\npractically infinite regexes that could be crafted to exploit this\nvulnerability. Because of this, we do not recommend denying known problematic\nregexes.\n\n## Acknowledgements\n\nWe want to thank Addison Crump for responsibly disclosing this to us according\nto the [Rust security policy][1], and for helping review the fix.\n\nWe also want to thank Andrew Gallant for developing the fix, and Pietro Albini\nfor coordinating the disclosure and writing this advisory.\n\n[1]: https://www.rust-lang.org/policies/security",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "regex",
        "purl": "pkg:cargo/regex"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.5.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/regex"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0013.html"
    },
    {
      "type": "WEB",
      "url": "https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw"
    }
  ]
},"317":{
  "id": "RUSTSEC-2021-0115",
  "modified": "2021-10-12T15:24:09Z",
  "published": "2021-09-24T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`#[zeroize(drop)]` doesn't implement `Drop` for `enum`s",
  "details": "Affected versions of this crate did not implement `Drop` when `#[zeroize(drop)]` was used on an `enum`.\n\nThis can result in memory not being zeroed out after dropping it, which is exactly what is intended when adding this attribute.\n\nThe flaw was corrected in version 1.2 and `#[zeroize(drop)]` on `enum`s now properly implements `Drop`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "zeroize_derive",
        "purl": "pkg:cargo/zeroize_derive"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.1.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/zeroize_derive"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0115.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/iqlusioninc/crates/issues/876"
    }
  ]
},"318":{
  "id": "RUSTSEC-2022-0005",
  "modified": "2022-01-22T18:27:42Z",
  "published": "2022-01-22T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `ftdi-embedded-hal`",
  "details": "This crate has been renamed from `ftd2xx-embedded-hal` to `ftdi-embedded-hal`.\n\nThe new repository location is:\n\n<https://github.com/ftdi-rs/ftdi-embedded-hal>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ftd2xx-embedded-hal",
        "purl": "pkg:cargo/ftd2xx-embedded-hal"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ftd2xx-embedded-hal"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0005.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/newAM/ftd2xx-embedded-hal/pull/40"
    }
  ]
},"319":{
  "id": "RUSTSEC-2021-0050",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-24T12:00:00Z",
  "aliases": [
    "CVE-2021-29941",
    "CVE-2021-29942"
  ],
  "related": [],
  "summary": "swap_index can write out of bounds and return uninitialized memory",
  "details": "`swap_index` takes an iterator and swaps the items with their corresponding\nindexes. It reserves capacity and sets the length of the vector based on the\n`.len()` method of the iterator.\n\nIf the `len()` returned by the iterator is larger than the actual number of\nelements yielded, then `swap_index` creates a vector containing uninitialized\nmembers. If the `len()` returned by the iterator is smaller than the actual\nnumber of members yielded, then `swap_index` can write out of bounds past\nits allocated vector.\n\nAs noted by the Rust documentation, [`len()`](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len)\nand `size_hint()` are primarily meant for optimization and incorrect values\nfrom their implementations should not lead to memory safety violations.\n\n\n# Patch\n\nA new version crate was pushed that marks this function as unsafe.\n\nreorder = \"1.1.0\"\n\nPrevious versions have also been yanked from crates.io.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "reorder",
        "purl": "pkg:cargo/reorder"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.1.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/reorder"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0050.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/tiby312/reorder/issues/1"
    }
  ]
},"320":{
  "id": "RUSTSEC-2019-0031",
  "modified": "2021-06-29T22:08:30Z",
  "published": "2019-11-21T12:00:00Z",
  "withdrawn": "2020-10-08T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "spin is no longer actively maintained",
  "details": "The author of the `spin` crate does not have time or interest to maintain it.\n\nConsider the following alternatives (all of which support `no_std`):\n\n- [`conquer-once`](https://github.com/oliver-giersch/conquer-once)\n- [`lock_api`](https://crates.io/crates/lock_api) (a subproject of `parking_lot`)\n  - [`spinning_top`](https://github.com/rust-osdev/spinning_top) spinlock crate built on `lock_api`\n- [`spinning`](https://github.com/4lDO2/spinning-rs)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "spin",
        "purl": "pkg:cargo/spin"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.0.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/spin"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0031.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/mvdnes/spin-rs/commit/7516c80"
    }
  ]
},"321":{
  "id": "RUSTSEC-2020-0109",
  "modified": "2021-01-20T19:29:04Z",
  "published": "2020-12-22T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "stderr is unmaintained; use eprintln instead",
  "details": "The `stderr` crate is no longer maintained by its current owner. \n\nThe author recommends using the `eprintln` macro from the standard library as a\nreplacement.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stderr",
        "purl": "pkg:cargo/stderr"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stderr"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0109.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/biluohc/stderr/issues/5"
    }
  ]
},"322":{
  "id": "RUSTSEC-2021-0007",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-07T12:00:00Z",
  "aliases": [
    "CVE-2021-25904"
  ],
  "related": [],
  "summary": "`Frame::copy_from_raw_parts` can lead to segfault without `unsafe`",
  "details": "`fn Frame::copy_from_raw_parts()` is a safe API that can take a\nraw pointer and dereference it. It is possible to read arbitrary memory address\nwith an arbitrarily fed pointer. This allows the safe API to access & read\narbitrary address in memory. Feeding an invalid memory address pointer to\nthe API may also cause the program to segfault.\n\nThe flaw was corrected in https://github.com/rust-av/rust-av/pull/137,\nby removing the API `fn Frame::copy_from_raw_parts()`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "av-data",
        "purl": "pkg:cargo/av-data"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure",
          "privilege-escalation"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/av-data"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0007.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-av/rust-av/issues/136"
    }
  ]
},"323":{
  "id": "RUSTSEC-2020-0037",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-08-31T12:00:00Z",
  "aliases": [
    "CVE-2020-35889"
  ],
  "related": [],
  "summary": "Misbehaving `HandleLike` implementation can lead to memory safety violation",
  "details": "Unsafe code in `ObjectPool` has time-of-check to time-of-use (TOCTOU) bug that\ncan eventually lead to a memory safety violation. `ObjectPool` and `HandlePool`\nimplicitly assumes that `HandleLike` trait methods are pure, i.e., they always\nreturn the same value. However, this assumption is unsound since `HandleLike`\nis a safe, public trait that allows a custom implementation.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "crayon",
        "purl": "pkg:cargo/crayon"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/crayon"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0037.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/shawnscode/crayon/issues/87"
    }
  ]
},"324":{
  "id": "RUSTSEC-2018-0001",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-06-21T12:00:00Z",
  "aliases": [
    "CVE-2018-20989"
  ],
  "related": [],
  "summary": "An integer underflow could lead to panic",
  "details": "A mistake in error handling in untrusted before 0.6.2 could lead to an integer\nunderflow and panic if a user of the crate didn't properly check for errors\nreturned by untrusted.\n\nCombination of these two programming errors (one in untrusted and another by\nuser of this crate) could lead to a panic and maybe a denial of service of\naffected software.\n\nThe error in untrusted is fixed in release 0.6.2 released 2018-06-21. It's also\nadvisable that users of untrusted check for their sources for cases where errors\nreturned by untrusted are not handled correctly.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "untrusted",
        "purl": "pkg:cargo/untrusted"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/untrusted"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0001.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/briansmith/untrusted/pull/20"
    }
  ]
},"325":{
  "id": "RUSTSEC-2021-0093",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-07-30T12:00:00Z",
  "aliases": [
    "GHSA-pqqp-xmhj-wgcw",
    "CVE-2021-32810"
  ],
  "related": [],
  "summary": "Data race in crossbeam-deque",
  "details": "In the affected version of this crate, the result of the race condition is that one or more tasks in the worker queue can be popped twice instead of other tasks that are forgotten and never popped. If tasks are allocated on the heap, this can cause double free and a memory leak. If not, this still can cause a logical bug.\n\nCrates using `Stealer::steal`, `Stealer::steal_batch`, or `Stealer::steal_batch_and_pop` are affected by this issue.\n\nCredits to @kmaork for discovering, reporting and fixing the bug.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "crossbeam-deque",
        "purl": "pkg:cargo/crossbeam-deque"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.4"
            },
            {
              ">=": "0.8.0","<": "0.8.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/crossbeam-deque"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0093.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/crossbeam-rs/crossbeam/security/advisories/GHSA-pqqp-xmhj-wgcw"
    }
  ]
},"326":{
  "id": "RUSTSEC-2020-0125",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-24T12:00:00Z",
  "aliases": [
    "CVE-2020-36445"
  ],
  "related": [],
  "summary": "convec::ConVec<T> unconditionally implements Send/Sync",
  "details": "Affected versions of this crate unconditionally implement Send/Sync for `ConVec<T>`.\nThis allows users to insert `T` that is not Send or not Sync.\n\nThis allows users to create data races by using non-Send types like `Arc<Cell<_>>` or `Rc<_>` as `T` in `ConVec<T>`. It is also possible to create data races by using types like `Cell<_>` or `RefCell<_>` as `T` (types that are `Send` but not `Sync`).\nSuch data races can lead to memory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "convec",
        "purl": "pkg:cargo/convec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/convec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0125.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/krl/convec/issues/2"
    }
  ]
},"327":{
  "id": "RUSTSEC-2020-0060",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-04T12:00:00Z",
  "aliases": [
    "CVE-2020-35906"
  ],
  "related": [],
  "summary": "futures_task::waker may cause a use-after-free if used on a type that isn't 'static",
  "details": "Affected versions of the crate did not properly implement a `'static` lifetime bound on the `waker` function.\nThis resulted in a use-after-free if `Waker::wake()` is called after original data had been dropped.\n\nThe flaw was corrected by adding `'static` lifetime bound to the data `waker` takes.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "futures-task",
        "purl": "pkg:cargo/futures-task"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "futures_task::waker"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.2.2-0","<": "0.3.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/futures-task"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0060.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-lang/futures-rs/pull/2206"
    }
  ]
},"328":{
  "id": "RUSTSEC-2020-0099",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-10T12:00:00Z",
  "aliases": [
    "CVE-2020-36207"
  ],
  "related": [],
  "summary": "Aovec<T> lacks bound on its Send and Sync traits allowing data races",
  "details": "`aovec::Aovec<T>` is a vector type that implements `Send` and `Sync` for all\ntypes `T`.\n\nThis allows non-Send types such as `Rc` and non-Sync types such as `Cell` to\nbe used across thread boundaries which can trigger undefined behavior and\nmemory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "aovec",
        "purl": "pkg:cargo/aovec"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/aovec"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0099.html"
    }
  ]
},"329":{
  "id": "RUSTSEC-2020-0133",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-15T12:00:00Z",
  "aliases": [
    "CVE-2020-36453"
  ],
  "related": [],
  "summary": "Queue<T> should have a Send bound on its Send/Sync traits",
  "details": "Affected versions of this crate unconditionally implements `Send`/`Sync` for `Queue<T>`.\n\nThis allows (1) creating data races to a `T: !Sync` and (2) sending `T: !Send` to other threads, resulting in memory corruption or other undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "scottqueue",
        "purl": "pkg:cargo/scottqueue"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/scottqueue"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0133.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rossdylan/rust-scottqueue/issues/1"
    }
  ]
},"330":{
  "id": "RUSTSEC-2020-0076",
  "modified": "2020-12-02T17:59:27Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `sn_routing`",
  "details": "This crate has been renamed from `routing` to `sn_routing`.\n\nThe new repository location is:\n\n<https://github.com/maidsafe/sn_routing>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "routing",
        "purl": "pkg:cargo/routing"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/routing"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0076.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/maidsafe/sn_routing/pull/2190"
    }
  ]
},"331":{
  "id": "RUSTSEC-2017-0005",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2017-05-06T12:00:00Z",
  "aliases": [
    "CVE-2017-18589"
  ],
  "related": [],
  "summary": "Large cookie Max-Age values can cause a denial of service",
  "details": "Affected versions of this crate use the `time` crate and the method\n`Duration::seconds` to parse the `Max-Age` duration cookie setting. This method\nwill panic if the value is greater than 2^64/1000 and less than or equal to\n2^64, which can result in denial of service for a client or server.\n\nThis flaw was corrected by explicitly checking for the `Max-Age` being in this\ninteger range and clamping the value to the maximum duration value.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cookie",
        "purl": "pkg:cargo/cookie"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.6.0","<": "0.6.2"
            },
            {
              ">=": "0.7.0-0","<": "0.7.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cookie"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0005.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/alexcrichton/cookie-rs/pull/86"
    }
  ]
},"332":{
  "id": "RUSTSEC-2020-0021",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-11T12:00:00Z",
  "aliases": [
    "CVE-2020-35876"
  ],
  "related": [],
  "summary": "rio allows a use-after-free buffer access when a future is leaked",
  "details": "When a `rio::Completion` is leaked, its drop code will not run. The drop code\nis responsible for waiting until the kernel completes the I/O operation into, or\nout of, the buffer borrowed by `rio::Completion`. Leaking the struct will allow\none to access and/or drop the buffer, which can lead to a use-after-free,\ndata races or leaking secrets.\n\nUpstream is not interested in fixing the issue.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rio",
        "purl": "pkg:cargo/rio"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rio"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0021.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/spacejam/rio/issues/11"
    }
  ]
},"333":{
  "id": "RUSTSEC-2018-0017",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2018-02-13T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`tempdir` crate has been deprecated; use `tempfile` instead",
  "details": "The [`tempdir`](https://crates.io/crates/tempdir) crate has been deprecated\nand the functionality is merged into [`tempfile`](https://crates.io/crates/tempfile).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "tempdir",
        "purl": "pkg:cargo/tempdir"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/tempdir"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0017.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-lang-deprecated/tempdir/pull/46"
    }
  ]
},"334":{
  "id": "RUSTSEC-2021-0085",
  "modified": "2021-08-22T01:23:35Z",
  "published": "2021-01-03T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "'Read' on uninitialized memory may cause UB",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. The crate currently contains 4 occurrences of such cases.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "binjs_io",
        "purl": "pkg:cargo/binjs_io"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/binjs_io"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0085.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/binast/binjs-ref/issues/460"
    }
  ]
},"335":{
  "id": "RUSTSEC-2018-0016",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2018-06-30T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "quickersort is deprecated and unmaintained",
  "details": "The author of the `quickersort` crate has deprecated it and does not recommend using it anymore.\n\nEverything in it has been incorporated into [std::sort_unstable] in the standard library as of Rust 1.20.\n\n[std::sort_unstable]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.sort_unstable",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "quickersort",
        "purl": "pkg:cargo/quickersort"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "3.0.2-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/quickersort"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0016.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/notriddle/quickersort/commit/0bc164366315801f0c6b31f4081b7df9fc894076"
    }
  ]
},"336":{
  "id": "RUSTSEC-2021-0084",
  "modified": "2021-08-22T01:20:01Z",
  "published": "2021-01-03T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`Read` on uninitialized buffer can cause UB (impl of `ReadKVExt`)",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bronzedb-protocol",
        "purl": "pkg:cargo/bronzedb-protocol"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bronzedb-protocol"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0084.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Hexilee/BronzeDB/issues/1"
    }
  ]
},"337":{
  "id": "RUSTSEC-2017-0004",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2017-05-03T12:00:00Z",
  "aliases": [
    "CVE-2017-1000430"
  ],
  "related": [],
  "summary": "Integer overflow leads to heap-based buffer overflow in encode_config_buf",
  "details": "Affected versions of this crate suffered from an integer overflow bug when\ncalculating the size of a buffer to use when encoding base64 using the\n`encode_config_buf` and `encode_config` functions.  If the input string\nwas large, this would cause a buffer to be allocated that was too small.\nSince this function writes to the buffer using unsafe code, it would\nallow an attacker to write beyond the buffer, causing memory corruption\nand possibly the execution of arbitrary code.\n\nThis flaw was corrected by using checked arithmetic to calculate\nthe size of the buffer.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "base64",
        "purl": "pkg:cargo/base64"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/base64"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2017-0004.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/alicemaz/rust-base64/commit/24ead980daf11ba563e4fb2516187a56a71ad319"
    }
  ]
},"338":{
  "id": "RUSTSEC-2020-0020",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2020-04-18T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`stb_truetype` crate has been deprecated; use `ttf-parser` instead",
  "details": "This crate was maintained for use in rusttype which has switched to use [ttf-parser](https://crates.io/crates/ttf-parser)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "stb_truetype",
        "purl": "pkg:cargo/stb_truetype"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/stb_truetype"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0020.html"
    },
    {
      "type": "WEB",
      "url": "https://gitlab.redox-os.org/redox-os/stb_truetype-rs/-/commit/f1f5be4794e87bfc80a4255bc3f23ed75dd77645"
    }
  ]
},"339":{
  "id": "RUSTSEC-2020-0098",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-18T12:00:00Z",
  "aliases": [
    "CVE-2020-36206"
  ],
  "related": [],
  "summary": "UsbContext trait did not require implementers to be Send and Sync.",
  "details": "Affected versions of `rusb` did not require `UsbContext` to implement `Send`\nand `Sync`. However, through `Device` and `DeviceHandle` it is possible to use\n`UsbContext`s across threads.\n\nThis issue allows non-thread safe `UsbContext` types to be used concurrently\nleading to data races and memory corruption.\n\nThe issue was fixed by adding `Send` and `Sync` bounds to `UsbContext`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rusb",
        "purl": "pkg:cargo/rusb"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rusb"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0098.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/a1ien/rusb/issues/44"
    }
  ]
},"340":{
  "id": "RUSTSEC-2020-0132",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-31T12:00:00Z",
  "aliases": [
    "CVE-2020-36452"
  ],
  "related": [],
  "summary": "`FixedCapacityDequeLike::clone()` can cause dropping uninitialized memory",
  "details": "Affected versions of this crate don't guard against panics, so that partially uninitialized buffer is dropped when user-provided `T::clone()` panics in `FixedCapacityDequeLike<T, A>::clone()`. This causes memory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "array-tools",
        "purl": "pkg:cargo/array-tools"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.2"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/array-tools"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0132.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/L117/array-tools/issues/2"
    }
  ]
},"341":{
  "id": "RUSTSEC-2020-0077",
  "modified": "2020-12-02T19:15:42Z",
  "published": "2020-12-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "memmap is unmaintained",
  "details": "The author of the `memmap` crate is unresponsive.\n\nMaintained alternatives:\n\n- [`mapr`](https://github.com/filecoin-project/mapr)\n- [`memmap2`](https://github.com/RazrFalcon/memmap2-rs)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "memmap",
        "purl": "pkg:cargo/memmap"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.1-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/memmap"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0077.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/danburkert/memmap-rs/issues/90"
    }
  ]
},"342":{
  "id": "RUSTSEC-2020-0124",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-08T12:00:00Z",
  "aliases": [
    "CVE-2020-36444"
  ],
  "related": [],
  "summary": "ArcGuard's Send and Sync should have bounds on RC",
  "details": "Affected versions of this crate implement Send/Sync for `ArcGuard<RC, T>` with no trait bounds on `RC`. This allows users to send `RC: !Send` to other threads and also allows users to concurrently access `Rc: !Sync` from multiple threads.\n\nThis can result in memory corruption from data race or other undefined behavior caused by sending `T: !Send` to other threads (e.g. dropping `MutexGuard<T>` in another thread that didn't lock its mutex).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "async-coap",
        "purl": "pkg:cargo/async-coap"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/async-coap"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0124.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/google/rust-async-coap/issues/33"
    }
  ]
},"343":{
  "id": "RUSTSEC-2020-0061",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-03T12:00:00Z",
  "aliases": [
    "CVE-2020-35907"
  ],
  "related": [],
  "summary": "futures_task::noop_waker_ref can segfault due to dereferencing a NULL pointer",
  "details": "Affected versions of the crate used a `UnsafeCell` in thread-local storage to return a noop waker reference,\nassuming that the reference would never be returned from another thread.\n\nThis resulted in a segmentation fault crash if `Waker::wake_by_ref()` was called on a waker returned from another thread due to \nit attempting to dereference a pointer that wasn't accessible from the main thread.\n\nReproduction Example (from issue):\n```rust\nuse futures_task::noop_waker_ref;\nfn main() {\n    let waker = std::thread::spawn(|| noop_waker_ref()).join().unwrap();\n    waker.wake_by_ref();\n}\n```\n\nThe flaw was corrected by using a `OnceCell::Lazy<>` wrapper around the noop waker instead of thread-local storage.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "futures-task",
        "purl": "pkg:cargo/futures-task"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "futures_task::noop_waker_ref"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/futures-task"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0061.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/rust-lang/futures-rs/issues/2091"
    }
  ]
},"344":{
  "id": "RUSTSEC-2021-0092",
  "modified": "2021-08-22T01:41:04Z",
  "published": "2021-01-26T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Deserialization functions pass uninitialized memory to user-provided Read",
  "details": "Affected versions of this crate passed an uninitialized buffer to a\nuser-provided `Read` instance in:\n\n* `deserialize_binary`\n* `deserialize_string`\n* `deserialize_extension_others`\n* `deserialize_string_primitive`\n\nThis can result in safe `Read` implementations reading from the uninitialized\nbuffer leading to undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "messagepack-rs",
        "purl": "pkg:cargo/messagepack-rs"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/messagepack-rs"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0092.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/otake84/messagepack-rs/issues/2"
    }
  ]
},"345":{
  "id": "RUSTSEC-2020-0036",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-05-02T12:00:00Z",
  "aliases": [
    "CVE-2020-25575"
  ],
  "related": [],
  "summary": "failure is officially deprecated/unmaintained",
  "details": "The `failure` crate is officially end-of-life: it has been marked as deprecated\nby the former maintainer, who has announced that there will be no updates or\nmaintenance work on it going forward.\n\nThe following are some suggested actively developed alternatives to switch to:\n\n- [`anyhow`](https://crates.io/crates/anyhow)\n- [`eyre`](https://crates.io/crates/eyre)\n- [`fehler`](https://crates.io/crates/fehler)\n- [`snafu`](https://crates.io/crates/snafu)\n- [`thiserror`](https://crates.io/crates/thiserror)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "failure",
        "purl": "pkg:cargo/failure"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/failure"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0036.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/rust-lang-nursery/failure/pull/347"
    }
  ]
},"346":{
  "id": "RUSTSEC-2021-0006",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-01T12:00:00Z",
  "aliases": [
    "CVE-2021-25903"
  ],
  "related": [],
  "summary": "Exposes internally used raw pointer",
  "details": "Affected versions of this crate dereference a raw pointer that can be modified\nwithout using `unsafe` code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cache",
        "purl": "pkg:cargo/cache"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cache"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0006.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/krl/cache/issues/2"
    }
  ]
},"347":{
  "id": "RUSTSEC-2019-0030",
  "modified": "2021-01-04T17:02:59Z",
  "published": "2019-10-06T12:00:00Z",
  "aliases": [
    "CVE-2020-25575",
    "CVE-2019-25006",
    "CVE-2019-25007"
  ],
  "related": [],
  "summary": "Incorrect implementation of the Streebog hash functions",
  "details": "Internal `update-sigma` function was implemented incorrectly and depending on\n`debug-assertions` it could've caused an incorrect result or panic for certain\ninputs.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "streebog",
        "purl": "pkg:cargo/streebog"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.8.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/streebog"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0030.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/hashes/pull/91"
    }
  ]
},"348":{
  "id": "RUSTSEC-2020-0108",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-20T12:00:00Z",
  "aliases": [
    "CVE-2020-36216"
  ],
  "related": [],
  "summary": "Soundness issue: Input<R> can be misused to create data race to an object",
  "details": "`Input<R>` implements `Send` without requiring `R: Send`.\n\nAffected versions of this crate allows users to send non-Send types to other threads,\nwhich can lead to undefined behavior such as data race and memory corruption.\n\nThe flaw was corrected in version 0.5.1 by adding `R: Send` bound to the `Send` impl of `Input<R>`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "eventio",
        "purl": "pkg:cargo/eventio"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.5.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/eventio"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0108.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/petabi/eventio/issues/33"
    }
  ]
},"349":{
  "id": "RUSTSEC-2021-0114",
  "modified": "2021-09-23T20:26:20Z",
  "published": "2021-09-23T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Aliased mutable references from `tls_rand` & `TlsWyRand`",
  "details": "`TlsWyRand`'s implementation of `Deref` unconditionally dereferences a raw pointer, and returns \nmultiple mutable references to the same object, which is undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "nanorand",
        "purl": "pkg:cargo/nanorand"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "nanorand::tls::tls_rand"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.5.0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/nanorand"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0114.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Absolucy/nanorand-rs/issues/28"
    }
  ]
},"350":{
  "id": "RUSTSEC-2021-0051",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-31T12:00:00Z",
  "aliases": [
    "CVE-2021-30454"
  ],
  "related": [],
  "summary": "KeyValueReader passes uninitialized memory to Read instance",
  "details": "The `KeyValueReader` type in affected versions of this crate set up an\nuninitialized memory buffer and passed them to be read in to a user-provided\n`Read` instance.\n\nThe `Read` instance could read uninitialized memory and cause undefined\nbehavior and miscompilations.\n\nThis issue was fixed in commit [dd59b30](https://github.com/SolraBizna/outer_cgi/commit/dd59b3066e616a08e756f72de8dc3ab11b7036c4)\nby zero-initializing the buffers before passing them.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "outer_cgi",
        "purl": "pkg:cargo/outer_cgi"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/outer_cgi"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0051.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/SolraBizna/outer_cgi/issues/1"
    }
  ]
},"351":{
  "id": "RUSTSEC-2022-0004",
  "modified": "2022-01-21T18:16:26Z",
  "published": "2022-01-01T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Stack overflow in rustc_serialize when parsing deeply nested JSON",
  "details": "When parsing JSON using `json::Json::from_str`, there is no limit to the depth of the stack, therefore deeply nested objects can cause a stack overflow, which aborts the process.\n\nExample code that triggers the vulnerability is\n\n```rust\nfn main() {\n    let _ = rustc_serialize::json::Json::from_str(&\"[0,[\".repeat(10000));\n}\n```\n\n[serde](https://crates.io/crates/serde) is recommended as a replacement to rustc_serialize.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rustc-serialize",
        "purl": "pkg:cargo/rustc-serialize"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "rustc_serialize::json::Json::from_str"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "denial-of-service"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rustc-serialize"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0004.html"
    }
  ]
},"352":{
  "id": "RUSTSEC-2021-0102",
  "modified": "2021-09-10T15:58:05Z",
  "published": "2021-05-27T12:00:00Z",
  "aliases": [
    "CVE-2021-31154",
    "GHSA-pp74-39w2-v4w9"
  ],
  "related": [],
  "summary": "Permissions bypass in pleaser",
  "details": "pleaseedit in pleaser before 0.4 uses predictable temporary filenames in /tmp and the target directory. This allows a local attacker to gain full root privileges by staging a symlink attack.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "pleaser",
        "purl": "pkg:cargo/pleaser"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "privilege-escalation"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/pleaser"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0102.html"
    },
    {
      "type": "WEB",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-31154"
    }
  ]
},"353":{
  "id": "RUSTSEC-2022-0012",
  "modified": "2022-03-04T18:17:34Z",
  "published": "2022-03-04T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Arrow2 allows double free in `safe` code",
  "details": "The struct `Ffi_ArrowArray` implements `#derive(Clone)` that is inconsistent with\nits custom implementation of `Drop`, resulting in a double free when cloned.\n\nCloning this struct in `safe` results in a segmentation fault, which is unsound.\n\nThis derive was removed from this struct. All users are advised to either:\n* bump the patch version of this crate (for versions `v0.7,v0.8,v0.9`), or\n* migrate to a more recent version of  the crate (when using `<0.7`).\n\nDoing so elimitates this vulnerability (code no longer compiles).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arrow2",
        "purl": "pkg:cargo/arrow2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.7.1"
            },
            {
              ">=": "0.8.0","<": "0.8.2"
            },
            {
              ">=": "0.9.0","<": "0.9.2"
            },
            {
              ">=": "0.10.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arrow2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0012.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/jorgecarleitao/arrow2/issues/880"
    }
  ]
},"354":{
  "id": "RUSTSEC-2021-0047",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-19T12:00:00Z",
  "aliases": [
    "CVE-2021-29938"
  ],
  "related": [],
  "summary": "SliceDeque::drain_filter can double drop an element if the predicate panics",
  "details": "Affected versions of the crate incremented the current index of the drain filter\niterator *before* calling the predicate function `self.pred`.\n\nIf the predicate function panics, it is possible for the last element in the\niterator to be dropped twice.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "slice-deque",
        "purl": "pkg:cargo/slice-deque"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/slice-deque"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0047.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/gnzlbg/slice_deque/issues/90"
    }
  ]
},"355":{
  "id": "RUSTSEC-2020-0149",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-15T12:00:00Z",
  "aliases": [
    "CVE-2020-36469"
  ],
  "related": [],
  "summary": "Data race and memory safety issue in `Index`",
  "details": "The `appendix` crate implements a key-value mapping data structure called\n`Index<K, V>` that is stored on disk. The crate allows for any type to inhabit\nthe generic `K` and `V` type parameters and implements Send and Sync for them\nunconditionally.\n\nUsing a type that is not marked as `Send` or `Sync` with `Index` can allow it\nto be used across multiple threads leading to data races. Additionally using\nreference types for the keys or values will lead to the segmentation faults\nin the crate's code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "appendix",
        "purl": "pkg:cargo/appendix"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/appendix"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0149.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/krl/appendix/issues/6"
    }
  ]
},"356":{
  "id": "RUSTSEC-2021-0010",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-01-12T12:00:00Z",
  "aliases": [
    "CVE-2021-25907"
  ],
  "related": [],
  "summary": "panic safety: double drop may happen within `util::{mutate, mutate2}`",
  "details": "Upon panic in a user-provided function `f`, `fn mutate()` & `fn mutate2` drops twice a same object.\n\nAffected versions of this crate did not guard against double drop while temporarily duplicating an object's ownership with `ptr::read()`.\n\nDropping a same object can result in memory corruption.\n\nThe flaw was corrected in version \"0.9.11\" by fixing the code to abort upon panic.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "containers",
        "purl": "pkg:cargo/containers"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.11"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/containers"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0010.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/strake/containers.rs/issues/2"
    }
  ]
},"357":{
  "id": "RUSTSEC-2019-0026",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-10-11T12:00:00Z",
  "aliases": [
    "CVE-2019-25002"
  ],
  "related": [],
  "summary": "generichash::Digest::eq always return true",
  "details": "PartialEq implementation for generichash::Digest has compared itself to itself.\n\nDigest::eq always returns true and Digest::ne always returns false.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "sodiumoxide",
        "purl": "pkg:cargo/sodiumoxide"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "sodiumoxide::crypto::generichash::Digest::eq",
            "sodiumoxide::crypto::generichash::Digest::ne"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.2.5"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/sodiumoxide"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0026.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/sodiumoxide/sodiumoxide/pull/381"
    }
  ]
},"358":{
  "id": "RUSTSEC-2021-0067",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-05-21T12:00:00Z",
  "aliases": [
    "CVE-2021-32629",
    "GHSA-hpqh-2wqx-7qp5"
  ],
  "related": [],
  "summary": "Memory access due to code generation flaw in Cranelift module",
  "details": "There is a bug in 0.73.0 of the Cranelift x64 backend that can create a\nscenario that could result in a potential sandbox escape in a WebAssembly\nmodule. Users of versions 0.73.0 of Cranelift should upgrade to either 0.73.1\nor 0.74 to remediate this vulnerability. Users of Cranelift prior to 0.73.0\nshould update to 0.73.1 or 0.74 if they were not using the old default backend.\n\nMore details can be found in the GitHub Security Advisory at:\n\n<https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cranelift-codegen",
        "purl": "pkg:cargo/cranelift-codegen"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [
            "x86"
          ],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "code-execution",
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.73.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cranelift-codegen"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0067.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5"
    }
  ]
},"359":{
  "id": "RUSTSEC-2021-0122",
  "modified": "2021-11-07T17:53:20Z",
  "published": "2021-10-31T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Generated code can read and write out of bounds in safe code",
  "details": "Code generated by flatbuffers' compiler is `unsafe` but not marked as such.\nSee https://github.com/google/flatbuffers/issues/6627 for details.\n\nAll users that use generated code by `flatbuffers` compiler are recommended to:\n1. not expose flatbuffer generated code as part of their public APIs\n2. audit their code and look for any usage of `follow`, `push`, or any method that uses them\n   (e.g. `self_follow`).\n3. Carefuly go through the crates' documentation to understand which \"safe\" APIs are not\n   intended to be used.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "flatbuffers",
        "purl": "pkg:cargo/flatbuffers"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/flatbuffers"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0122.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/google/flatbuffers/issues/6627"
    }
  ]
},"360":{
  "id": "RUSTSEC-2021-0088",
  "modified": "2021-08-22T01:34:42Z",
  "published": "2021-01-05T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`Read` on uninitialized memory may cause UB (fn preamble_skipcount())",
  "details": "Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (within `fn preamble_skipcount()`).\n\nArbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "csv-sniffer",
        "purl": "pkg:cargo/csv-sniffer"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/csv-sniffer"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0088.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/jblondin/csv-sniffer/issues/1"
    }
  ]
},"361":{
  "id": "RUSTSEC-2020-0094",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-01T12:00:00Z",
  "aliases": [
    "CVE-2020-36203"
  ],
  "related": [],
  "summary": "Unsound: can make `ARefss` contain a !Send, !Sync object.",
  "details": "`ARefss<'a, V>` is a type that is assumed to contain objects that are `Send + Sync`.\n\nIn the affected versions of this crate,\n`Send`/`Sync` traits are unconditionally implemented for `ARefss<'a, V>`.\n\nBy using the `ARefss::map()` API, we can insert a `!Send` or `!Sync` object into `ARefss<'a, V>`. After that, it is possible to create a data race to the inner object of `ARefss<'a, V>`, which can lead to undefined behavior & memory corruption.\n\nThe flaw was corrected in commit 6dd7ca0 (https://github.com/diwic/reffers-rs/commit/6dd7ca0d50f2464df708975cdafcfaeeb6d41c66) by adding trait bound `V: Send + Sync` to `ARefss::map()` API.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "reffers",
        "purl": "pkg:cargo/reffers"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/reffers"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0094.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/diwic/reffers-rs/issues/7"
    }
  ]
},"362":{
  "id": "RUSTSEC-2019-0006",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2019-06-15T12:00:00Z",
  "aliases": [
    "CVE-2019-15547",
    "CVE-2019-15548"
  ],
  "related": [],
  "summary": "Buffer overflow and format vulnerabilities in functions exposed without unsafe",
  "details": "`ncurses` exposes functions from the ncurses library which:\n\n- Pass buffers without length to C functions that may write an arbitrary amount of\n  data, leading to a buffer overflow. (`instr`, `mvwinstr`, etc)\n- Passes rust &str to strings expecting C format arguments, allowing hostile\n  input to execute a format string attack, which trivially allows writing\n  arbitrary data to stack memory (functions in the `printw` family).",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ncurses",
        "purl": "pkg:cargo/ncurses"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "ncurses::instr",
            "ncurses::mvprintw",
            "ncurses::mvwinstr",
            "ncurses::mvwprintw",
            "ncurses::printw"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ncurses"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0006.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/RustSec/advisory-db/issues/106"
    }
  ]
},"363":{
  "id": "RUSTSEC-2021-0030",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-18T12:00:00Z",
  "aliases": [
    "CVE-2021-28031"
  ],
  "related": [],
  "summary": "move_elements can double-free objects on panic",
  "details": "Affected versions of `scratchpad` used `ptr::read` to read elements while\ncalling a user provided function `f` on them.\n\nSince the pointer read duplicates ownership, a panic inside the user provided\n`f` function could cause a double free when unwinding.\n\nThe flaw was fixed in commit `891561bea` by removing the unsafe block and using\na plain iterator.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "scratchpad",
        "purl": "pkg:cargo/scratchpad"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "scratchpad::SliceMoveSource::move_elements"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.3.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/scratchpad"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0030.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/okready/scratchpad/issues/1"
    }
  ]
},"364":{
  "id": "RUSTSEC-2020-0082",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-06T12:00:00Z",
  "aliases": [
    "CVE-2020-35923"
  ],
  "related": [],
  "summary": "ordered_float:NotNan may contain NaN after panic in assignment operators",
  "details": "After using an assignment operators such as `NotNan::add_assign`, `NotNan::mul_assign`, etc., it was possible for the resulting `NotNan` value to contain a `NaN`.  This could cause undefined behavior in safe code, because the safe `NotNan::cmp` method contains internal unsafe code that assumes the value is never `NaN`.  (It could also cause undefined behavior in third-party unsafe code that makes the same assumption, as well as logic errors in safe code.)\n\nThis was mitigated starting in version 0.4.0, by panicking if the assigned value is NaN.  However, in affected versions from 0.4.0 onward, code that uses the `NotNan` value during unwinding, or that continues after catching the panic, could still observe the invalid value and trigger undefined behavior.\n\nThe flaw is fully corrected in versions 1.1.1 and 2.0.1, by ensuring that the assignment operators panic without modifying the operand, if the result would be `NaN`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "ordered-float",
        "purl": "pkg:cargo/ordered-float"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.2.2","<": "1.1.1"
            },
            {
              ">=": "2.0.0-0","<": "2.0.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/ordered-float"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0082.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/reem/rust-ordered-float/pull/71"
    }
  ]
},"365":{
  "id": "RUSTSEC-2020-0128",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-24T12:00:00Z",
  "aliases": [
    "CVE-2020-36448"
  ],
  "related": [],
  "summary": "Cache<K>: Send/Sync impls needs trait bounds on `K`",
  "details": "Affected versions of this crate unconditionally implement Send/Sync for `Cache<K>`.\nThis allows users to insert `K` that is not Send or not Sync.\n\nThis allows users to create data races by using non-Send types like `Arc<Cell<T>>` or `Rc<T>` as `K` in `Cache<K>`. It is also possible to create data races by using types like `Cell<T>` or `RefCell<T>` (types that are `Send` but not `Sync`).\nSuch data races can lead to memory corruption.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "cache",
        "purl": "pkg:cargo/cache"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/cache"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0128.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/krl/cache/issues/1"
    }
  ]
},"366":{
  "id": "RUSTSEC-2019-0010",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2019-07-04T12:00:00Z",
  "aliases": [
    "CVE-2019-15552"
  ],
  "related": [],
  "summary": "MultiDecoder::read() drops uninitialized memory of arbitrary type on panic in client code",
  "details": "Affected versions of libflate have set a field of an internal structure with a generic type to an uninitialized value in `MultiDecoder::read()` and reverted it to the original value after the function completed. However, execution of `MultiDecoder::read()` could be interrupted by a panic in caller-supplied `Read` implementation. This would cause `drop()` to be called on uninitialized memory of a generic type implementing `Read`.\n\nThis is equivalent to a use-after-free vulnerability and could allow an attacker to gain arbitrary code execution.\n\nThe flaw was corrected by aborting immediately instead of unwinding the stack in case of panic within `MultiDecoder::read()`. The issue was discovered and fixed by Shnatsel.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libflate",
        "purl": "pkg:cargo/libflate"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "libflate::gzip::MultiDecoder::read"
          ]
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.14","<": "0.1.25"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libflate"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2019-0010.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/sile/libflate/issues/35"
    }
  ]
},"367":{
  "id": "RUSTSEC-2021-0026",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-02-21T12:00:00Z",
  "aliases": [
    "CVE-2021-27671"
  ],
  "related": [],
  "summary": "XSS in `comrak`",
  "details": "The [comrak](https://github.com/kivikakk/comrak) we were matching unsafe URL prefixes, such as `data:` or `javascript:` , in a case-sensitive manner. This meant prefixes like `Data:` were untouched.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "comrak",
        "purl": "pkg:cargo/comrak"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "format-injection"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/comrak"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0026.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/kivikakk/comrak/releases/tag/0.9.1"
    }
  ]
},"368":{
  "id": "RUSTSEC-2016-0002",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2016-05-09T12:00:00Z",
  "aliases": [
    "CVE-2016-10932"
  ],
  "related": [
    "RUSTSEC-2016-0001"
  ],
  "summary": "HTTPS MitM vulnerability due to lack of hostname verification",
  "details": "When used on Windows platforms, all versions of Hyper prior to 0.9.4 did not\nperform hostname verification when making HTTPS requests.\n\nThis allows an attacker to perform MitM attacks by preventing any valid\nCA-issued certificate, even if there's a hostname mismatch.\n\nThe problem was addressed by leveraging rust-openssl's built-in support for\nhostname verification.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "hyper",
        "purl": "pkg:cargo/hyper"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "crypto-failure"
        ],
        "cvss": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.9.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/hyper"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2016-0002.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/hyperium/hyper/blob/master/CHANGELOG.md#v094-2016-05-09"
    }
  ]
},"369":{
  "id": "RUSTSEC-2021-0071",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2021-06-12T12:00:00Z",
  "aliases": [
    "CVE-2021-3013"
  ],
  "related": [],
  "summary": "`grep-cli` may run arbitrary executables on Windows",
  "details": "On Windows in versions of `grep-cli` prior to `0.1.6`, it's possible for some\nof the routines to execute arbitrary executables. In particular, a quirk of\nthe Windows process execution API is that it will automatically consider the\ncurrent directory before other directories when resolving relative binary\nnames. Therefore, if you use `grep-cli` to read decompressed files in an\nuntrusted directory with that directory as the CWD, a malicious actor to could\nput, e.g., a `gz.exe` binary in that directory and `grep-cli` will use the\nmalicious actor's version of `gz.exe` instead of the system's.\n\nThis is also technically possible on Unix as well, but only if the `PATH`\nvariable contains `.`. Conventionally, they do not.\n\nA `DecompressionReader` has been fixed to automatically resolve binary names\nusing `PATH`, instead of relying on the Windows API to do it.\n\nIf you use `grep-cli`'s `CommandReader` with a `std::process::Command` value\non Windows, then it is recommended to either construct the `Command` with an\nabsolute binary name, or use `grep-cli`'s new\n[`resolve_binary`](https://docs.rs/grep-cli/0.1.6/grep_cli/fn.resolve_binary.html)\nhelper function.\n\nTo be clear, `grep-cli 0.1.6` mitigates this issue in two ways:\n\n* A `DecompressionReader` will resolve decompression programs to absolute\npaths automatically using the `PATH` environment variable, instead of relying\non Windows APIs to do it (which would result in the undesirable behavior of\nchecking the CWD for a program first).\n* A new function, `resolve_binary`, was added to help users of this crate\nmitigate this behavior when they need to create their own\n`std::process::Command`. For example,\n[ripgrep uses `grep_cli::resolve_binary`](https://github.com/BurntSushi/ripgrep/blob/7ce66f73cf7e76e9f2557922ac8e650eb02cf4ed/crates/core/search.rs#L119-L122)\non the argument given to its `--pre` flag.\n\nWhile the first mitigation fixes this issue for sensible values of `PATH`\nwhen doing decompression search, the second mitigation is imperfect. The more\nfundamental issue is that `std::process::Command` is itself vulnerable to this.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "grep-cli",
        "purl": "pkg:cargo/grep-cli"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": [
            "grep_cli::DecompressionReader::new"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "code-execution"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.1.6"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/grep-cli"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0071.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/BurntSushi/ripgrep/issues/1773"
    }
  ]
},"370":{
  "id": "RUSTSEC-2021-0134",
  "modified": "2022-03-06T11:02:04Z",
  "published": "2021-12-27T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "rental is unmaintained, author has moved on",
  "details": "The author encourages users to explore other solutions, or maintain a fork.\n\nMaintained alternatives include:\n\n* [`ouroboros`](https://crates.io/crates/ouroboros)\n* [`fortify`](https://crates.io/crates/fortify)\n* [`escher`](https://crates.io/crates/escher)",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "rental",
        "purl": "pkg:cargo/rental"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/rental"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0134.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/jpernst/rental/commit/213671ab3aab3452efd7e2290c6bb714ee327014"
    }
  ]
},"371":{
  "id": "RUSTSEC-2020-0041",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-09-06T12:00:00Z",
  "aliases": [
    "CVE-2020-25791",
    "CVE-2020-25792",
    "CVE-2020-25793",
    "CVE-2020-25794",
    "CVE-2020-25795",
    "CVE-2020-25796"
  ],
  "related": [],
  "summary": "Multiple soundness issues in Chunk and InlineArray",
  "details": "Chunk:\n\n* Array size is not checked when constructed with `unit()` and `pair()`.\n* Array size is not checked when constructed with `From<InlineArray<A, T>>`.\n* `Clone` and `insert_from` are not panic-safe; A panicking iterator causes memory safety issues with them.\n\nInlineArray:\n\n* Generates unaligned references for types with a large alignment requirement.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "sized-chunks",
        "purl": "pkg:cargo/sized-chunks"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.3"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/sized-chunks"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0041.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/bodil/sized-chunks/issues/11"
    }
  ]
},"372":{
  "id": "RUSTSEC-2020-0104",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-08T12:00:00Z",
  "aliases": [
    "CVE-2020-36211"
  ],
  "related": [],
  "summary": "ImageChunkMut needs bounds on its Send and Sync traits",
  "details": "In the affected versions of this crate, `ImageChunkMut<'_, T>` unconditionally implements `Send` and `Sync`, allowing to create data races.\n\nThis can result in a memory corruption or undefined behavior when non thread-safe types are moved and referenced across thread boundaries.\n\nThe flaw was corrected in commit e7fb2f5 by adding `T: Send` bound to the `Send` impl and adding `T: Sync` bound to the `Sync` impl.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "gfwx",
        "purl": "pkg:cargo/gfwx"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.3.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/gfwx"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0104.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/Devolutions/gfwx-rs/issues/7"
    }
  ]
},"373":{
  "id": "RUSTSEC-2020-0016",
  "modified": "2020-10-02T01:29:11Z",
  "published": "2020-05-01T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`net2` crate has been deprecated; use `socket2` instead",
  "details": "The [`net2`](https://crates.io/crates/net2) crate has been deprecated\nand users are encouraged to considered [`socket2`](https://crates.io/crates/socket2) instead.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "net2",
        "purl": "pkg:cargo/net2"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/net2"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0016.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/deprecrated/net2-rs/commit/3350e3819adf151709047e93f25583a5df681091"
    }
  ]
},"374":{
  "id": "RUSTSEC-2020-0153",
  "modified": "2021-08-22T01:15:34Z",
  "published": "2020-12-31T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`read` on uninitialized buffer may cause UB (bite::read::BiteReadExpandedExt::read_framed_max)",
  "details": "Affected versions of this crate calls a user provided `Read` implementation on an uninitialized buffer.\n\n`Read` on uninitialized buffer is defined as undefined behavior in Rust.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "bite",
        "purl": "pkg:cargo/bite"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/bite"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0153.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/hinaria/bite/issues/1"
    }
  ]
},"375":{
  "id": "RUSTSEC-2021-0118",
  "modified": "2021-12-22T21:15:54Z",
  "published": "2021-09-14T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "`FixedSizeBinaryArray` does not perform bound checks on accessing values and offsets",
  "details": "`FixedSizeBinaryArray` performs insufficient bounds checks, which allows out-of-bounds reads in safe code.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "arrow",
        "purl": "pkg:cargo/arrow"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-exposure"
        ],
        "cvss": null,
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "6.4.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/arrow"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2021-0118.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/apache/arrow-rs/issues/774"
    }
  ]
},"376":{
  "id": "RUSTSEC-2022-0008",
  "modified": "2022-02-04T15:22:53Z",
  "published": "2022-01-02T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "Delegate functions are missing `Send` bound",
  "details": "Affected versions of this crate did not require event handlers to have `Send` bound despite there being no guarantee of them being called on any particular thread, which can potentially lead to data races and undefined behavior.\n\nThe flaw was corrected in commit [afe3252](https://github.com/microsoft/windows-rs/commit/afe32525c22209aa8f632a0f4ad607863b51796a) by adding `Send` bounds.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "windows",
        "purl": "pkg:cargo/windows"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [
            "windows"
          ],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": null,
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.1.2","<": "0.32.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/windows"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2022-0008.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/microsoft/windows-rs/issues/1409"
    }
  ]
},"377":{
  "id": "RUSTSEC-2018-0020",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2018-12-22T12:00:00Z",
  "aliases": [
    "GHSA-6gvc-4jvj-pwq4",
    "CVE-2018-25001"
  ],
  "related": [],
  "summary": "Possible use-after-free with `proplist::Iterator`",
  "details": "Affected versions contained a possible use-after-free issue with property list iteration\ndue to a lack of a lifetime constraint tying the lifetime of a `proplist::Iterator` to the\n`Proplist` object for which it was created. This made it possible for users, without\nexperiencing a compiler error/warning, to destroy the `Proplist` object before the iterator,\nthus destroying the underlying C object the iterator works upon, before the iterator may be\nfinished with it.\n\nThis impacts all versions of the crate before `2.5.0` back to `1.0.5`. Before version\n`1.0.5` the function that produces the iterator was broken to the point of being useless.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "libpulse-binding",
        "purl": "pkg:cargo/libpulse-binding"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "1.0.5","<": "2.5.0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/libpulse-binding"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2018-0020.html"
    },
    {
      "type": "ADVISORY",
      "url": "https://github.com/advisories/GHSA-6gvc-4jvj-pwq4"
    }
  ]
},"378":{
  "id": "RUSTSEC-2020-0145",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-11-02T12:00:00Z",
  "aliases": [
    "CVE-2020-36464"
  ],
  "related": [],
  "summary": "Use-after-free when cloning a partially consumed `Vec` iterator",
  "details": "The `IntoIter` `Clone` implementation clones the whole underlying `Vec`.\nIf the iterator is partially consumed the consumed items will be copied, thus creating a use-after-free access.\n\nA proof of concept is available in the original bug report.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "heapless",
        "purl": "pkg:cargo/heapless"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": [
            "heapless::vec::IntoIter::clone"
          ]
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "memory-exposure"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": "unsound"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "0.6.1"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/heapless"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0145.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/japaric/heapless/issues/181"
    }
  ]
},"379":{
  "id": "RUSTSEC-2020-0057",
  "modified": "2020-10-25T19:05:32Z",
  "published": "2020-10-15T12:00:00Z",
  "aliases": [],
  "related": [],
  "summary": "crate has been renamed to `cipher`",
  "details": "This crate has been renamed from `block-cipher` to `cipher`.\n\nThe new repository location is at:\n\n<https://github.com/RustCrypto/traits/tree/master/cipher>",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "block-cipher",
        "purl": "pkg:cargo/block-cipher"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [],
        "cvss": null,
        "informational": "unmaintained"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/block-cipher"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0057.html"
    },
    {
      "type": "WEB",
      "url": "https://github.com/RustCrypto/traits/pull/337"
    }
  ]
},"380":{
  "id": "RUSTSEC-2020-0112",
  "modified": "2021-10-19T22:14:35Z",
  "published": "2020-12-18T12:00:00Z",
  "aliases": [
    "CVE-2020-36218"
  ],
  "related": [],
  "summary": "ButtplugFutureStateShared allows data race to (!Send|!Sync) objects",
  "details": "`ButtplugFutureStateShared<T>` implements `Send` & `Sync` regardless of `T`.\n\nIf `T: !Send` for `ButtplugFutureStateShared<T>`, it is possible to move non-Send types across thread boundaries (e.g. `T`=`Rc<T>`) and lead to undefined behavior.\nIf `T: !Sync` for `ButtplugFutureStateShared<T>`, it is possible to cause data race to `T` (e.g. `T`=`Arc<Cell<_>>`) and lead to undefined behavior.\n\nThe flaw was corrected in version 1.0.4 by removing manual implementations of `Send`/`Sync` for `ButtplugFutureStateShared<T>` to let rustc generate auto trait implementations with correct trait bounds on `T`.",
  "affected": [
    {
      "package": {
        "ecosystem": "crates.io",
        "name": "buttplug",
        "purl": "pkg:cargo/buttplug"
      },
      "ecosystem_specific": {
        "affects": {
          "arch": [],
          "os": [],
          "functions": []
        }
      },
      "database_specific": {
        "categories": [
          "memory-corruption",
          "thread-safety"
        ],
        "cvss": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
        "informational": null
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              ">=": "0.0.0-0","<": "1.0.4"
            }
          ]
        }
      ]
    }
  ],
  "references": [
    {
      "type": "PACKAGE",
      "url": "https://crates.io/crates/buttplug"
    },
    {
      "type": "ADVISORY",
      "url": "https://rustsec.org/advisories/RUSTSEC-2020-0112.html"
    },
    {
      "type": "REPORT",
      "url": "https://github.com/buttplugio/buttplug-rs/issues/225"
    }
  ]
}}